<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Alvaro Franco Martins</title>
    <link>https://alvarofrancomartins.com/author/alvaro-franco-martins/</link>
      <atom:link href="https://alvarofrancomartins.com/author/alvaro-franco-martins/index.xml" rel="self" type="application/rss+xml" />
    <description>Alvaro Franco Martins</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sun, 13 Dec 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://alvarofrancomartins.com/author/alvaro-franco-martins/avatar_hu24fc0dde7e43204c2d264da5f3800e59_73232_270x270_fill_q100_lanczos_center.jpg</url>
      <title>Alvaro Franco Martins</title>
      <link>https://alvarofrancomartins.com/author/alvaro-franco-martins/</link>
    </image>
    
    <item>
      <title>Spotify data analysis</title>
      <link>https://alvarofrancomartins.com/post/spotify-data-analysis/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://alvarofrancomartins.com/post/spotify-data-analysis/</guid>
      <description>
&lt;!DOCTYPE html&gt;
&lt;head&gt;
  &lt;meta charset=&#34;utf-8&#34;&gt;
  &lt;script src=&#34;https://d3js.org/d3.v5.min.js&#34;&gt;&lt;/script&gt;
  &lt;style&gt;
    text{
      font-size: 16px;
      font-family: Open Sans, sans-serif;
    }
    text.title{
      font-size: 24px;
      font-weight: 500;
    }
    text.subTitle{
      font-weight: 500;
      fill: #777777;
    }
    text.caption{
      font-weight: 400;
      font-size: 14px;
      fill: #777777;
    }
    text.label{
      font-weight: 600;
    }
    text.valueLabel{
     font-weight: 300;
    }
    text.yearText{
      font-size: 64px;
      font-weight: 700;
      opacity: 0.25;
    }
    .tick text {
      fill: #777777;
    }
    .xAxis .tick:nth-child(2) text {
      text-anchor: start;
    }
    .tick line {
      shape-rendering: CrispEdges;
      stroke: #dddddd;
    }
    .tick line.origin{
      stroke: #aaaaaa;
    }
    path.domain{
      display: none;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div id=&#34;chat&#34;&gt;&lt;/div&gt;

  &lt;script&gt;
    var svg = d3.select(&#34;#chat&#34;).append(&#34;svg&#34;)
      .attr(&#34;width&#34;, 960)
      .attr(&#34;height&#34;, 600);
    
    var tickDuration = 500;
    
    var top_n = 12;
    var height = 600;
    var width = 960;
    
    const margin = {
      top: 80,
      right: 0,
      bottom: 5,
      left: 0
    };
  
    let barPadding = (height-(margin.bottom+margin.top))/(top_n*5);
      
    let title = svg.append(&#39;text&#39;)
     .attr(&#39;class&#39;, &#39;title&#39;)
     .attr(&#39;y&#39;, 24)
     .html(&#39;18 years of Interbrandâ€™s Top Global Brands&#39;);
  
    let subTitle = svg.append(&#34;text&#34;)
     .attr(&#34;class&#34;, &#34;subTitle&#34;)
     .attr(&#34;y&#34;, 55)
     .html(&#34;Brand value, $m&#34;);
   
    let caption = svg.append(&#39;text&#39;)
     .attr(&#39;class&#39;, &#39;caption&#39;)
     .attr(&#39;x&#39;, width)
     .attr(&#39;y&#39;, height-5)
     .style(&#39;text-anchor&#39;, &#39;end&#39;);
     // .html(&#39;Source: Interbrand&#39;);

     let year = 2000;
    
  d3.csv(&#39;/brand_values.csv&#39;).then(function(data) {
    //if (error) throw error;
      
      console.log(data);
      
       data.forEach(d =&gt; {
        d.value = +d.value,
        d.lastValue = +d.lastValue,
        d.value = isNaN(d.value) ? 0 : d.value,
        d.year = +d.year,
        d.colour = d3.hsl(Math.random()*360,0.75,0.75)
      });

     console.log(data);
    
     let yearSlice = data.filter(d =&gt; d.year == year &amp;&amp; !isNaN(d.value))
      .sort((a,b) =&gt; b.value - a.value)
      .slice(0, top_n);
  
      yearSlice.forEach((d,i) =&gt; d.rank = i);
    
     console.log(&#39;yearSlice: &#39;, yearSlice)
  
     let x = d3.scaleLinear()
        .domain([0, d3.max(yearSlice, d =&gt; d.value)])
        .range([margin.left, width-margin.right-65]);
  
     let y = d3.scaleLinear()
        .domain([top_n, 0])
        .range([height-margin.bottom, margin.top]);
  
     let xAxis = d3.axisTop()
        .scale(x)
        .ticks(width &gt; 500 ? 5:2)
        .tickSize(-(height-margin.top-margin.bottom))
        .tickFormat(d =&gt; d3.format(&#39;,&#39;)(d));
  
     svg.append(&#39;g&#39;)
       .attr(&#39;class&#39;, &#39;axis xAxis&#39;)
       .attr(&#39;transform&#39;, `translate(0, ${margin.top})`)
       .call(xAxis)
       .selectAll(&#39;.tick line&#39;)
       .classed(&#39;origin&#39;, d =&gt; d == 0);
  
     svg.selectAll(&#39;rect.bar&#39;)
        .data(yearSlice, d =&gt; d.name)
        .enter()
        .append(&#39;rect&#39;)
        .attr(&#39;class&#39;, &#39;bar&#39;)
        .attr(&#39;x&#39;, x(0)+1)
        .attr(&#39;width&#39;, d =&gt; x(d.value)-x(0)-1)
        .attr(&#39;y&#39;, d =&gt; y(d.rank)+5)
        .attr(&#39;height&#39;, y(1)-y(0)-barPadding)
        .style(&#39;fill&#39;, d =&gt; d.colour);
      
     svg.selectAll(&#39;text.label&#39;)
        .data(yearSlice, d =&gt; d.name)
        .enter()
        .append(&#39;text&#39;)
        .attr(&#39;class&#39;, &#39;label&#39;)
        .attr(&#39;x&#39;, d =&gt; x(d.value)-8)
        .attr(&#39;y&#39;, d =&gt; y(d.rank)+5+((y(1)-y(0))/2)+1)
        .style(&#39;text-anchor&#39;, &#39;end&#39;)
        .html(d =&gt; d.name);
      
    svg.selectAll(&#39;text.valueLabel&#39;)
      .data(yearSlice, d =&gt; d.name)
      .enter()
      .append(&#39;text&#39;)
      .attr(&#39;class&#39;, &#39;valueLabel&#39;)
      .attr(&#39;x&#39;, d =&gt; x(d.value)+5)
      .attr(&#39;y&#39;, d =&gt; y(d.rank)+5+((y(1)-y(0))/2)+1)
      .text(d =&gt; d3.format(&#39;,.0f&#39;)(d.lastValue));

    let yearText = svg.append(&#39;text&#39;)
      .attr(&#39;class&#39;, &#39;yearText&#39;)
      .attr(&#39;x&#39;, width-margin.right)
      .attr(&#39;y&#39;, height-25)
      .style(&#39;text-anchor&#39;, &#39;end&#39;)
      .html(~~year)
      .call(halo, 10);
     
   let ticker = d3.interval(e =&gt; {

      yearSlice = data.filter(d =&gt; d.year == year &amp;&amp; !isNaN(d.value))
        .sort((a,b) =&gt; b.value - a.value)
        .slice(0,top_n);

      yearSlice.forEach((d,i) =&gt; d.rank = i);
     
      //console.log(&#39;IntervalYear: &#39;, yearSlice);

      x.domain([0, d3.max(yearSlice, d =&gt; d.value)]); 
     
      svg.select(&#39;.xAxis&#39;)
        .transition()
        .duration(tickDuration)
        .ease(d3.easeLinear)
        .call(xAxis);
    
       let bars = svg.selectAll(&#39;.bar&#39;).data(yearSlice, d =&gt; d.name);
    
       bars
        .enter()
        .append(&#39;rect&#39;)
        .attr(&#39;class&#39;, d =&gt; `bar ${d.name.replace(/\s/g,&#39;_&#39;)}`)
        .attr(&#39;x&#39;, x(0)+1)
        .attr( &#39;width&#39;, d =&gt; x(d.value)-x(0)-1)
        .attr(&#39;y&#39;, d =&gt; y(top_n+1)+5)
        .attr(&#39;height&#39;, y(1)-y(0)-barPadding)
        .style(&#39;fill&#39;, d =&gt; d.colour)
        .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          .attr(&#39;y&#39;, d =&gt; y(d.rank)+5);
          
       bars
        .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          .attr(&#39;width&#39;, d =&gt; x(d.value)-x(0)-1)
          .attr(&#39;y&#39;, d =&gt; y(d.rank)+5);
            
       bars
        .exit()
        .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          .attr(&#39;width&#39;, d =&gt; x(d.value)-x(0)-1)
          .attr(&#39;y&#39;, d =&gt; y(top_n+1)+5)
          .remove();

       let labels = svg.selectAll(&#39;.label&#39;)
          .data(yearSlice, d =&gt; d.name);
     
       labels
        .enter()
        .append(&#39;text&#39;)
        .attr(&#39;class&#39;, &#39;label&#39;)
        .attr(&#39;x&#39;, d =&gt; x(d.value)-8)
        .attr(&#39;y&#39;, d =&gt; y(top_n+1)+5+((y(1)-y(0))/2))
        .style(&#39;text-anchor&#39;, &#39;end&#39;)
        .html(d =&gt; d.name)    
        .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          .attr(&#39;y&#39;, d =&gt; y(d.rank)+5+((y(1)-y(0))/2)+1);
             
    
   	   labels
          .transition()
          .duration(tickDuration)
            .ease(d3.easeLinear)
            .attr(&#39;x&#39;, d =&gt; x(d.value)-8)
            .attr(&#39;y&#39;, d =&gt; y(d.rank)+5+((y(1)-y(0))/2)+1);
     
       labels
          .exit()
          .transition()
            .duration(tickDuration)
            .ease(d3.easeLinear)
            .attr(&#39;x&#39;, d =&gt; x(d.value)-8)
            .attr(&#39;y&#39;, d =&gt; y(top_n+1)+5)
            .remove();
         

     
       let valueLabels = svg.selectAll(&#39;.valueLabel&#39;).data(yearSlice, d =&gt; d.name);
    
       valueLabels
          .enter()
          .append(&#39;text&#39;)
          .attr(&#39;class&#39;, &#39;valueLabel&#39;)
          .attr(&#39;x&#39;, d =&gt; x(d.value)+5)
          .attr(&#39;y&#39;, d =&gt; y(top_n+1)+5)
          .text(d =&gt; d3.format(&#39;,.0f&#39;)(d.lastValue))
          .transition()
            .duration(tickDuration)
            .ease(d3.easeLinear)
            .attr(&#39;y&#39;, d =&gt; y(d.rank)+5+((y(1)-y(0))/2)+1);
            
       valueLabels
          .transition()
            .duration(tickDuration)
            .ease(d3.easeLinear)
            .attr(&#39;x&#39;, d =&gt; x(d.value)+5)
            .attr(&#39;y&#39;, d =&gt; y(d.rank)+5+((y(1)-y(0))/2)+1)
            .tween(&#34;text&#34;, function(d) {
               let i = d3.interpolateRound(d.lastValue, d.value);
               return function(t) {
                 this.textContent = d3.format(&#39;,&#39;)(i(t));
              };
            });
      
     
      valueLabels
        .exit()
        .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          .attr(&#39;x&#39;, d =&gt; x(d.value)+5)
          .attr(&#39;y&#39;, d =&gt; y(top_n+1)+5)
          .remove();
    
      yearText.html(~~year);
     
     if(year == 2018) ticker.stop();
     year = d3.format(&#39;.1f&#39;)((+year) + 0.1);
   },tickDuration);

 });
    
 const halo = function(text, strokeWidth) {
  text.select(function() { return this.parentNode.insertBefore(this.cloneNode(true), this); })
    .style(&#39;fill&#39;, &#39;#ffffff&#39;)
     .style( &#39;stroke&#39;,&#39;#ffffff&#39;)
     .style(&#39;stroke-width&#39;, strokeWidth)
     .style(&#39;stroke-linejoin&#39;, &#39;round&#39;)
     .style(&#39;opacity&#39;, 1);
   
}   
  &lt;/script&gt;
&lt;/body&gt;
</description>
    </item>
    
    <item>
      <title>The dynamical structure of political corruption networks</title>
      <link>https://alvarofrancomartins.com/publication/brazilian-corruption-network/</link>
      <pubDate>Wed, 24 Jan 2018 00:00:00 +0000</pubDate>
      <guid>https://alvarofrancomartins.com/publication/brazilian-corruption-network/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
