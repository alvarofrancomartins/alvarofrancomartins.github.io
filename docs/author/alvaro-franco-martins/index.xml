<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Alvaro Franco Martins</title>
    <link>https://alvarofrancomartins.com/author/alvaro-franco-martins/</link>
      <atom:link href="https://alvarofrancomartins.com/author/alvaro-franco-martins/index.xml" rel="self" type="application/rss+xml" />
    <description>Alvaro Franco Martins</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sun, 13 Dec 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://alvarofrancomartins.com/author/alvaro-franco-martins/avatar_hu24fc0dde7e43204c2d264da5f3800e59_73232_270x270_fill_q100_lanczos_center.jpg</url>
      <title>Alvaro Franco Martins</title>
      <link>https://alvarofrancomartins.com/author/alvaro-franco-martins/</link>
    </image>
    
    <item>
      <title>Spotify data analysis</title>
      <link>https://alvarofrancomartins.com/post/spotify-data-analysis/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://alvarofrancomartins.com/post/spotify-data-analysis/</guid>
      <description>
&lt;!DOCTYPE html&gt;
&lt;head&gt;
  &lt;meta charset=&#34;utf-8&#34;&gt;
  &lt;script src=&#34;https://d3js.org/d3.v5.min.js&#34;&gt;&lt;/script&gt;
  &lt;style&gt;
    text{
      font-size: 16px;
      font-family: Open Sans, sans-serif;
    }
    text.title{
      font-size: 24px;
      font-weight: 500;
    }
    text.subTitle{
      font-weight: 500;
      fill: #777777;
    }
    text.caption{
      font-weight: 400;
      font-size: 14px;
      fill: #777777;
    }
    text.label{
      font-weight: 600;
    }
    text.valueLabel{
     font-weight: 300;
    }
    text.yearText{
      font-size: 64px;
      font-weight: 700;
      opacity: 0.25;
    }
    .tick text {
      fill: #777777;
    }
    .xAxis .tick:nth-child(2) text {
      text-anchor: start;
    }
    .tick line {
      shape-rendering: CrispEdges;
      stroke: #dddddd;
    }
    .tick line.origin{
      stroke: #aaaaaa;
    }
    path.domain{
      display: none;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div id=&#34;chat&#34;&gt;&lt;/div&gt;

  &lt;script&gt;
    var svg = d3.select(&#34;#chat&#34;).append(&#34;svg&#34;)
      .attr(&#34;width&#34;, 960)
      .attr(&#34;height&#34;, 600);
    
    var tickDuration = 500;
    
    var top_n = 12;
    var height = 600;
    var width = 960;
    
    const margin = {
      top: 80,
      right: 0,
      bottom: 5,
      left: 0
    };
  
    let barPadding = (height-(margin.bottom+margin.top))/(top_n*5);
      
    let title = svg.append(&#39;text&#39;)
     .attr(&#39;class&#39;, &#39;title&#39;)
     .attr(&#39;y&#39;, 24)
     .html(&#39;18 years of Interbrandâ€™s Top Global Brands&#39;);
  
    let subTitle = svg.append(&#34;text&#34;)
     .attr(&#34;class&#34;, &#34;subTitle&#34;)
     .attr(&#34;y&#34;, 55)
     .html(&#34;Brand value, $m&#34;);
   
    let caption = svg.append(&#39;text&#39;)
     .attr(&#39;class&#39;, &#39;caption&#39;)
     .attr(&#39;x&#39;, width)
     .attr(&#39;y&#39;, height-5)
     .style(&#39;text-anchor&#39;, &#39;end&#39;);
     // .html(&#39;Source: Interbrand&#39;);

     let year = 2000;
    
  d3.csv(&#39;/brand_values.csv&#39;).then(function(data) {
    //if (error) throw error;
      
      console.log(data);
      
       data.forEach(d =&gt; {
        d.value = +d.value,
        d.lastValue = +d.lastValue,
        d.value = isNaN(d.value) ? 0 : d.value,
        d.year = +d.year,
        d.colour = d3.hsl(Math.random()*360,0.75,0.75)
      });

     console.log(data);
    
     let yearSlice = data.filter(d =&gt; d.year == year &amp;&amp; !isNaN(d.value))
      .sort((a,b) =&gt; b.value - a.value)
      .slice(0, top_n);
  
      yearSlice.forEach((d,i) =&gt; d.rank = i);
    
     console.log(&#39;yearSlice: &#39;, yearSlice)
  
     let x = d3.scaleLinear()
        .domain([0, d3.max(yearSlice, d =&gt; d.value)])
        .range([margin.left, width-margin.right-65]);
  
     let y = d3.scaleLinear()
        .domain([top_n, 0])
        .range([height-margin.bottom, margin.top]);
  
     let xAxis = d3.axisTop()
        .scale(x)
        .ticks(width &gt; 500 ? 5:2)
        .tickSize(-(height-margin.top-margin.bottom))
        .tickFormat(d =&gt; d3.format(&#39;,&#39;)(d));
  
     svg.append(&#39;g&#39;)
       .attr(&#39;class&#39;, &#39;axis xAxis&#39;)
       .attr(&#39;transform&#39;, `translate(0, ${margin.top})`)
       .call(xAxis)
       .selectAll(&#39;.tick line&#39;)
       .classed(&#39;origin&#39;, d =&gt; d == 0);
  
     svg.selectAll(&#39;rect.bar&#39;)
        .data(yearSlice, d =&gt; d.name)
        .enter()
        .append(&#39;rect&#39;)
        .attr(&#39;class&#39;, &#39;bar&#39;)
        .attr(&#39;x&#39;, x(0)+1)
        .attr(&#39;width&#39;, d =&gt; x(d.value)-x(0)-1)
        .attr(&#39;y&#39;, d =&gt; y(d.rank)+5)
        .attr(&#39;height&#39;, y(1)-y(0)-barPadding)
        .style(&#39;fill&#39;, d =&gt; d.colour);
      
     svg.selectAll(&#39;text.label&#39;)
        .data(yearSlice, d =&gt; d.name)
        .enter()
        .append(&#39;text&#39;)
        .attr(&#39;class&#39;, &#39;label&#39;)
        .attr(&#39;x&#39;, d =&gt; x(d.value)-8)
        .attr(&#39;y&#39;, d =&gt; y(d.rank)+5+((y(1)-y(0))/2)+1)
        .style(&#39;text-anchor&#39;, &#39;end&#39;)
        .html(d =&gt; d.name);
      
    svg.selectAll(&#39;text.valueLabel&#39;)
      .data(yearSlice, d =&gt; d.name)
      .enter()
      .append(&#39;text&#39;)
      .attr(&#39;class&#39;, &#39;valueLabel&#39;)
      .attr(&#39;x&#39;, d =&gt; x(d.value)+5)
      .attr(&#39;y&#39;, d =&gt; y(d.rank)+5+((y(1)-y(0))/2)+1)
      .text(d =&gt; d3.format(&#39;,.0f&#39;)(d.lastValue));

    let yearText = svg.append(&#39;text&#39;)
      .attr(&#39;class&#39;, &#39;yearText&#39;)
      .attr(&#39;x&#39;, width-margin.right)
      .attr(&#39;y&#39;, height-25)
      .style(&#39;text-anchor&#39;, &#39;end&#39;)
      .html(~~year)
      .call(halo, 10);
     
   let ticker = d3.interval(e =&gt; {

      yearSlice = data.filter(d =&gt; d.year == year &amp;&amp; !isNaN(d.value))
        .sort((a,b) =&gt; b.value - a.value)
        .slice(0,top_n);

      yearSlice.forEach((d,i) =&gt; d.rank = i);
     
      //console.log(&#39;IntervalYear: &#39;, yearSlice);

      x.domain([0, d3.max(yearSlice, d =&gt; d.value)]); 
     
      svg.select(&#39;.xAxis&#39;)
        .transition()
        .duration(tickDuration)
        .ease(d3.easeLinear)
        .call(xAxis);
    
       let bars = svg.selectAll(&#39;.bar&#39;).data(yearSlice, d =&gt; d.name);
    
       bars
        .enter()
        .append(&#39;rect&#39;)
        .attr(&#39;class&#39;, d =&gt; `bar ${d.name.replace(/\s/g,&#39;_&#39;)}`)
        .attr(&#39;x&#39;, x(0)+1)
        .attr( &#39;width&#39;, d =&gt; x(d.value)-x(0)-1)
        .attr(&#39;y&#39;, d =&gt; y(top_n+1)+5)
        .attr(&#39;height&#39;, y(1)-y(0)-barPadding)
        .style(&#39;fill&#39;, d =&gt; d.colour)
        .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          .attr(&#39;y&#39;, d =&gt; y(d.rank)+5);
          
       bars
        .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          .attr(&#39;width&#39;, d =&gt; x(d.value)-x(0)-1)
          .attr(&#39;y&#39;, d =&gt; y(d.rank)+5);
            
       bars
        .exit()
        .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          .attr(&#39;width&#39;, d =&gt; x(d.value)-x(0)-1)
          .attr(&#39;y&#39;, d =&gt; y(top_n+1)+5)
          .remove();

       let labels = svg.selectAll(&#39;.label&#39;)
          .data(yearSlice, d =&gt; d.name);
     
       labels
        .enter()
        .append(&#39;text&#39;)
        .attr(&#39;class&#39;, &#39;label&#39;)
        .attr(&#39;x&#39;, d =&gt; x(d.value)-8)
        .attr(&#39;y&#39;, d =&gt; y(top_n+1)+5+((y(1)-y(0))/2))
        .style(&#39;text-anchor&#39;, &#39;end&#39;)
        .html(d =&gt; d.name)    
        .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          .attr(&#39;y&#39;, d =&gt; y(d.rank)+5+((y(1)-y(0))/2)+1);
             
    
   	   labels
          .transition()
          .duration(tickDuration)
            .ease(d3.easeLinear)
            .attr(&#39;x&#39;, d =&gt; x(d.value)-8)
            .attr(&#39;y&#39;, d =&gt; y(d.rank)+5+((y(1)-y(0))/2)+1);
     
       labels
          .exit()
          .transition()
            .duration(tickDuration)
            .ease(d3.easeLinear)
            .attr(&#39;x&#39;, d =&gt; x(d.value)-8)
            .attr(&#39;y&#39;, d =&gt; y(top_n+1)+5)
            .remove();
         

     
       let valueLabels = svg.selectAll(&#39;.valueLabel&#39;).data(yearSlice, d =&gt; d.name);
    
       valueLabels
          .enter()
          .append(&#39;text&#39;)
          .attr(&#39;class&#39;, &#39;valueLabel&#39;)
          .attr(&#39;x&#39;, d =&gt; x(d.value)+5)
          .attr(&#39;y&#39;, d =&gt; y(top_n+1)+5)
          .text(d =&gt; d3.format(&#39;,.0f&#39;)(d.lastValue))
          .transition()
            .duration(tickDuration)
            .ease(d3.easeLinear)
            .attr(&#39;y&#39;, d =&gt; y(d.rank)+5+((y(1)-y(0))/2)+1);
            
       valueLabels
          .transition()
            .duration(tickDuration)
            .ease(d3.easeLinear)
            .attr(&#39;x&#39;, d =&gt; x(d.value)+5)
            .attr(&#39;y&#39;, d =&gt; y(d.rank)+5+((y(1)-y(0))/2)+1)
            .tween(&#34;text&#34;, function(d) {
               let i = d3.interpolateRound(d.lastValue, d.value);
               return function(t) {
                 this.textContent = d3.format(&#39;,&#39;)(i(t));
              };
            });
      
     
      valueLabels
        .exit()
        .transition()
          .duration(tickDuration)
          .ease(d3.easeLinear)
          .attr(&#39;x&#39;, d =&gt; x(d.value)+5)
          .attr(&#39;y&#39;, d =&gt; y(top_n+1)+5)
          .remove();
    
      yearText.html(~~year);
     
     if(year == 2018) ticker.stop();
     year = d3.format(&#39;.1f&#39;)((+year) + 0.1);
   },tickDuration);

 });
    
 const halo = function(text, strokeWidth) {
  text.select(function() { return this.parentNode.insertBefore(this.cloneNode(true), this); })
    .style(&#39;fill&#39;, &#39;#ffffff&#39;)
     .style( &#39;stroke&#39;,&#39;#ffffff&#39;)
     .style(&#39;stroke-width&#39;, strokeWidth)
     .style(&#39;stroke-linejoin&#39;, &#39;round&#39;)
     .style(&#39;opacity&#39;, 1);
   
}   
  &lt;/script&gt;
&lt;/body&gt;
</description>
    </item>
    
    <item>
      <title>The computational model of political corruption networks</title>
      <link>https://alvarofrancomartins.com/post/corruption-networks-model/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://alvarofrancomartins.com/post/corruption-networks-model/</guid>
      <description>
&lt;style&gt;
figure {
    display: flex;
    flex-flow: column;
}

figcaption {
  font-size:  17px !important; 
  font-family: &#34;Roboto&#34;, sans-serif;
  font-weight: 500;
  margin-top: 0.5rem !important; 
  margin-bottom: 0rem !important;
  margin-right:  0.5rem !important;
  line-height: 1.25;
  color: #313131;
  text-rendering: optimizeLegibility;
  /* Ensure long words do not overflow into content. */
  overflow-wrap: break-word; 
  word-wrap: break-word;
  word-break: break-word;
  /* Add a hyphen where the word breaks (use `&amp;shy;` to insert a soft-hyphen in a word). */
  -webkit-hyphens: manual;
  -ms-hyphens: manual;
  hyphens: manual; 
}
&lt;/style&gt;

&lt;figure&gt;
    &lt;img src=&#34;rede.png&#34; width=&#34;500px&#34; height=&#34;399px&#34; alt = &#39;ok&#39;/&gt;
    &lt;figcaption&gt;Visualization of an artificial network &lt;br &gt;generated by the corruption network model.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;In this post, I will briefly describe our computational model of political corruption networks. I also present an interactive version of the model and show the code in Python. This model is extensively described and studied in our &lt;a href=&#34;https://www.google.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;publication&lt;/a&gt; in Journal X. I also made a &lt;a href=&#34;https://www.alvarofrancomartins.com/post/corruption-networks&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;post&lt;/a&gt; of our main findings on the political corruption networks of Brazil and Spain.&lt;/p&gt;
&lt;p&gt;If you just want to play with the model networks, skip to &lt;a href=&#34;#play&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;the-model&#34;&gt;The model&lt;/h1&gt;
&lt;p&gt;In summary, we have proposed a model based on two of our main findings about political corruption networks.&lt;/p&gt;
&lt;p&gt;The first finding is that the &lt;strong&gt;number of people per scandal&lt;/strong&gt; is reasonably well described by an exponential distribution with a characteristic number of $1/\lambda \approx 7$ people per scandal. This result was found in both Brazilian and Spanish datasets on corruption scandals.&lt;/p&gt;
&lt;p&gt;The second finding is that the number of &lt;strong&gt;repeat offenders&lt;/strong&gt; can be modeled by the following equation.&lt;/p&gt;
&lt;p&gt;$$r(n) = \alpha n + \beta,$$&lt;/p&gt;
&lt;p&gt;where $n$ is the total number of people. The parameters are&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\alpha$: The recidivism rate (number of repeat offenders / total number of offenders). $\in [0, 1]$.&lt;/li&gt;
&lt;li&gt;$\beta$: The regression coefficient. It controls when the repeat offenders starts to appear in the network. $\in [-\infty, 0)$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The networks in our model grows by the addition of &amp;ldquo;scandals&amp;rdquo; or &lt;a href=&#34;https://en.wikipedia.org/wiki/Complete_graph&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;complete graphs&lt;/a&gt;. The complete graphs (sampled by the exponential distribution with $1/\lambda$) simulate the scandals in the same way that, in a scandal, all individuals involved are connected. As the number of vertices $n$ grows, the number of repeat offenders $r(n)$ also grows and they start to connect different parts of the network. Depending on the value of $\alpha$, we get different network structures. Since the model is stochastic, every network will be different.&lt;/p&gt;
&lt;p&gt;And that is basically it&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. If you want to see in detail how the model was written, skip to the &lt;a href=&#34;#algorithm&#34;&gt;algorithm&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;play&#34;&gt;Play with the model&lt;/h1&gt;
&lt;p&gt;Below you can grow artificial networks generated by our model&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; and see how it evolves as you keep adding the scandals&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. First click in &lt;strong&gt;Start new network&lt;/strong&gt; and then keep clicking on &lt;strong&gt;Add new scandal&lt;/strong&gt;. You will note that, in the beginning, only complete graphs appear. After a while, however, the repeat offenders will show up and then connect different parts of the network.&lt;/p&gt;
&lt;p&gt;If eventually the visualization starts to lag, just click in &lt;strong&gt;Start new network&lt;/strong&gt; again.&lt;/p&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;

  &lt;head&gt;
    &lt;title&gt;Network Corruption Model&lt;/title&gt;

    &lt;style&gt;
      #mynetwork {
        display: inline-block;
        height: 620px;
        width: 100%;
        border: 1px solid #444444;
        background-color: #222222;
      }

      .input-group {
        width: 100%;
        padding:  0px;

      }

      .my_input {
        border: solid 1px #ccc;

        padding-left: 20px;

        border-radius: 5px;
        margin-bottom: 5px;
        }

      .btn-primary{
        font-size: 20px;
        margin-left: 10px;
        margin-bottom: 5px;
      }

      .btn-outline-primary{
        font-size: 20px;
        margin-left: 10px;
        margin-bottom: 5px;
      }

      .row {
        margin-left:2px;
      }
    }
    &lt;/style&gt;

    &lt;script type=&#34;text/javascript&#34; src=&#34;https://unpkg.com/vis-network/standalone/umd/vis-network.min.js&#34;&gt;&lt;/script&gt;
    &lt;script src=&#34;https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js&#34;&gt;&lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div class=&#34;input-group&#34;&gt;
      &lt;label style=&#34;font-size:28px;padding-top:5px;&#34;&gt;$\alpha$ &amp;nbsp&lt;/label&gt;&lt;input class = &#34;my_input&#34; type=&#34;number&#34; name=&#34;recidivism_rate&#34; min=0 max=1 step=0.001 value=0.142 id=&#34;recidivism_rate&#34; oninput= &#34;(!validity.rangeOverflow||(value=1)) &amp;&amp; (!validity.rangeUnderflow||(value=0)) &amp;&amp;
(!validity.stepMismatch||(value=parseInt(this.value)));&#34;/&gt;

      &lt;label style=&#34;font-size:28px;padding-top:5px;&#34;&gt;&amp;nbsp&amp;nbsp $\beta$ &amp;nbsp&lt;/label&gt;&lt;input class = &#34;my_input&#34; type=&#34;number&#34; name=&#34;beta_parameter&#34; min=-100 max=-1 step=-1 value=-11 id=&#34;beta_parameter&#34; oninput= &#34;(!validity.rangeOverflow||(value=-1)) &amp;&amp; 
(!validity.stepMismatch||(value=parseInt(this.value)));&#34; /&gt;

      &lt;div class=&#34;row&#34;&gt;
        &lt;button id=&#34;startNewNetwork&#34; class=&#34;btn btn-primary&#34; onclick=&#34;startNewNetwork();addCompleteGraph();enableAddGraph();&#34;&gt;Start new network&lt;/button&gt;
        &lt;button id=&#34;add_new_scandal&#34; class=&#34;btn btn-outline-primary&#34; onclick=&#34;addCompleteGraph();&#34; disabled&gt;Add new scandal&lt;/button&gt;
      &lt;/div&gt;

    &lt;/div&gt;

    &lt;div id=&#34;mynetwork&#34;&gt;&lt;/div&gt;

    &lt;script type=&#34;text/javascript&#34;&gt;
      var container = document.getElementById(&#34;mynetwork&#34;);

      proba = 0.024;
      lambda = 7.33;

      const options = {
        &#34;autoResize&#34;: true,
        &#34;height&#34;: &#39;100%&#39;,
        &#34;width&#34;: &#39;100%&#39;,
        &#34;physics&#34;: {
          &#34;enabled&#34;: true,
          &#34;forceAtlas2Based&#34;: {
            &#34;theta&#34;: 0.9,
            &#34;gravitationalConstant&#34;: -100,
            &#34;centralGravity&#34;: 0.01,
            &#34;springConstant&#34;: 0.08,
            &#34;springLength&#34;: 100,
            &#34;damping&#34;: 0.7,
            &#34;avoidOverlap&#34;: 0
          },
          &#34;maxVelocity&#34;: 50,
          &#34;minVelocity&#34;: 0.1,
          &#34;solver&#34;: &#39;forceAtlas2Based&#39;,
          &#34;stabilization&#34;: {
            &#34;enabled&#34;: false
          },
          &#34;timestep&#34;: 0.2,
          &#34;adaptiveTimestep&#34;: true,
        },
        &#34;edges&#34;: {
          &#34;smooth&#34;: false
        },
        &#34;nodes&#34;: {
          &#34;shape&#34;: &#34;dot&#34;,
          &#34;size&#34;: 10,
        },
        &#34;interaction&#34;: {
          &#34;dragNodes&#34;: false,
          &#34;dragView&#34;: true
        }
      }

      function startNewNetwork() {
        a = parseFloat(document.getElementById(&#34;recidivism_rate&#34;).value);
        b = parseFloat(document.getElementById(&#34;beta_parameter&#34;).value);

        last_agent_index = 0;
        total_repeated_agents = 0;

        repeated_agent_names = [];
        agent_names = [];

        nodes = new vis.DataSet();
        edges = new vis.DataSet();

        data = {
          nodes: nodes,
          edges: edges,
        };

        return network = new vis.Network(container, data, options);
      }

      function expoSampling(scale) {
        return Math.round(-scale * Math.log(1.0 - Math.random()));
      }

      function addCompleteGraph() {
        // calculate the size of the complete graph to enter the network
        var n_new_agents = expoSampling(lambda);

        while (n_new_agents &lt;= 1) {
          var n_new_agents = expoSampling(lambda);
        }

        // get index from new nodes
        var new_agent_names = [];
        for (let n = last_agent_index; n &lt; last_agent_index + n_new_agents; n++) {
          new_agent_names.push(n);
        }
        last_agent_index += n_new_agents;

        size_network = agent_names.length;

        // apply model
        var new_repeated_agents = Math.round(a * (size_network) + b - total_repeated_agents);

        if (new_repeated_agents &gt; 0) {

          var minimo = Math.min(new_repeated_agents, new_agent_names.length);

          for (let i = 0; i &lt; minimo; i++) {

            if ((Math.random() &lt;= proba) &amp;&amp; (repeated_agent_names.length &gt; 0)) {

              id_old = repeated_agent_names[Math.floor(Math.random() * repeated_agent_names.length)];

            } else {

              let difference = agent_names.filter(x =&gt; !repeated_agent_names.includes(x));

              id_old = difference[Math.floor(Math.random() * difference.length)];

              total_repeated_agents += 1;
            }

            new_agent_names[i] = id_old;
            repeated_agent_names.push(id_old);
          }
        }

        for (let i = 0; i &lt; new_agent_names.length; i++) {
          if (!agent_names.includes(new_agent_names[i])) {
            agent_names.push(new_agent_names[i])
          }
        }

        // add complete graph to the network
        for (let n = 0; n &lt; new_agent_names.length; n++) {
          nodes.update({
            id: new_agent_names[n]
          })
        }

        for (let i = 0; i &lt; new_agent_names.length; i++) {
          for (let j = i + 1; j &lt; new_agent_names.length; j++) {
            let i_ = new_agent_names[i];
            let j_ = new_agent_names[j];

            if (i_ != j_) {
              edges.update({
                from: i_,
                to: j_
              });
            }
          }
        }
        network.fit();
      }

      // button dynamics
      const numSeconds = 1
      document.querySelector(&#39;#add_new_scandal&#39;).addEventListener(&#39;click&#39;, (e) =&gt; {
        e.target.disabled = true
        setTimeout(() =&gt; {
          e.target.disabled = false
        }, numSeconds * 500)
      })

      function enableAddGraph() {
        document.getElementById(&#34;add_new_scandal&#34;).disabled = false;
      }

    &lt;/script&gt;

  &lt;/body&gt;

&lt;/html&gt;
&lt;p&gt;This interactive visualization was made using &lt;a href=&#34;https://visjs.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;visjs&lt;/a&gt;, a browser based visualization library. Below you can see a visual comparison between the Brazilian corruption network (Figure 1) and an artificial network generated using our model and the Brazilian recidivism rate (Figure 2).&lt;/p&gt;
&lt;div class=&#34;parent&#34; style = &#34;display:flex&#34;&gt;
&lt;figure&gt;
&lt;img style = &#34;width: 100%;display: inline-block;padding-left: 5px;&#34; class=&#34;half-page-image&#34; src=&#34;brazil.png&#34;&gt;
&lt;figcaption&gt;Figure 1: The Brazilian political corruption network. &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img style = &#34;width: 100%;display: inline-block; padding-left: 5px;&#34; class=&#34;half-page-image&#34; src=&#34;model.png&#34;&gt;
&lt;figcaption &gt;Figure 2: An artificial network generated using our model. &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;h1 id=&#34;algorithm&#34;&gt;The model algorithm in Python&lt;/h1&gt;
&lt;p&gt;First of all, we need the following packages.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;numpy&lt;/span&gt;          &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;np&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;graph_tool.all&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;gt&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;itertools&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;combinations&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After importing these modules, we can then write the model function:&lt;/p&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-2&#34;&gt;
  &lt;summary&gt;Click to view the full algorithm&lt;/summary&gt;
  &lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;generate_net_links&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tmax&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lambda_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;7.33&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.09&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;11.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;proba&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.024&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    Generate a corruption network based on our model.
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    Parameters
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    ---------
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    tmax : int
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;           Number of iteration steps (default: 100).
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    lambda_ : float
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;           Characteristic number of people per scandal (default: 7.33).
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    a, b : float
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;           Parameters defining the number of repeated agents (nr) as a function
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;           of total number of agents (n): nr = a*n + b (default: 0.09, -11.5).
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    proba : float
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;            Probability of selecting a repeated agent that was already involved in
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;            another scandal (default: 0.024091841863485983).
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    Returns
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    -------
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    links_list : list
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;                 A list of edge lists where each element correspond to
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;                 a particular iteration step.
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    
    &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;                          &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;links&lt;/span&gt;                      &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;links_list&lt;/span&gt;                 &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;agent_names&lt;/span&gt;                &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;last_agent_index&lt;/span&gt;           &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;repeated_agent_names&lt;/span&gt;       &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;total_repeated_agents&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
    
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tmax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;n_new_agents&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;round&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;random&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exponential&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lambda_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;
            
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n_new_agents&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        
            &lt;span class=&#34;n&#34;&gt;new_agent_names&lt;/span&gt;     &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arange&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;last_agent_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;last_agent_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n_new_agents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;last_agent_index&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n_new_agents&lt;/span&gt;
            
            &lt;span class=&#34;n&#34;&gt;new_repeated_agents&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;round&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;agent_names&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;total_repeated_agents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;
            
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new_repeated_agents&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new_repeated_agents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new_agent_names&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))):&lt;/span&gt;

                    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;random&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uniform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;proba&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;repeated_agent_names&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
                        &lt;span class=&#34;c1&#34;&gt;#select from repeated_agent_names&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;repeated_agent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;random&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;choice&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;repeated_agent_names&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
                    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                        &lt;span class=&#34;c1&#34;&gt;#select from agent_names&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;repeated_agent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;random&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;choice&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;repeated_agent_names&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;^&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;agent_names&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;total_repeated_agents&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;

                    &lt;span class=&#34;n&#34;&gt;new_agent_names&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;repeated_agent&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;repeated_agent_names&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;repeated_agent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
                    
            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;agent_&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new_agent_names&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;agent_names&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;agent_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            
            &lt;span class=&#34;n&#34;&gt;new_links&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;combinations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new_agent_names&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
            
            &lt;span class=&#34;n&#34;&gt;links_list&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new_links&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;          &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;links_list&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;This function returns a list of edge lists where each element correspond to a particular iteration step.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span class=&#34;n&#34;&gt;edge_lists&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;generate_net_links&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tmax&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.142&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# e.g, [[(0, 1), (0, 3), ... (5, 6)], [(7, 8), (7, 9) ... (14, 15)], ... ]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To create the network until step $t$ we need to concatenate these lists.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;network&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;edges_list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;           &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Graph&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;directed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;False&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;edge_list_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;concatenate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;edges_list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
    
    &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;add_edge_list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;edge_list_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hashed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;# Since we have not yet dealt with self loops and parallel edges, we will remove them. &lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;gt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;remove_self_loops&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;gt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;remove_parallel_edges&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we can finally generate the network until $t$ steps (100 in this case).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span class=&#34;n&#34;&gt;final_network&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;network&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;edge_lists&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;final_network&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&amp;lt;Graph object, undirected, with 767 vertices and 4805 edges, at 0x7f2789007d60&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For now I think that&amp;rsquo;s about it. Please, do not hesitate to contact me in case you want to talk about my work.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;In order to make our model more precise, we also take into account the fraction of repeat offenders that re-offend in more than two cases. Represented as $p_a$, our empirical results show that $p_a \approx 0.024$ in both Brazilian and Spanish corruption networks.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;The default $\alpha = 0.142$ is the empirical recidivism rate found in the Brazilian corruption network. The recidivism rate found in the Spanish corruption network is $\alpha = 0.09$.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Keep in mind that, depending on the value of $\alpha$, you will have to add enough complete graphs for the repeat offenders appear and start to connect to the other nodes in the network. That is, if $\alpha \to 1$ then the repeat offenders will appear quickly. On the other hand, when $\alpha \to 0$ you will need to add more complete graphs.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>The dynamical structure of political corruption networks</title>
      <link>https://alvarofrancomartins.com/publication/brazilian-corruption-network/</link>
      <pubDate>Wed, 24 Jan 2018 00:00:00 +0000</pubDate>
      <guid>https://alvarofrancomartins.com/publication/brazilian-corruption-network/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
