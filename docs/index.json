[{"authors":null,"categories":null,"content":"Physicist working on complex networks and data science.\n  Download my CV.\n","date":1607817600,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1607817600,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://alvarofrancomartins.com/author/alvaro-franco-martins/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/alvaro-franco-martins/","section":"authors","summary":"Physicist working on complex networks and data science.\n  Download my CV.","tags":null,"title":"Alvaro Franco Martins","type":"authors"},{"authors":["Alvaro Franco Martins"],"categories":null,"content":"    text{ font-size: 16px; font-family: Open Sans, sans-serif; } text.title{ font-size: 24px; font-weight: 500; } text.subTitle{ font-weight: 500; fill: #777777; } text.caption{ font-weight: 400; font-size: 14px; fill: #777777; } text.label{ font-weight: 600; } text.valueLabel{ font-weight: 300; } text.yearText{ font-size: 64px; font-weight: 700; opacity: 0.25; } .tick text { fill: #777777; } .xAxis .tick:nth-child(2) text { text-anchor: start; } .tick line { shape-rendering: CrispEdges; stroke: #dddddd; } .tick line.origin{ stroke: #aaaaaa; } path.domain{ display: none; }      var svg = d3.select(\"#chat\").append(\"svg\") .attr(\"width\", 960) .attr(\"height\", 600); var tickDuration = 500; var top_n = 12; var height = 600; var width = 960; const margin = { top: 80, right: 0, bottom: 5, left: 0 }; let barPadding = (height-(margin.bottom+margin.top))/(top_n*5); let title = svg.append('text') .attr('class', 'title') .attr('y', 24) .html('18 years of Interbrand’s Top Global Brands'); let subTitle = svg.append(\"text\") .attr(\"class\", \"subTitle\") .attr(\"y\", 55) .html(\"Brand value, $m\"); let caption = svg.append('text') .attr('class', 'caption') .attr('x', width) .attr('y', height-5) .style('text-anchor', 'end'); // .html('Source: Interbrand'); let year = 2000; d3.csv('/brand_values.csv').then(function(data) { //if (error) throw error; console.log(data); data.forEach(d = { d.value = +d.value, d.lastValue = +d.lastValue, d.value = isNaN(d.value) ? 0 : d.value, d.year = +d.year, d.colour = d3.hsl(Math.random()*360,0.75,0.75) }); console.log(data); let yearSlice = data.filter(d = d.year == year \u0026\u0026 !isNaN(d.value)) .sort((a,b) = b.value - a.value) .slice(0, top_n); yearSlice.forEach((d,i) = d.rank = i); console.log('yearSlice: ', yearSlice) let x = d3.scaleLinear() .domain([0, d3.max(yearSlice, d = d.value)]) .range([margin.left, width-margin.right-65]); let y = d3.scaleLinear() .domain([top_n, 0]) .range([height-margin.bottom, margin.top]); let xAxis = d3.axisTop() .scale(x) .ticks(width  500 ? 5:2) .tickSize(-(height-margin.top-margin.bottom)) .tickFormat(d = d3.format(',')(d)); svg.append('g') .attr('class', 'axis xAxis') .attr('transform', `translate(0, ${margin.top})`) .call(xAxis) .selectAll('.tick line') .classed('origin', d = d == 0); svg.selectAll('rect.bar') .data(yearSlice, d = d.name) .enter() .append('rect') .attr('class', 'bar') .attr('x', x(0)+1) .attr('width', d = x(d.value)-x(0)-1) .attr('y', d = y(d.rank)+5) .attr('height', y(1)-y(0)-barPadding) .style('fill', d = d.colour); svg.selectAll('text.label') .data(yearSlice, d = d.name) .enter() .append('text') .attr('class', 'label') .attr('x', d = x(d.value)-8) .attr('y', d = y(d.rank)+5+((y(1)-y(0))/2)+1) .style('text-anchor', 'end') .html(d = d.name); svg.selectAll('text.valueLabel') .data(yearSlice, d = d.name) .enter() .append('text') .attr('class', 'valueLabel') .attr('x', d = x(d.value)+5) .attr('y', d = y(d.rank)+5+((y(1)-y(0))/2)+1) .text(d = d3.format(',.0f')(d.lastValue)); let yearText = svg.append('text') .attr('class', 'yearText') .attr('x', width-margin.right) .attr('y', height-25) .style('text-anchor', 'end') .html(~~year) .call(halo, 10); let ticker = d3.interval(e = { yearSlice = data.filter(d = d.year == year \u0026\u0026 !isNaN(d.value)) .sort((a,b) = b.value - a.value) .slice(0,top_n); yearSlice.forEach((d,i) = d.rank = i); //console.log('IntervalYear: ', yearSlice); x.domain([0, d3.max(yearSlice, d = d.value)]); svg.select('.xAxis') .transition() .duration(tickDuration) .ease(d3.easeLinear) .call(xAxis); let bars = svg.selectAll('.bar').data(yearSlice, d = d.name); bars .enter() .append('rect') .attr('class', d = `bar ${d.name.replace(/\\s/g,'_')}`) .attr('x', x(0)+1) .attr( 'width', d = x(d.value)-x(0)-1) .attr('y', d = y(top_n+1)+5) .attr('height', y(1)-y(0)-barPadding) .style('fill', d = d.colour) .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('y', d = y(d.rank)+5); bars .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('width', d = x(d.value)-x(0)-1) .attr('y', d = y(d.rank)+5); bars .exit() .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('width', d = x(d.value)-x(0)-1) .attr('y', d = y(top_n+1)+5) .remove(); let labels = svg.selectAll('.label') .data(yearSlice, d = d.name); labels .enter() .append('text') .attr('class', 'label') .attr('x', d = x(d.value)-8) .attr('y', d = y(top_n+1)+5+((y(1)-y(0))/2)) .style('text-anchor', 'end') .html(d = d.name) .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('y', d = y(d.rank)+5+((y(1)-y(0))/2)+1); labels .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('x', d = x(d.value)-8) .attr('y', d = y(d.rank)+5+((y(1)-y(0))/2)+1); labels .exit() .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('x', d = x(d.value)-8) .attr('y', d = y(top_n+1)+5) .remove(); let valueLabels = svg.selectAll('.valueLabel').data(yearSlice, d = d.name); valueLabels .enter() .append('text') .attr('class', 'valueLabel') .attr('x', d = x(d.value)+5) .attr('y', d = y(top_n+1)+5) .text(d = d3.format(',.0f')(d.lastValue)) .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('y', d = y(d.rank)+5+((y(1)-y(0))/2)+1); valueLabels .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('x', d = x(d.value)+5) .attr('y', d = y(d.rank)+5+((y(1)-y(0))/2)+1) .tween(\"text\", function(d) { let i = d3.interpolateRound(d.lastValue, d.value); return function(t) { this.textContent = d3.format(',')(i(t)); }; }); valueLabels .exit() .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('x', d = x(d.value)+5) .attr('y', d = y(top_n+1)+5) .remove(); yearText.html(~~year); if(year == 2018) ticker.stop(); year = d3.format('.1f')((+year) + 0.1); },tickDuration); }); const halo = function(text, strokeWidth) { text.select(function() { return this.parentNode.insertBefore(this.cloneNode(true), this); }) .style('fill', '#ffffff') .style( 'stroke','#ffffff') .style('stroke-width', strokeWidth) .style('stroke-linejoin', 'round') .style('opacity', 1); }   ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"885b1a8b8905cc09a46eacbcdf2975a2","permalink":"https://alvarofrancomartins.com/post/spotify-data-analysis/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/post/spotify-data-analysis/","section":"post","summary":"NaN","tags":null,"title":"Spotify data analysis","type":"post"},{"authors":["Alvaro Franco Martins"],"categories":["corruption_networks"],"content":"  figure { display: flex; flex-flow: column; } figcaption { font-size: 17px !important; font-family: \"Roboto\", sans-serif; font-weight: 500; margin-top: 0.5rem !important; margin-bottom: 0rem !important; margin-right: 0.5rem !important; line-height: 1.25; color: #313131; text-rendering: optimizeLegibility; /* Ensure long words do not overflow into content. */ overflow-wrap: break-word; word-wrap: break-word; word-break: break-word; /* Add a hyphen where the word breaks (use `\u0026shy;` to insert a soft-hyphen in a word). */ -webkit-hyphens: manual; -ms-hyphens: manual; hyphens: manual; }   Visualization of an artificial network generated by the corruption network model.  In this post, I will briefly describe our computational model of political corruption networks. I also present an interactive version of the model and show the code in Python. This model is extensively described and studied in our publication in Journal X. I also made a post of our main findings on the political corruption networks of Brazil and Spain.\nIf you just want to play with the model networks, skip to here.\nThe model In summary, we have proposed a model based on two of our main findings about political corruption networks.\nThe first finding is that the number of people per scandal is reasonably well described by an exponential distribution with a characteristic number of $1/\\lambda \\approx 7$ people per scandal. This result was found in both Brazilian and Spanish datasets on corruption scandals.\nThe second finding is that the number of repeat offenders can be modeled by the following equation.\n$$r(n) = \\alpha n + \\beta,$$\nwhere $n$ is the total number of people. The parameters are\n $\\alpha$: The recidivism rate (number of repeat offenders / total number of offenders). $\\in [0, 1]$. $\\beta$: The regression coefficient. It controls when the repeat offenders starts to appear in the network. $\\in [-\\infty, 0)$.  The networks in our model grows by the addition of \u0026ldquo;scandals\u0026rdquo; or complete graphs. The complete graphs (sampled by the exponential distribution with $1/\\lambda$) simulate the scandals in the same way that, in a scandal, all individuals involved are connected. As the number of vertices $n$ grows, the number of repeat offenders $r(n)$ also grows and they start to connect different parts of the network. Depending on the value of $\\alpha$, we get different network structures. Since the model is stochastic, every network will be different.\nAnd that is basically it1. If you want to see in detail how the model was written, skip to the algorithm.\nPlay with the model Below you can grow artificial networks generated by our model2 and see how it evolves as you keep adding the scandals3. First click in Start new network and then keep clicking on Add new scandal. You will note that, in the beginning, only complete graphs appear. After a while, however, the repeat offenders will show up and then connect different parts of the network.\nIf eventually the visualization starts to lag, just click in Start new network again.\n Network Corruption Model  #mynetwork { display: inline-block; height: 620px; width: 100%; border: 1px solid #444444; background-color: #222222; } .input-group { width: 100%; padding: 0px; } .my_input { border: solid 1px #ccc; padding-left: 20px; border-radius: 5px; margin-bottom: 5px; } .btn-primary{ font-size: 20px; margin-left: 10px; margin-bottom: 5px; } .btn-outline-primary{ font-size: 20px; margin-left: 10px; margin-bottom: 5px; } .row { margin-left:2px; } }      $\\alpha$ \u0026nbsp\u0026nbsp\u0026nbsp $\\beta$ \u0026nbspStart new network Add new scandal    var container = document.getElementById(\"mynetwork\"); proba = 0.024; lambda = 7.33; const options = { \"autoResize\": true, \"height\": '100%', \"width\": '100%', \"physics\": { \"enabled\": true, \"forceAtlas2Based\": { \"theta\": 0.9, \"gravitationalConstant\": -100, \"centralGravity\": 0.01, \"springConstant\": 0.08, \"springLength\": 100, \"damping\": 0.7, \"avoidOverlap\": 0 }, \"maxVelocity\": 50, \"minVelocity\": 0.1, \"solver\": 'forceAtlas2Based', \"stabilization\": { \"enabled\": false }, \"timestep\": 0.2, \"adaptiveTimestep\": true, }, \"edges\": { \"smooth\": false }, \"nodes\": { \"shape\": \"dot\", \"size\": 10, }, \"interaction\": { \"dragNodes\": false, \"dragView\": true } } function startNewNetwork() { a = parseFloat(document.getElementById(\"recidivism_rate\").value); b = parseFloat(document.getElementById(\"beta_parameter\").value); last_agent_index = 0; total_repeated_agents = 0; repeated_agent_names = []; agent_names = []; nodes = new vis.DataSet(); edges = new vis.DataSet(); data = { nodes: nodes, edges: edges, }; return network = new vis.Network(container, data, options); } function expoSampling(scale) { return Math.round(-scale * Math.log(1.0 - Math.random())); } function addCompleteGraph() { // calculate the size of the complete graph to enter the network var n_new_agents = expoSampling(lambda); while (n_new_agents 0) { var minimo = Math.min(new_repeated_agents, new_agent_names.length); for (let i = 0; i 0)) { id_old = repeated_agent_names[Math.floor(Math.random() * repeated_agent_names.length)]; } else { let difference = agent_names.filter(x = !repeated_agent_names.includes(x)); id_old = difference[Math.floor(Math.random() * difference.length)]; total_repeated_agents += 1; } new_agent_names[i] = id_old; repeated_agent_names.push(id_old); } } for (let i = 0; i { e.target.disabled = true setTimeout(() = { e.target.disabled = false }, numSeconds * 500) }) function enableAddGraph() { document.getElementById(\"add_new_scandal\").disabled = false; }    This interactive visualization was made using visjs, a browser based visualization library. Below you can see a visual comparison between the Brazilian corruption network (Figure 1) and an artificial network generated using our model and the Brazilian recidivism rate (Figure 2).\n Figure 1: The Brazilian political corruption network.    Figure 2: An artificial network generated using our model.    The model algorithm in Python First of all, we need the following packages.\nimport numpy as np import graph_tool.all as gt from itertools import combinations After importing these modules, we can then write the model function:\nClick to view the full algorithm def generate_net_links(tmax = 100, lambda_ = 7.33, a = 0.09, b = -11.5, proba = 0.024): \u0026#34;\u0026#34;\u0026#34; Generate a corruption network based on our model. Parameters --------- tmax : int Number of iteration steps (default: 100). lambda_ : float Characteristic number of people per scandal (default: 7.33). a, b : float Parameters defining the number of repeated agents (nr) as a function of total number of agents (n): nr = a*n + b (default: 0.09, -11.5). proba : float Probability of selecting a repeated agent that was already involved in another scandal (default: 0.024091841863485983). Returns ------- links_list : list A list of edge lists where each element correspond to a particular iteration step. \u0026#34;\u0026#34;\u0026#34; t = 0 links = [] links_list = [] agent_names = set() last_agent_index = 0 repeated_agent_names = set() total_repeated_agents = 0 while t \u0026lt; tmax: n_new_agents = int(np.round(np.random.exponential(lambda_))) if n_new_agents \u0026gt; 1: new_agent_names = [x for x in np.arange(last_agent_index, last_agent_index + n_new_agents)] last_agent_index += n_new_agents new_repeated_agents = int(np.round((a*(len(agent_names)) + b - total_repeated_agents))) if new_repeated_agents \u0026gt; 0: for i in range(min(new_repeated_agents, len(new_agent_names))): if (np.random.uniform() \u0026lt;= proba) \u0026amp; (len(repeated_agent_names) \u0026gt; 0): #select from repeated_agent_names repeated_agent = np.random.choice(list(repeated_agent_names)) else: #select from agent_names repeated_agent = np.random.choice(list(repeated_agent_names^agent_names)) total_repeated_agents += 1 new_agent_names[i] = repeated_agent repeated_agent_names.add(repeated_agent) for agent_ in new_agent_names: agent_names.add(agent_) new_links = list(combinations(new_agent_names, 2)) links_list += [new_links] t += 1 return links_list \n This function returns a list of edge lists where each element correspond to a particular iteration step.\nedge_lists = generate_net_links(tmax = 100, a = 0.142) # e.g, [[(0, 1), (0, 3), ... (5, 6)], [(7, 8), (7, 9) ... (14, 15)], ... ] To create the network until step $t$ we need to concatenate these lists.\ndef network(t, edges_list): g = gt.Graph(directed = False) edge_list_t = np.concatenate(edges_list[:t]) g.add_edge_list(edge_list_t, hashed = True) # Since we have not yet dealt with self loops and parallel edges, we will remove them.  gt.remove_self_loops(g) gt.remove_parallel_edges(g) return g Now we can finally generate the network until $t$ steps (100 in this case).\nfinal_network = network(100, edge_lists) final_network  \u0026lt;Graph object, undirected, with 767 vertices and 4805 edges, at 0x7f2789007d60\u0026gt;\n For now I think that\u0026rsquo;s about it. Please, do not hesitate to contact me in case you want to talk about my work.\n  In order to make our model more precise, we also take into account the fraction of repeat offenders that re-offend in more than two cases. Represented as $p_a$, our empirical results show that $p_a \\approx 0.024$ in both Brazilian and Spanish corruption networks.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The default $\\alpha = 0.142$ is the empirical recidivism rate found in the Brazilian corruption network. The recidivism rate found in the Spanish corruption network is $\\alpha = 0.09$.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Keep in mind that, depending on the value of $\\alpha$, you will have to add enough complete graphs for the repeat offenders appear and start to connect to the other nodes in the network. That is, if $\\alpha \\to 1$ then the repeat offenders will appear quickly. On the other hand, when $\\alpha \\to 0$ you will need to add more complete graphs.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"7147f3c8217ff551f455891882c4d951","permalink":"https://alvarofrancomartins.com/post/corruption-networks-model/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/post/corruption-networks-model/","section":"post","summary":"Play with artificial networks that simulate real political corruption networks","tags":["Corruption networks"],"title":"The computational model of political corruption networks","type":"post"},{"authors":["Alvaro Franco Martins","Haroldo V. Ribeiro","Luiz G. A. Alves","Ervin K. Lenzi","Matjaz Perc"],"categories":null,"content":"","date":1516752000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1516752000,"objectID":"0e36dd8fa8e19bb42073e933b199cd02","permalink":"https://alvarofrancomartins.com/publication/brazilian-corruption-network/","publishdate":"2018-01-24T00:00:00Z","relpermalink":"/publication/brazilian-corruption-network/","section":"publication","summary":"Our research reveals that corruption runs in small groups that rarely comprise more than eight people, in networks that have hubs and a modular structure that encompasses more than one corruption scandal.","tags":["Corruption Networks"],"title":"The dynamical structure of political corruption networks","type":"publication"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"https://alvarofrancomartins.com/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"c9b5771543b03b8149b612b630936a56","permalink":"https://alvarofrancomartins.com/experience/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/experience/","section":"","summary":"","tags":null,"title":"Experiência","type":"widget_page"}]