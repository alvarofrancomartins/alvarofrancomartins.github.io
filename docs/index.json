[{"authors":null,"categories":null,"content":"I\u0026rsquo;m a physicist working on data science and complex networks.\nI hold both a Bachelor\u0026rsquo;s and a Master\u0026rsquo;s degree in Physics from State University of Maringá. At the moment, I\u0026rsquo;m a PhD fellow on the Academic Cooperation Program (PROCAD) in Public Security and Forensic Sciences.\nCurrently I\u0026rsquo;m working on the project \u0026ldquo;Network and data science applied on the study of corruption and organized crime.\u0026rdquo; My primary goal is to extract meaningful patterns from these type of data, uncovering rules and mechanisms governing their structure and dynamics.\n  Download my curriculum vitae (eng / pt).\n","date":1626134400,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1626134400,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://alvarofrancomartins.com/author/alvaro-franco-martins/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/alvaro-franco-martins/","section":"authors","summary":"I\u0026rsquo;m a physicist working on data science and complex networks.\nI hold both a Bachelor\u0026rsquo;s and a Master\u0026rsquo;s degree in Physics from State University of Maringá. At the moment, I\u0026rsquo;m a PhD fellow on the Academic Cooperation Program (PROCAD) in Public Security and Forensic Sciences.","tags":null,"title":"Alvaro Franco Martins","type":"authors"},{"authors":["Alvaro Franco Martins"],"categories":["corruption_networks"],"content":"figure { display: flex; flex-flow: column; } figcaption { font-size: 17px !important; font-family: \"Roboto\", sans-serif; font-weight: 500; margin-top: 1.0rem !important; margin-bottom: 0rem !important; line-height: 1.25; color: #313131; text-rendering: optimizeLegibility; /* Ensure long words do not overflow into content. */ overflow-wrap: break-word; word-wrap: break-word; word-break: break-word; /* Add a hyphen where the word breaks (use `\u0026shy;` to insert a soft-hyphen in a word). */ -webkit-hyphens: manual; -ms-hyphens: manual; hyphens: manual; }   Figure: The community structure of political corruption networks  -- Our main results We have studied the corruption networks of Brazil and Spain. Here I present our main findings:\n The countries have distributions of people per scandal with approximately the same characteristic number ($\\approx$ 7 people). It seems, therefore, that people usually act in small groups when involved in corruption processes.   Figure 1: Complementary cumulative distribution for the number of people per corruption scandals in Spain (left) and Brazil (right).  The networks display small-world properties (high clustering coefficient and low average path length). However, corruption agents have tried to increase their distance as these networks have evolved. This result indicates an agreement with the so-called theory of secret societies, in which the evolution of illegal networks is assumed to maximize concealment.   Figure 2: Spanish (left) and Brazilian (right) political corruption networks.  The networks have degree distributions well described by exponential distributions. Moreover, their characteristic degrees have essentially the same evolving pattern.   Figure 3: Degree distributions and the characteristic degree evolving behavior.  The networks present modular structures and the number of modules grows linearly with the number of scandals.   Figure 4: Number of modules versus number of scandals.  The evolution of the networks are characterized by abrupt changes in the size of the largest connected component, which is due to the coalescence (or connection) of different network components. This process is caused by repeat offenders (i.e, individuals that are involved in at least two scandals).   Figure 5: The coalescence processes observed in both political corruption networks.  The countries have number of repeat offenders that grows linearly with the total number of offenders. The recidivism rates (number of repeat offenders / total number of offenders) are 9% for Spain and 14,2% for Brazil, and stay the same throughout the entire network growth.   Figure 6: The linear relationships between the number of repeat offenders and the total number of people.  The repeat offenders are able to connect different parts of the network and function as brokers. In this sense, the recidivism rate plays an important role on the evolution, structure and dynamics of corruption networks. The difference in the network metrics (such as density and average path length) are then explained by the difference in the recidivism rates.   Figure 7: Spanish political corruption network with repeat offenders highlighted in red.  We have proposed a model to grow networks that model corruption networks taking into account two simple elements presented above: the linear recidivism pattern and the distribution of people per scandal.   Figure 8: The political corruption networks model behavior.  Our model have not only produced visually strikingly similar networks to the empirical ones, but it was capable of describing all the evolving patterns (3, 4 and 5) discussed above.   Figure 9: The model generate artificial networks that are able to reproduce the empirical network properties.   All our results are better described in our publication in the Journal X. Also, an interactive version of our model is available here.\n","date":1626134400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1626134400,"objectID":"7b4a1a1ff33f805bd3e010c90f3c0c68","permalink":"https://alvarofrancomartins.com/post/corruption-networks/","publishdate":"2021-07-13T00:00:00Z","relpermalink":"/post/corruption-networks/","section":"post","summary":"A deep dive into the hidden patterns of corruption networks","tags":["Corruption networks"],"title":"Unveiling the hidden patterns of political corruption networks","type":"post"},{"authors":["Alvaro Franco Martins"],"categories":["redes_corrupcao"],"content":"Nesse post irei brevemente descrever nosso modelo computacional de redes de corrupção política. Também apresentarei uma versão interativa do modelo e seu código em Python. Esse modelo foi descrito e estudado na nossa publicação no Journal X. Eu também fiz uma postagem dos nossos principais resultados relacionados às redes de corrupção do Brasil e da Espanha. Caso você queira apenas interagir com o modelo, pule pra cá.\nO modelo computacional De forma geral, propusemos um modelo baseado em dois dos nossos principais resultados sobre redes de corrupção política. A nossa primeira descoberta foi que o número de pessoas por escândalo pode ser razoavelmente bem descrito por uma distribui-ção exponencial com valor característico de aproximadamente 7 pessoas. Esse resultado foi encontrado em ambas as base de dados (brasileira e espanhola) sobre escândalos de corrupção.\nNosso segundo resultado é que o número de pessoas reincidentes em corrupção pode ser modelada pela seguinte equação.\n$$r(n) = \\alpha n + \\beta,$$\nonde $n$ é o número total de pessoas e os parâmetros acima são\n $\\alpha$: Taxa de reincidência criminosa (número de reincidentes / número total de criminosos). $\\in [0, 1]$. $\\beta$: O coeficiente linear. Esse coeficiente controla quando os reincidentes começam a surgir na rede. $\\in [-\\infty, 0)$.  As redes no nosso modelo crescem com a adição de \u0026ldquo;escândalos\u0026rdquo; ou grafos completos. Os grafos completos (com tamanho amostrado pela distribuição exponencial do número de pessoas comentado acima) simulam escândalos de corrupção da mesma forma que, em um escândalo, todos seus envolvidos estão conectados. Ao passo que o número de vértices $n$ cresce, o número de reincidentes $r(n)$ também cresce. Esses reincidentes então conectam diferentes partes da rede. Dependendo do valor de $\\alpha$, obtém-se diferentes estruturas de rede1. Uma vez que o modelo é estocástico, cada nova rede gerada será diferente.\nE é basicamente isso2. Caso você queira saber em detalhes como o modelo foi escrito, pule para o algoritmo.\nInteraja com o modelo Abaixo você pode crescer as redes artificiais geradas pelo modelo3 e ver como elas se desenvolvem ao passo que você adiciona novos escândalos4. Primeiramente, clique em Iniciar nova rede e depois clique diversas vezes em Adicionar novo escândalo. Você vai notar que inicialmente surgem apenas grafos completos. No entanto, depois de um tempo, os reincidentes começarão a aparecer e então eles irão conectar diferentes partes da rede. Se depois de um tempo a visualização começar a ficar lenta, clique novamente em Iniciar nova rede.\n Network Corruption Model  #mynetwork { display: inline-block; height: 620px; width: 100%; border: 1px solid #444444; background-color: #222222; } .input-group { width: 100%; padding: 0px; } .my_input { border: solid 1px #ccc; padding-left: 20px; border-radius: 5px; margin-bottom: 5px; } .btn-primary{ font-size: 20px; margin-left: 10px; margin-bottom: 5px; } .btn-outline-primary{ font-size: 20px; margin-left: 10px; margin-bottom: 5px; } .row { margin-left:2px; } }      $\\alpha$ \u0026nbsp\u0026nbsp\u0026nbsp $\\beta$ \u0026nbspIniciar nova rede Adicionar novo escândalo    var container = document.getElementById(\"mynetwork\"); proba = 0.024; lambda = 7.33; const options = { \"autoResize\": true, \"height\": '100%', \"width\": '100%', \"physics\": { \"enabled\": true, \"forceAtlas2Based\": { \"theta\": 0.9, \"gravitationalConstant\": -100, \"centralGravity\": 0.01, \"springConstant\": 0.08, \"springLength\": 100, \"damping\": 0.7, \"avoidOverlap\": 0 }, \"maxVelocity\": 50, \"minVelocity\": 0.1, \"solver\": 'forceAtlas2Based', \"stabilization\": { \"enabled\": false }, \"timestep\": 0.2, \"adaptiveTimestep\": true, }, \"edges\": { \"smooth\": false }, \"nodes\": { \"shape\": \"dot\", \"size\": 10, }, \"interaction\": { \"dragNodes\": false, \"dragView\": true } } function startNewNetwork() { a = parseFloat(document.getElementById(\"recidivism_rate\").value); b = parseFloat(document.getElementById(\"beta_parameter\").value); last_agent_index = 0; total_repeated_agents = 0; repeated_agent_names = []; agent_names = []; nodes = new vis.DataSet(); edges = new vis.DataSet(); data = { nodes: nodes, edges: edges, }; return network = new vis.Network(container, data, options); } function expoSampling(scale) { return Math.round(-scale * Math.log(1.0 - Math.random())); } function addCompleteGraph() { // calculate the size of the complete graph to enter the network var n_new_agents = expoSampling(lambda); while (n_new_agents 0) { var minimo = Math.min(new_repeated_agents, new_agent_names.length); for (let i = 0; i 0)) { id_old = repeated_agent_names[Math.floor(Math.random() * repeated_agent_names.length)]; } else { let difference = agent_names.filter(x = !repeated_agent_names.includes(x)); id_old = difference[Math.floor(Math.random() * difference.length)]; total_repeated_agents += 1; } new_agent_names[i] = id_old; repeated_agent_names.push(id_old); } } for (let i = 0; i { e.target.disabled = true setTimeout(() = { e.target.disabled = false }, numSeconds * 500) }) function enableAddGraph() { document.getElementById(\"add_new_scandal\").disabled = false; }    Essa visualização interativa foi criada utilizando a biblioteca de Javascript visjs. Abaixo você pode ver uma comparação visual entre a verdadeira rede de corrupção brasileira (Figura 1) e uma simulação do nosso modelo utilizando o valor de reincidência empírico (Figura 2).\n Figura 1: Rede brasileira de corrupção política.    Figura 2: Rede artificial gerada pelo nosso modelo usando a taxa de reincidência brasileira.    Código do modelo em Python Para escrever e usar o modelo, precisamos das seguintes bibliotecas.\nimport numpy as np import graph_tool.all as gt from itertools import combinations Depois de importá-las, podemos escrever a função que gera as redes do modelo:\nClique para abrir o código completo def generate_net_links(tmax = 100, lambda_ = 7.33, a = 0.09, b = -11.5, proba = 0.024): \u0026#34;\u0026#34;\u0026#34; Generate a corruption network based on our model. Parameters --------- tmax : int Number of iteration steps (default: 100). lambda_ : float Characteristic number of people per scandal (default: 7.33). a, b : float Parameters defining the number of repeated agents (nr) as a function of total number of agents (n): nr = a*n + b (default: 0.09, -11.5). proba : float Probability of selecting a repeated agent that was already involved in another scandal (default: 0.024091841863485983). Returns ------- links_list : list A list of edge lists where each element correspond to a particular iteration step. \u0026#34;\u0026#34;\u0026#34; t = 0 links = [] links_list = [] agent_names = set() last_agent_index = 0 repeated_agent_names = set() total_repeated_agents = 0 while t \u0026lt; tmax: n_new_agents = int(np.round(np.random.exponential(lambda_))) if n_new_agents \u0026gt; 1: new_agent_names = [x for x in np.arange(last_agent_index, last_agent_index + n_new_agents)] last_agent_index += n_new_agents new_repeated_agents = int(np.round((a*(len(agent_names)) + b - total_repeated_agents))) if new_repeated_agents \u0026gt; 0: for i in range(min(new_repeated_agents, len(new_agent_names))): if (np.random.uniform() \u0026lt;= proba) \u0026amp; (len(repeated_agent_names) \u0026gt; 0): #select from repeated_agent_names repeated_agent = np.random.choice(list(repeated_agent_names)) else: #select from agent_names repeated_agent = np.random.choice(list(repeated_agent_names^agent_names)) total_repeated_agents += 1 new_agent_names[i] = repeated_agent repeated_agent_names.add(repeated_agent) for agent_ in new_agent_names: agent_names.add(agent_) new_links = list(combinations(new_agent_names, 2)) links_list += [new_links] t += 1 return links_list \n Esse função returna uma lista de listas de ligações onde cada elemento corresponde a uma determinada iteração. Por exemplo,\nedge_lists = generate_net_links(tmax = 100, a = 0.142) # e.g, [[(0, 1), (0, 3), ... (5, 6)], [(7, 8), (7, 9) ... (14, 15)], ... ] Para criar a rede até o passo $t$, precisamos concatenar essas listas:\ndef network(t, edges_list): g = gt.Graph(directed = False) edge_list_t = np.concatenate(edges_list[:t]) g.add_edge_list(edge_list_t, hashed = True) # Since we have not yet dealt with self loops and parallel edges, we will remove them.  gt.remove_self_loops(g) gt.remove_parallel_edges(g) return g Agora podemos finalmente gerar a rede até o passo $t$ (que nesse caso é igual a 100).\nfinal_network = network(100, edge_lists) final_network  \u0026lt;Graph object, undirected, with 767 vertices and 4805 edges, at 0x7f2789007d60\u0026gt;\n   Os envolvidos reincidentes são capazes de conectar diferentes partes da rede. Quanto maior a taxa de reincidência $\\alpha$, mais densamente conectada será a rede. Por outro lado, se $\\alpha$ é pequeno ($\u0026lt;0.065$) a rede será esparsamente conectada, com um número maior de componentes.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Para deixar o modelo mais preciso, nós também levamos em conta a fração do número de reincidentes que reofendem em mais de dois casos. Representado como $p_a$, nossos resultados empíricos mostraram que $p_a \\approx 0.024$ nas duas redes de corrupção brasileira e espanhola.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n O valor de $\\alpha = 0.142$ é o valor empírico da taxa de reincidência para a rede de corrupção brasileira. A taxa de reincidência da rede de corrupção espanhola é $\\alpha = 0.09$\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Tenha em mente que dependendo do valor de $\\alpha$, irá demorar um pouco para que os reincidentes comecem a surgir. Isto é, se $\\alpha \\to 1$ então os reincidentes irão aparecer logo no início. Por outro lado, quando $\\alpha \\to 0$, você precisará adicionar bastantes grafos completos até que eles apareçam.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1620864000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1620864000,"objectID":"7c3166ed90d0450a177534746ed949ea","permalink":"https://alvarofrancomartins.com/post/modelo-redes-corrupcao/","publishdate":"2021-05-13T00:00:00Z","relpermalink":"/post/modelo-redes-corrupcao/","section":"post","summary":"Interaja com redes artificiais capazes de simular verdadeiras redes de corrupção política","tags":["Redes de corrupção"],"title":"Modelo computacional de redes de corrupção política","type":"post"},{"authors":["Alvaro Franco Martins"],"categories":null,"content":"    text{ font-size: 16px; font-family: Open Sans, sans-serif; } text.title{ font-size: 24px; font-weight: 500; } text.subTitle{ font-weight: 500; fill: #777777; } text.caption{ font-weight: 400; font-size: 14px; fill: #777777; } text.label{ font-weight: 600; } text.valueLabel{ font-weight: 300; } text.yearText{ font-size: 64px; font-weight: 700; opacity: 0.25; } .tick text { fill: #777777; } .xAxis .tick:nth-child(2) text { text-anchor: start; } .tick line { shape-rendering: CrispEdges; stroke: #dddddd; } .tick line.origin{ stroke: #aaaaaa; } path.domain{ display: none; }      var svg = d3.select(\"#chat\").append(\"svg\") .attr(\"width\", 960) .attr(\"height\", 600); var tickDuration = 500; var top_n = 12; var height = 600; var width = 960; const margin = { top: 80, right: 0, bottom: 5, left: 0 }; let barPadding = (height-(margin.bottom+margin.top))/(top_n*5); let title = svg.append('text') .attr('class', 'title') .attr('y', 24) .html('18 years of Interbrand’s Top Global Brands'); let subTitle = svg.append(\"text\") .attr(\"class\", \"subTitle\") .attr(\"y\", 55) .html(\"Brand value, $m\"); let caption = svg.append('text') .attr('class', 'caption') .attr('x', width) .attr('y', height-5) .style('text-anchor', 'end'); // .html('Source: Interbrand'); let year = 2000; d3.csv('/brand_values.csv').then(function(data) { //if (error) throw error; console.log(data); data.forEach(d = { d.value = +d.value, d.lastValue = +d.lastValue, d.value = isNaN(d.value) ? 0 : d.value, d.year = +d.year, d.colour = d3.hsl(Math.random()*360,0.75,0.75) }); console.log(data); let yearSlice = data.filter(d = d.year == year \u0026\u0026 !isNaN(d.value)) .sort((a,b) = b.value - a.value) .slice(0, top_n); yearSlice.forEach((d,i) = d.rank = i); console.log('yearSlice: ', yearSlice) let x = d3.scaleLinear() .domain([0, d3.max(yearSlice, d = d.value)]) .range([margin.left, width-margin.right-65]); let y = d3.scaleLinear() .domain([top_n, 0]) .range([height-margin.bottom, margin.top]); let xAxis = d3.axisTop() .scale(x) .ticks(width  500 ? 5:2) .tickSize(-(height-margin.top-margin.bottom)) .tickFormat(d = d3.format(',')(d)); svg.append('g') .attr('class', 'axis xAxis') .attr('transform', `translate(0, ${margin.top})`) .call(xAxis) .selectAll('.tick line') .classed('origin', d = d == 0); svg.selectAll('rect.bar') .data(yearSlice, d = d.name) .enter() .append('rect') .attr('class', 'bar') .attr('x', x(0)+1) .attr('width', d = x(d.value)-x(0)-1) .attr('y', d = y(d.rank)+5) .attr('height', y(1)-y(0)-barPadding) .style('fill', d = d.colour); svg.selectAll('text.label') .data(yearSlice, d = d.name) .enter() .append('text') .attr('class', 'label') .attr('x', d = x(d.value)-8) .attr('y', d = y(d.rank)+5+((y(1)-y(0))/2)+1) .style('text-anchor', 'end') .html(d = d.name); svg.selectAll('text.valueLabel') .data(yearSlice, d = d.name) .enter() .append('text') .attr('class', 'valueLabel') .attr('x', d = x(d.value)+5) .attr('y', d = y(d.rank)+5+((y(1)-y(0))/2)+1) .text(d = d3.format(',.0f')(d.lastValue)); let yearText = svg.append('text') .attr('class', 'yearText') .attr('x', width-margin.right) .attr('y', height-25) .style('text-anchor', 'end') .html(~~year) .call(halo, 10); let ticker = d3.interval(e = { yearSlice = data.filter(d = d.year == year \u0026\u0026 !isNaN(d.value)) .sort((a,b) = b.value - a.value) .slice(0,top_n); yearSlice.forEach((d,i) = d.rank = i); //console.log('IntervalYear: ', yearSlice); x.domain([0, d3.max(yearSlice, d = d.value)]); svg.select('.xAxis') .transition() .duration(tickDuration) .ease(d3.easeLinear) .call(xAxis); let bars = svg.selectAll('.bar').data(yearSlice, d = d.name); bars .enter() .append('rect') .attr('class', d = `bar ${d.name.replace(/\\s/g,'_')}`) .attr('x', x(0)+1) .attr( 'width', d = x(d.value)-x(0)-1) .attr('y', d = y(top_n+1)+5) .attr('height', y(1)-y(0)-barPadding) .style('fill', d = d.colour) .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('y', d = y(d.rank)+5); bars .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('width', d = x(d.value)-x(0)-1) .attr('y', d = y(d.rank)+5); bars .exit() .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('width', d = x(d.value)-x(0)-1) .attr('y', d = y(top_n+1)+5) .remove(); let labels = svg.selectAll('.label') .data(yearSlice, d = d.name); labels .enter() .append('text') .attr('class', 'label') .attr('x', d = x(d.value)-8) .attr('y', d = y(top_n+1)+5+((y(1)-y(0))/2)) .style('text-anchor', 'end') .html(d = d.name) .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('y', d = y(d.rank)+5+((y(1)-y(0))/2)+1); labels .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('x', d = x(d.value)-8) .attr('y', d = y(d.rank)+5+((y(1)-y(0))/2)+1); labels .exit() .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('x', d = x(d.value)-8) .attr('y', d = y(top_n+1)+5) .remove(); let valueLabels = svg.selectAll('.valueLabel').data(yearSlice, d = d.name); valueLabels .enter() .append('text') .attr('class', 'valueLabel') .attr('x', d = x(d.value)+5) .attr('y', d = y(top_n+1)+5) .text(d = d3.format(',.0f')(d.lastValue)) .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('y', d = y(d.rank)+5+((y(1)-y(0))/2)+1); valueLabels .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('x', d = x(d.value)+5) .attr('y', d = y(d.rank)+5+((y(1)-y(0))/2)+1) .tween(\"text\", function(d) { let i = d3.interpolateRound(d.lastValue, d.value); return function(t) { this.textContent = d3.format(',')(i(t)); }; }); valueLabels .exit() .transition() .duration(tickDuration) .ease(d3.easeLinear) .attr('x', d = x(d.value)+5) .attr('y', d = y(top_n+1)+5) .remove(); yearText.html(~~year); if(year == 2018) ticker.stop(); year = d3.format('.1f')((+year) + 0.1); },tickDuration); }); const halo = function(text, strokeWidth) { text.select(function() { return this.parentNode.insertBefore(this.cloneNode(true), this); }) .style('fill', '#ffffff') .style( 'stroke','#ffffff') .style('stroke-width', strokeWidth) .style('stroke-linejoin', 'round') .style('opacity', 1); }   ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"885b1a8b8905cc09a46eacbcdf2975a2","permalink":"https://alvarofrancomartins.com/post/spotify-data-analysis/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/post/spotify-data-analysis/","section":"post","summary":"NaN","tags":null,"title":"Spotify data analysis","type":"post"},{"authors":["Alvaro Franco Martins"],"categories":["corruption_networks"],"content":"figure { display: flex; flex-flow: column; } figcaption { font-size: 17px !important; font-family: \"Roboto\", sans-serif; font-weight: 500; margin-top: 0.5rem !important; margin-bottom: 0rem !important; margin-right: 0.5rem !important; line-height: 1.25; color: #313131; text-rendering: optimizeLegibility; /* Ensure long words do not overflow into content. */ overflow-wrap: break-word; word-wrap: break-word; word-break: break-word; /* Add a hyphen where the word breaks (use `\u0026shy;` to insert a soft-hyphen in a word). */ -webkit-hyphens: manual; -ms-hyphens: manual; hyphens: manual; }   Visualization of an artificial network generated by the corruption network model.  -- In this post, I will briefly describe our computational model of political corruption networks. I also present an interactive version of the model and show the code in Python. This model is extensively described and studied in our publication in Journal X. I also made a post of our main findings on the political corruption networks of Brazil and Spain. If you just want to play with the model networks, skip to here.\nThe model In summary, we have proposed a model based on two of our main findings about political corruption networks. The first finding is that the number of people per scandal is reasonably well described by an exponential distribution with a characteristic number of $1/\\lambda \\approx 7$ people per scandal. This result was found in both Brazilian and Spanish datasets on corruption scandals.\nThe second finding is that the number of repeat offenders can be modeled by the following equation.\n$$r(n) = \\alpha n + \\beta,$$\nwhere $n$ is the total number of people. The parameters are\n $\\alpha$: The recidivism rate (number of repeat offenders / total number of offenders). $\\in [0, 1]$. $\\beta$: The regression coefficient. It controls when the repeat offenders starts to appear in the network. $\\in [-\\infty, 0)$.  The networks in our model grows by the addition of \u0026ldquo;scandals\u0026rdquo; or complete graphs. The complete graphs (sampled by the exponential distribution with $1/\\lambda$) simulate the scandals in the same way that, in a scandal, all individuals involved are connected. As the number of vertices $n$ grows, the number of repeat offenders $r(n)$ also grows and they start to connect different parts of the network. In this sense, the recidivism rate plays an important role on the evolution, structure and dynamics of corruption networks. Therefore, depending on the value of $\\alpha$, we get different network structures1. Moreover, since the model is stochastic, every network will be different.\nAnd that is basically it 2. If you want to see in detail how the model was written, skip to the algorithm.\nPlay with the model Below you can grow artificial networks generated by our model3 and see how it evolves as you keep adding the scandals4. First click in Start new network and then keep clicking on Add new scandal. You will note that, in the beginning, only complete graphs appear. After a while, however, the repeat offenders will show up and then connect different parts of the network. If eventually the visualization starts to lag, just click in Start new network again.\n Network Corruption Model  #mynetwork { display: inline-block; height: 620px; width: 100%; border: 1px solid #444444; background-color: #222222; } .input-group { width: 100%; padding: 0px; } .my_input { border: solid 1px #ccc; padding-left: 20px; border-radius: 5px; margin-bottom: 5px; } .btn-primary{ font-size: 20px; margin-left: 10px; margin-bottom: 5px; } .btn-outline-primary{ font-size: 20px; margin-left: 10px; margin-bottom: 5px; } .row { margin-left:2px; }      $\\alpha$ \u0026nbsp\u0026nbsp\u0026nbsp $\\beta$ \u0026nbspStart new network Add new scandal    var container = document.getElementById(\"mynetwork\"); proba = 0.024; lambda = 7.33; const options = { \"autoResize\": true, \"height\": '100%', \"width\": '100%', \"physics\": { \"enabled\": true, \"forceAtlas2Based\": { \"theta\": 0.9, \"gravitationalConstant\": -100, \"centralGravity\": 0.01, \"springConstant\": 0.08, \"springLength\": 100, \"damping\": 0.7, \"avoidOverlap\": 0 }, \"maxVelocity\": 50, \"minVelocity\": 0.1, \"solver\": 'forceAtlas2Based', \"stabilization\": { \"enabled\": false }, \"timestep\": 0.2, \"adaptiveTimestep\": true, }, \"edges\": { \"smooth\": false }, \"nodes\": { \"shape\": \"dot\", \"size\": 10, }, \"interaction\": { \"dragNodes\": false, \"dragView\": true } } function startNewNetwork() { a = parseFloat(document.getElementById(\"recidivism_rate\").value); b = parseFloat(document.getElementById(\"beta_parameter\").value); last_agent_index = 0; total_repeated_agents = 0; repeated_agent_names = []; agent_names = []; nodes = new vis.DataSet(); edges = new vis.DataSet(); data = { nodes: nodes, edges: edges, }; return network = new vis.Network(container, data, options); } function expoSampling(scale) { return Math.round(-scale * Math.log(1.0 - Math.random())); } function addCompleteGraph() { // calculate the size of the complete graph to enter the network var n_new_agents = expoSampling(lambda); while (n_new_agents 0) { var minimo = Math.min(new_repeated_agents, new_agent_names.length); for (let i = 0; i 0)) { id_old = repeated_agent_names[Math.floor(Math.random() * repeated_agent_names.length)]; } else { let difference = agent_names.filter(x = !repeated_agent_names.includes(x)); id_old = difference[Math.floor(Math.random() * difference.length)]; total_repeated_agents += 1; } new_agent_names[i] = id_old; repeated_agent_names.push(id_old); } } for (let i = 0; i { e.target.disabled = true setTimeout(() = { e.target.disabled = false }, numSeconds * 500) }) function enableAddGraph() { document.getElementById(\"add_new_scandal\").disabled = false; }    This interactive visualization was made using visjs, a browser based visualization library. Below you can see a visual comparison between the Brazilian corruption network (Figure 1) and an artificial network generated using our model and the Brazilian recidivism rate (Figure 2).\n Figure 1: The Brazilian political corruption network.    Figure 2: An artificial network generated using our model.    The model algorithm in Python First of all, we need the following packages.\nimport numpy as np import graph_tool.all as gt from itertools import combinations After importing these modules, we can then write the model function:\nClick to view the full algorithm def generate_net_links(tmax = 100, lambda_ = 7.33, a = 0.09, b = -11.5, proba = 0.024): \u0026#34;\u0026#34;\u0026#34; Generate a corruption network based on our model. Parameters --------- tmax : int Number of iteration steps (default: 100). lambda_ : float Characteristic number of people per scandal (default: 7.33). a, b : float Parameters defining the number of repeated agents (nr) as a function of total number of agents (n): nr = a*n + b (default: 0.09, -11.5). proba : float Probability of selecting a repeated agent that was already involved in another scandal (default: 0.024091841863485983). Returns ------- links_list : list A list of edge lists where each element correspond to a particular iteration step. \u0026#34;\u0026#34;\u0026#34; t = 0 links = [] links_list = [] agent_names = set() last_agent_index = 0 repeated_agent_names = set() total_repeated_agents = 0 while t \u0026lt; tmax: n_new_agents = int(np.round(np.random.exponential(lambda_))) if n_new_agents \u0026gt; 1: new_agent_names = [x for x in np.arange(last_agent_index, last_agent_index + n_new_agents)] last_agent_index += n_new_agents new_repeated_agents = int(np.round((a*(len(agent_names)) + b - total_repeated_agents))) if new_repeated_agents \u0026gt; 0: for i in range(min(new_repeated_agents, len(new_agent_names))): if (np.random.uniform() \u0026lt;= proba) \u0026amp; (len(repeated_agent_names) \u0026gt; 0): #select from repeated_agent_names repeated_agent = np.random.choice(list(repeated_agent_names)) else: #select from agent_names repeated_agent = np.random.choice(list(repeated_agent_names^agent_names)) total_repeated_agents += 1 new_agent_names[i] = repeated_agent repeated_agent_names.add(repeated_agent) for agent_ in new_agent_names: agent_names.add(agent_) new_links = list(combinations(new_agent_names, 2)) links_list += [new_links] t += 1 return links_list \n This function returns a list of edge lists where each element correspond to a particular iteration step.\nedge_lists = generate_net_links(tmax = 100, a = 0.142) # e.g, [[(0, 1), (0, 3), ... (5, 6)], [(7, 8), (7, 9) ... (14, 15)], ... ] To create the network until step $t$ we need to concatenate these lists.\ndef network(t, edges_list): g = gt.Graph(directed = False) edge_list_t = np.concatenate(edges_list[:t]) g.add_edge_list(edge_list_t, hashed = True) # Since we have not yet dealt with self loops and parallel edges, we will remove them.  gt.remove_self_loops(g) gt.remove_parallel_edges(g) return g Now we can finally generate the network until $t$ steps (100 in this case).\nfinal_network = network(100, edge_lists) final_network  \u0026lt;Graph object, undirected, with 767 vertices and 4805 edges, at 0x7f2789007d60\u0026gt;\n For now I think that\u0026rsquo;s about it. Please, do not hesitate to contact me in case you want to talk about my work.\n  The recidivism rate controls, for instance, whether the networks are more or less densely connected.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n In order to make our model more precise, we also take into account the fraction of repeat offenders that re-offend in more than two cases. Represented as $p_a$, our empirical results show that $p_a \\approx 0.024$ in both Brazilian and Spanish corruption networks.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The default $\\alpha = 0.142$ is the empirical recidivism rate found in the Brazilian corruption network. The recidivism rate found in the Spanish corruption network is $\\alpha = 0.09$.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Keep in mind that, depending on the value of $\\alpha$, you will have to add enough complete graphs for the repeat offenders appear and start to connect to the other nodes in the network. That is, if $\\alpha \\to 1$ then the repeat offenders will appear quickly. On the other hand, when $\\alpha \\to 0$ you will need to add more complete graphs.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"7147f3c8217ff551f455891882c4d951","permalink":"https://alvarofrancomartins.com/post/corruption-networks-model/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/post/corruption-networks-model/","section":"post","summary":"Play with artificial networks that simulate real political corruption networks","tags":["Corruption networks"],"title":"The computational model of political corruption networks","type":"post"},{"authors":["Alvaro Franco Martins","Haroldo V. Ribeiro","Luiz G. A. Alves","Ervin K. Lenzi","Matjaz Perc"],"categories":null,"content":"","date":1516752000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1516752000,"objectID":"0e36dd8fa8e19bb42073e933b199cd02","permalink":"https://alvarofrancomartins.com/publication/brazilian-corruption-network/","publishdate":"2018-01-24T00:00:00Z","relpermalink":"/publication/brazilian-corruption-network/","section":"publication","summary":"Our research reveals that corruption runs in small groups that rarely comprise more than eight people, in networks that have hubs and a modular structure that encompasses more than one corruption scandal.","tags":["Corruption Networks"],"title":"The dynamical structure of political corruption networks","type":"publication"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"https://alvarofrancomartins.com/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"c9b5771543b03b8149b612b630936a56","permalink":"https://alvarofrancomartins.com/experience/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/experience/","section":"","summary":"","tags":null,"title":"Experiência","type":"widget_page"}]