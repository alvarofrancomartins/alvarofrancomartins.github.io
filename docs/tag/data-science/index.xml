<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data science | Alvaro Franco Martins</title>
    <link>https://alvarofrancomartins.com/tag/data-science/</link>
      <atom:link href="https://alvarofrancomartins.com/tag/data-science/index.xml" rel="self" type="application/rss+xml" />
    <description>Data science</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sun, 23 Mar 2025 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://alvarofrancomartins.com/media/sharing.png</url>
      <title>Data science</title>
      <link>https://alvarofrancomartins.com/tag/data-science/</link>
    </image>
    
    <item>
      <title>Sensibilidade, especificidade e curvas ROC: Um guia visual para não se confundir mais!</title>
      <link>https://alvarofrancomartins.com/post/ml-metrics/</link>
      <pubDate>Sun, 23 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://alvarofrancomartins.com/post/ml-metrics/</guid>
      <description>&lt;h1 id=&#34;descomplicando-as-métricas-de-classificação&#34;&gt;Descomplicando as métricas de classificação&lt;/h1&gt;
&lt;p&gt;Você já se viu diante do desafio de memorizar todas aquelas métricas de classificação?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&amp;ldquo;Era sensibilidade que priorizava acertar os positivos ou era especificidade? E a precisão&amp;hellip; se refere a quê mesmo?&amp;quot;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Se você já se fez essas perguntas, não está sozinho. Essas métricas são confusas porque muitas vezes são ensinadas apenas com fórmulas matemáticas, sem uma compreensão visual ou prática do que realmente significam.&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;Neste post, vamos transformar conceitos abstratos em intuições visuais. Ao invés de decorar fórmulas, você vai entender o que cada métrica realmente representa e quando deve ser aplicada. Esta postagem inclui simulações interativas, assim você poderá observar como cada métrica se comporta em tempo real.&lt;/p&gt;
&lt;h2 id=&#34;o-cenário-básico-separando-positivos-e-negativos&#34;&gt;O cenário básico: separando positivos e negativos&lt;/h2&gt;
&lt;div style=&#34;display: flex; align-items: center;&#34;&gt;
&lt;div style=&#34;flex: 1; padding-right: 20px;&#34;&gt;
&lt;p&gt;No diagrama apresentado, utilizamos uma representação visual simplificada para facilitar a compreensão dos conceitos. O retângulo é dividido em duas seções distintas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&#34;color: red;&#34;&gt;Lado esquerdo&lt;/span&gt;: representa casos negativos (exemplos: pessoas sem doença, transação legítima, etc&amp;hellip;);&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color: blue;&#34;&gt;Lado direito&lt;/span&gt;: representa casos positivos (exemplos: pessoas com doença, transação fraudulenta, etc&amp;hellip;).&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div style=&#34;flex: 1;&#34;&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /post/ml-metrics/img/separacao_hu3f58973be1ed0536e63e064b1fdcb669_68287_3de44b4fcbfe16561abd143e6202f3b9.png 400w,
               /post/ml-metrics/img/separacao_hu3f58973be1ed0536e63e064b1fdcb669_68287_0451326f5176334c2702dee5ca1ce4d3.png 760w,
               /post/ml-metrics/img/separacao_hu3f58973be1ed0536e63e064b1fdcb669_68287_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://alvarofrancomartins.com/post/ml-metrics/img/separacao_hu3f58973be1ed0536e63e064b1fdcb669_68287_3de44b4fcbfe16561abd143e6202f3b9.png&#34;
               width=&#34;60%&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Para entender as métricas de classificação, podemos visualizar o que um modelo está fazendo. Considere que nosso modelo (por exemplo, que determina se a pessoa possui ou não determinada doença) é representado por um círculo azul no centro desse retângulo. O círculo, na verdade, é a fronteira de decisão do modelo. Tudo o que está dentro deste círculo o modelo prevê que é positivo. Portanto, tudo que está fora dele é previsto como negativo.&lt;/p&gt;
&lt;div style=&#34;display: flex; align-items: center; margin-top: 30px;&#34;&gt;
&lt;div style=&#34;flex: 1; padding-right: 20px;&#34;&gt;
&lt;br&gt;
&lt;p&gt;Observamos claramente que o modelo não é perfeito&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Ele comete dois tipos de erros:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Classifica alguns negativos como positivos (dentro do círculo, à esquerda);&lt;/li&gt;
&lt;li&gt;Classifica alguns positivos como negativos (fora do círculo, à direita).&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div style=&#34;flex: 1;&#34;&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /post/ml-metrics/img/separacao_modelo_hu04f02f5379807a38989e453224f67c1d_87762_3d7256dca6c2f1a5a69583887cc6efb5.png 400w,
               /post/ml-metrics/img/separacao_modelo_hu04f02f5379807a38989e453224f67c1d_87762_1ea16d9e8305ae7435780ea59b24fec3.png 760w,
               /post/ml-metrics/img/separacao_modelo_hu04f02f5379807a38989e453224f67c1d_87762_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://alvarofrancomartins.com/post/ml-metrics/img/separacao_modelo_hu04f02f5379807a38989e453224f67c1d_87762_3d7256dca6c2f1a5a69583887cc6efb5.png&#34;
               width=&#34;60%&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;as-quatro-situações-fundamentais&#34;&gt;As quatro situações fundamentais&lt;/h2&gt;
&lt;div style=&#34;display: flex; align-items: center;&#34;&gt;
&lt;div style=&#34;flex: 1; padding-right: 20px;&#34;&gt;
&lt;p&gt;Esses erros&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; e acertos possuem nomes e são representados nas quatro regiões da figura ao lado. Suas descrições são as seguintes:&lt;/p&gt;
&lt;br&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sigla&lt;/th&gt;
&lt;th&gt;Descrição&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;TP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Verdadeiro positivo, acerto&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;FN&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Falso negativo, erro de omissão, subestimação&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;FP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Falso positivo, falso alarme, superestimação&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;TN&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Verdadeiro negativo, rejeição correta&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
  &lt;/div&gt;
&lt;div style=&#34;flex: 1;&#34;&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;pt-br&#34;&gt;
&lt;head&gt;
  &lt;meta charset=&#34;UTF-8&#34;&gt;
  &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;
  &lt;title&gt;Visualização Interativa das Métricas de Classificação&lt;/title&gt;
  &lt;style&gt;
    .simulation_container {
      max-width: 600px;
      margin: 0 auto;
      font-family: Arial, sans-serif;
    }
    
    .visualization {
      position: relative;
      width: 400px;
      height: 400px;
      margin: 20px auto;
      border: 2px solid #000;
      background-color: #ffffff;
    }
    
    .divider {
      position: absolute;
      top: 0;
      left: 50%;
      width: 2px;
      height: 100%;
      background-color: #000;
    }
    
    .circle {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 65%;
      height: 65%;
      border: 3px solid blue;
      border-radius: 50%;
      background-color: rgba(0, 0, 255, 0.08);
      z-index: 1;
    }
    
    .dot {
      position: absolute;
      width: 7px;
      height: 7px;
      border-radius: 50%;
      margin: -3.5px 0 0 -3.5px;
    }
    
    .negative {
      background-color: red;
    }
    
    .positive {
      background-color: blue;
    }
    
    .label {
      position: absolute;
      font-size: 32px;
      font-weight: bold;
      z-index: 3;
      cursor: pointer;
      padding: 6px 12px;
      border-radius: 8px;
      transition: all 0.2s ease;
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 1);
      color: #000;
      background-color: rgba(255, 255, 255, 0.9);
      border: 2px dashed rgba(0, 0, 0, 0.1);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .label:hover {
      transform: scale(1.1);
      background-color: rgba(255, 255, 255, 1);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 1);
      border: 2px dashed rgba(0, 0, 0, 0.7);
    }
    
    /* Posicionamento correto baseado nas posições fornecidas */
    .tn-label {
      top: 7%;
      left: 10%;
      color: #000;
    }
    
    .fn-label {
      top: 7%;
      right: 10%;
      color: #000;
    }
    
    .fp-label {
      bottom: 42%;
      left: 30%;
      color: #000;
    }
    
    .tp-label {
      bottom: 42%;
      right: 30%;
      color: #000;
    }
    
    .side-label {
      position: absolute;
      font-size: 24px;
      font-weight: bold;
      bottom: -40px;
      text-align: center;
      width: 45%;
    }
    
    .negative-label {
      left: 0;
      color: #ff0000;
    }
    
    .positive-label {
      right: 0;
      color: blue;
    }
    
    .info-box {
      position: absolute;
      top: 95%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(255, 255, 255, 1);
      border: 2px solid #333;
      border-radius: 10px;
      padding: 7px;
      width: 100%;
      max-width: 400px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      z-index: 10;
      display: none;
    }
    
    .info-title {
      font-size: 22px;
      font-weight: bold;
      margin-bottom: 15px;
      text-align: center;
      border-bottom: 1px solid #ddd;
      padding-bottom: 10px;
    }
    
    .info-description {
      font-size: 16px;
      margin-bottom: 15px;
      line-height: 1.5;
      white-space: pre-line;
    }
    
    .close-btn {
      background-color: #4a5568;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      display: block;
      margin: 0 auto;
      font-weight: bold;
      transition: background-color 0.2s;
    }
    
    .close-btn:hover {
      background-color: #2d3748;
    }
    
    .instructions {
      text-align: center;
      margin-bottom: 20px;
      font-style: italic;
      color: #555;
      background-color: #f0f0f0;
      padding: 12px;
      border-radius: 8px;
      border-left: 6px solid #4a5568;
      font-size: 18px;
    }
    
    /* Responsividade para telas menores */
    @media (max-width: 600px) {
      .visualization {
        width: 100%;
        height: 90vw;
        max-height: 500px;
      }
      
      .label {
        font-size: 18px;
      }
      
      .side-label {
        font-size: 18px;
      }
    }

    table {
      font-size: 1rem !important;
      width: 100%;
    }
    table td, table th {
      padding: 18px;
      font-size: 1rem !important;
}

  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class=&#34;simulation_container&#34;&gt;    
    &lt;div class=&#34;visualization&#34; id=&#34;classification-viz&#34;&gt;
      &lt;div class=&#34;divider&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;circle&#34;&gt;&lt;/div&gt;
      
      &lt;!-- Rótulos clicáveis --&gt;
      &lt;div class=&#34;label tn-label&#34; data-type=&#34;tn&#34;&gt;TN&lt;/div&gt;
      &lt;div class=&#34;label fn-label&#34; data-type=&#34;fn&#34;&gt;FN&lt;/div&gt;
      &lt;div class=&#34;label fp-label&#34; data-type=&#34;fp&#34;&gt;FP&lt;/div&gt;
      &lt;div class=&#34;label tp-label&#34; data-type=&#34;tp&#34;&gt;TP&lt;/div&gt;
      
      &lt;!-- Rótulos laterais --&gt;
      &lt;div class=&#34;side-label negative-label&#34;&gt;Negativos&lt;/div&gt;
      &lt;div class=&#34;side-label positive-label&#34;&gt;Positivos&lt;/div&gt;
      
      &lt;!-- Caixa de informações --&gt;
      &lt;div class=&#34;info-box&#34; id=&#34;info-box&#34;&gt;
        &lt;div class=&#34;info-title&#34; id=&#34;info-title&#34;&gt;&lt;/div&gt;
        &lt;div class=&#34;info-description&#34; id=&#34;info-description&#34;&gt;&lt;/div&gt;
        &lt;button class=&#34;close-btn&#34; id=&#34;close-btn&#34;&gt;Fechar&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  
  &lt;script&gt;
    document.addEventListener(&#39;DOMContentLoaded&#39;, function() {
      const visualization = document.getElementById(&#39;classification-viz&#39;);
      const infoBox = document.getElementById(&#39;info-box&#39;);
      const infoTitle = document.getElementById(&#39;info-title&#39;);
      const infoDescription = document.getElementById(&#39;info-description&#39;);
      const closeBtn = document.getElementById(&#39;close-btn&#39;);
      const circle = document.querySelector(&#39;.circle&#39;);
      
      // Dados para cada quadrante - definições precisas
      const quadrantInfo = {
        tn: {
          title: &#39;TN - Verdadeiro Negativo&#39;,
          description: &#39;O modelo classificou como NEGATIVO, e realmente era NEGATIVO.\n\nEstes são os pontos vermelhos (negativos) que estão FORA do círculo (classificados como negativos pelo modelo).&#39;
        },
        fn: {
          title: &#39;FN - Falso Negativo&#39;,
          description: &#39;O modelo classificou como NEGATIVO, mas na verdade era POSITIVO.\n\nEstes são os pontos azuis (positivos) que estão FORA do círculo (classificados como negativos pelo modelo).&#39;
        },
        fp: {
          title: &#39;FP - Falso Positivo&#39;,
          description: &#39;O modelo classificou como POSITIVO, mas na verdade era NEGATIVO.\n\nEstes são os pontos vermelhos (negativos) que estão DENTRO do círculo (classificados como positivos pelo modelo).&#39;
        },
        tp: {
          title: &#39;TP - Verdadeiro Positivo&#39;,
          description: &#39;O modelo classificou como POSITIVO, e realmente era POSITIVO.\n\nEstes são os pontos azuis (positivos) que estão DENTRO do círculo (classificados como positivos pelo modelo).&#39;
        }
      };
      
      // Obter as dimensões do círculo e área de visualização
      function getCircleProperties() {
        const rect = circle.getBoundingClientRect();
        const vizRect = visualization.getBoundingClientRect();
        
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const radius = rect.width / 2;
        
        return { centerX, centerY, radius, vizWidth: vizRect.width, vizHeight: vizRect.height };
      }
      
      // Verificar se um ponto está dentro do círculo
      function isInsideCircle(x, y) {
        const rect = circle.getBoundingClientRect();
        const vizRect = visualization.getBoundingClientRect();
        
        const circleX = rect.left + rect.width / 2 - vizRect.left;
        const circleY = rect.top + rect.height / 2 - vizRect.top;
        const radius = rect.width / 2;
        
        const dx = x - circleX;
        const dy = y - circleY;
        return dx * dx + dy * dy &lt;= radius * radius;
      }
      
      // Gerar pontos aleatórios
      function generateDots() {
        // Limpar pontos existentes
        const existingDots = document.querySelectorAll(&#39;.dot&#39;);
        existingDots.forEach(dot =&gt; dot.remove());
        
        const { vizWidth, vizHeight } = getCircleProperties();
        const midX = vizWidth / 2;
        
        // Gerar novos pontos
        for (let i = 0; i &lt; 500; i++) {
          const dot = document.createElement(&#39;div&#39;);
          dot.className = &#39;dot&#39;;
          
          // Metade dos pontos são negativos (esquerda), metade positivos (direita)
          const isPositive = i &gt;= 250;
          dot.classList.add(isPositive ? &#39;positive&#39; : &#39;negative&#39;);
          
          // Posicionar os pontos respeitando a divisão central
          let x, y;
          
          if (isPositive) {
            // Pontos positivos (lado direito)
            x = Math.random() * (vizWidth / 2 - 10) + midX + 5;  // 5px de margem da linha central
          } else {
            // Pontos negativos (lado esquerdo)
            x = Math.random() * (vizWidth / 2 - 10) + 5;         // 5px de margem da borda
          }
          
          y = Math.random() * (vizHeight - 10) + 5;    // 5px de margem da borda superior e inferior
          
          // Melhor distribuição para TN, FP, FN, TP
          const insideCircle = isInsideCircle(x, y);
          
          // Queremos uma distribuição de pontos que seja consistente com a visualização
          // Se for FP (negativo dentro do círculo) ou FN (positivo fora do círculo)
          // reduzimos a probabilidade para ter mais TP e TN
          if ((!isPositive &amp;&amp; insideCircle) || (isPositive &amp;&amp; !insideCircle)) {
            if (Math.random() &gt; 0.6) {
              // Tentar novamente para obter mais TP e TN
              i--;
              continue;
            }
          }
          
          dot.style.left = x + &#39;px&#39;;
          dot.style.top = y + &#39;px&#39;;
          
          visualization.appendChild(dot);
        }
      }
      
      // Mostrar informações quando um rótulo é clicado
      const labels = document.querySelectorAll(&#39;.label&#39;);
      labels.forEach(label =&gt; {
        label.addEventListener(&#39;click&#39;, function() {
          const type = this.getAttribute(&#39;data-type&#39;);
          const info = quadrantInfo[type];
          
          infoTitle.textContent = info.title;
          infoDescription.textContent = info.description;
          
          infoBox.style.display = &#39;block&#39;;
          
          // Destacar o rótulo clicado
          labels.forEach(l =&gt; l.style.backgroundColor = &#39;&#39;);
          this.style.backgroundColor = &#39;rgba(255, 255, 255, 0.8)&#39;;
        });
      });
      
      // Fechar a caixa de informações
      closeBtn.addEventListener(&#39;click&#39;, function() {
        infoBox.style.display = &#39;none&#39;;
        
        // Remover destaque de todos os rótulos
        labels.forEach(l =&gt; l.style.backgroundColor = &#39;&#39;);
      });
      
      // Fechar a caixa quando clicar fora dela
      visualization.addEventListener(&#39;click&#39;, function(e) {
        if (e.target === visualization || e.target === document.querySelector(&#39;.circle&#39;) || e.target === document.querySelector(&#39;.divider&#39;)) {
          infoBox.style.display = &#39;none&#39;;
          
          // Remover destaque de todos os rótulos
          labels.forEach(l =&gt; l.style.backgroundColor = &#39;&#39;);
        }
      });
      
      // Inicializar a visualização
      window.addEventListener(&#39;resize&#39;, generateDots);
      generateDots();
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;br&gt;
&lt;div class=&#34;instructions&#34;&gt;No painel acima, clique em cada rótulo (TN, FP, FN, TP) para aprender mais sobre as quatro situações fundamentais. &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;p&gt;Com base nessas quatro situações, podemos calcular métricas que nos ajudam a avaliar o desempenho de um modelo.&lt;/p&gt;
&lt;h2 id=&#34;entendendo-cada-métrica-visualmente&#34;&gt;Entendendo Cada Métrica Visualmente&lt;/h2&gt;
&lt;h3 id=&#34;1-sensibilidade-recall-ou-tpr&#34;&gt;1. Sensibilidade (Recall ou TPR)&lt;/h3&gt;
&lt;div style=&#34;display: flex; align-items: center;&#34;&gt;
&lt;div style=&#34;flex: 1; padding-right: 20px;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Pergunta-chave: &amp;ldquo;De todos os casos realmente positivos, quantos o modelo classificou como positivos?&amp;quot;&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;div style=&#34;text-align: center;&#34;&gt;
$$\text{Sensibilidade} = \frac{TP}{TP + FN}$$
&lt;/div&gt;
&lt;br&gt;
&lt;p&gt;A &lt;strong&gt;sensibilidade&lt;/strong&gt; indica quanto do lado direito foi coberto pelo círculo — ou seja, a proporção entre a parte azul dentro do círculo (TP) e todo o lado direito (TP + FN). O foco da sensibilidade é não deixar passar casos positivos.&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&#34;flex: 1;&#34;&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /post/ml-metrics/img/tpr_hu83acb151a3873ecb5acdbb19fdef72f9_88387_a28f82fe6d55a7ba15b2887f3d912c99.png 400w,
               /post/ml-metrics/img/tpr_hu83acb151a3873ecb5acdbb19fdef72f9_88387_0975becfbc9e35fa0d01b25d49bd1e2b.png 760w,
               /post/ml-metrics/img/tpr_hu83acb151a3873ecb5acdbb19fdef72f9_88387_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://alvarofrancomartins.com/post/ml-metrics/img/tpr_hu83acb151a3873ecb5acdbb19fdef72f9_88387_a28f82fe6d55a7ba15b2887f3d912c99.png&#34;
               width=&#34;60%&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;2-taxa-de-falsos-negativos-fnr&#34;&gt;2. Taxa de Falsos Negativos (FNR)&lt;/h3&gt;
&lt;div style=&#34;display: flex; align-items: center;&#34;&gt;
&lt;div style=&#34;flex: 1; padding-right: 20px;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Pergunta-chave: &amp;ldquo;De todos os casos realmente positivos, quantos o modelo classificou como negativos?&amp;quot;&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;div style=&#34;text-align: center;&#34;&gt;
$$\text{FNR} = \frac{FN}{TP + FN} = 1 - \text{Sensibilidade}$$
&lt;/div&gt;
&lt;br&gt;
&lt;p&gt;É a proporção entre o que o círculo não cobriu do lado direito (FN) em relação ao lado direito inteiro (TP + FN).&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&#34;flex: 1;&#34;&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /post/ml-metrics/img/fnr_hu12acc418103c2365ca44d1387167aa06_82701_9e9a288eb11238d76cbe97cd7e1c418e.png 400w,
               /post/ml-metrics/img/fnr_hu12acc418103c2365ca44d1387167aa06_82701_576f67fb3635cc80f3b1360bfdea8255.png 760w,
               /post/ml-metrics/img/fnr_hu12acc418103c2365ca44d1387167aa06_82701_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://alvarofrancomartins.com/post/ml-metrics/img/fnr_hu12acc418103c2365ca44d1387167aa06_82701_9e9a288eb11238d76cbe97cd7e1c418e.png&#34;
               width=&#34;60%&#34;
               height=&#34;626&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;3-especificidade-tnr&#34;&gt;3. Especificidade (TNR)&lt;/h3&gt;
&lt;div style=&#34;display: flex; align-items: center;&#34;&gt;
&lt;div style=&#34;flex: 1; padding-right: 20px;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Pergunta-chave: &amp;ldquo;De todos os casos realmente negativos, quantos o modelo classificou como negativos?&amp;quot;&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;div style=&#34;text-align: center;&#34;&gt;
$$\text{Especificidade} = \frac{TN}{TN + FP}$$
&lt;/div&gt;
&lt;br&gt;
&lt;p&gt;A &lt;strong&gt;especificidade&lt;/strong&gt; representa a proporção do lado esquerdo que o círculo não cobriu (TN) em relação ao lado esquerdo inteiro (TN + FP).&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&#34;flex: 1;&#34;&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /post/ml-metrics/img/tnr_hu898c36af63707939ee0fc9f92b553a00_87616_e1f42cb1315e2f27e339e4783b54b2bb.png 400w,
               /post/ml-metrics/img/tnr_hu898c36af63707939ee0fc9f92b553a00_87616_05e1cd55e74a7ccc1c39fbd7cca622ac.png 760w,
               /post/ml-metrics/img/tnr_hu898c36af63707939ee0fc9f92b553a00_87616_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://alvarofrancomartins.com/post/ml-metrics/img/tnr_hu898c36af63707939ee0fc9f92b553a00_87616_e1f42cb1315e2f27e339e4783b54b2bb.png&#34;
               width=&#34;60%&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;4-taxa-de-falsos-positivos-fpr&#34;&gt;4. Taxa de Falsos Positivos (FPR)&lt;/h3&gt;
&lt;div style=&#34;display: flex; align-items: center;&#34;&gt;
&lt;div style=&#34;flex: 1; padding-right: 20px;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Pergunta-chave: &amp;ldquo;De todos os casos realmente negativos, quantos o modelo  classificou como positivos?&amp;quot;&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;div style=&#34;text-align: center;&#34;&gt;
$$\text{FPR} = \frac{FP}{TN + FP} = 1 - \text{Especificidade}$$
&lt;/div&gt;
&lt;br&gt;
&lt;p&gt;É a proporção entre o que o círculo cobriu do lado esquerdo (FP) e o lado esquerdo inteiro (TN + FP). É o complemento da especificidade.&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&#34;flex: 1;&#34;&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /post/ml-metrics/img/fpr_hu2d1878e6feaffb64491d611c1a439f6e_88246_385ab302cd18c19653c23c4fa6b2f037.png 400w,
               /post/ml-metrics/img/fpr_hu2d1878e6feaffb64491d611c1a439f6e_88246_53c00ec90bea212034d32e374515e84f.png 760w,
               /post/ml-metrics/img/fpr_hu2d1878e6feaffb64491d611c1a439f6e_88246_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://alvarofrancomartins.com/post/ml-metrics/img/fpr_hu2d1878e6feaffb64491d611c1a439f6e_88246_385ab302cd18c19653c23c4fa6b2f037.png&#34;
               width=&#34;60%&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;5-precisão-precision-ou-ppv&#34;&gt;5. Precisão (Precision ou PPV)&lt;/h3&gt;
&lt;div style=&#34;display: flex; align-items: center;&#34;&gt;
&lt;div style=&#34;flex: 1; padding-right: 20px;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Pergunta-chave: &amp;ldquo;Quando o modelo diz &amp;lsquo;positivo&amp;rsquo;, com que frequência ele está correto?&amp;quot;&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;div style=&#34;text-align: center;&#34;&gt;
$$\text{Precisão} = \frac{TP}{TP + FP}$$
&lt;/div&gt;
&lt;br&gt;
&lt;p&gt;Considerando a região interna do círculo (tudo o que o modelo classificou como positivo), a &lt;strong&gt;precisão&lt;/strong&gt; representa a proporção da área à direita (TP) em relação à área total do círculo (TP + FP). O foco da precisão é não dar falsos alarmes.&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&#34;flex: 1;&#34;&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /post/ml-metrics/img/prec_hu87f480ea6cdf39eeaeec3942b42ab3b6_113788_a994763ebed4b5ae20598529275689ae.png 400w,
               /post/ml-metrics/img/prec_hu87f480ea6cdf39eeaeec3942b42ab3b6_113788_11a057d11ebf9b73109b79018bc3f7c0.png 760w,
               /post/ml-metrics/img/prec_hu87f480ea6cdf39eeaeec3942b42ab3b6_113788_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://alvarofrancomartins.com/post/ml-metrics/img/prec_hu87f480ea6cdf39eeaeec3942b42ab3b6_113788_a994763ebed4b5ae20598529275689ae.png&#34;
               width=&#34;60%&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;6-acurácia&#34;&gt;6. Acurácia&lt;/h3&gt;
&lt;div style=&#34;display: flex; align-items: center;&#34;&gt;
&lt;div style=&#34;flex: 1; padding-right: 20px;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Pergunta-chave: &amp;ldquo;Qual a porcentagem total de previsões corretas?&amp;quot;&lt;/strong&gt;&lt;/p&gt;
&lt;div style=&#34;text-align: center;&#34;&gt;
$$\text{Acurácia} = \frac{TP + TN}{TP + TN + FP + FN}$$
&lt;/div&gt;
&lt;br&gt;
&lt;p&gt;A &lt;strong&gt;acurácia&lt;/strong&gt; representa a proporção da área coberta pelo circulo à direita (TP) mais a área não coberta pelo círculo à esquerda (TN) em relação à área total.&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&#34;flex: 1;&#34;&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /post/ml-metrics/img/acuracia_huaf85c404ff198c2ba9fa7f1480b5b36b_156621_55e735f14940870b5d2fb976dfc7bab1.png 400w,
               /post/ml-metrics/img/acuracia_huaf85c404ff198c2ba9fa7f1480b5b36b_156621_f1c4c3bbdebf55a66a61ccbec37aa736.png 760w,
               /post/ml-metrics/img/acuracia_huaf85c404ff198c2ba9fa7f1480b5b36b_156621_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://alvarofrancomartins.com/post/ml-metrics/img/acuracia_huaf85c404ff198c2ba9fa7f1480b5b36b_156621_55e735f14940870b5d2fb976dfc7bab1.png&#34;
               width=&#34;60%&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;simulações-interativas&#34;&gt;Simulações interativas&lt;/h1&gt;
&lt;p&gt;Para realmente compreender esses conceitos, nada melhor que ver como eles se comportam em tempo real.&lt;/p&gt;
&lt;h2 id=&#34;métricas-de-classificação&#34;&gt;Métricas de classificação&lt;/h2&gt;
&lt;p&gt;A simulação abaixo ilustra interativamente os conceitos fundamentais de métricas de classificação. Pontos são uniformemente e aleatoriamente gerados, separados igualmente entre as classes positiva (direita) e negativa (esquerda). Você pode alterar o tamanho do cículo, bem como movê-lo e assim observar como se comportam as métricas discutidas acima.&lt;/p&gt;
&lt;br&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;
    &lt;!-- KaTeX for math rendering --&gt;
    &lt;link rel=&#34;stylesheet&#34; href=&#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/katex.min.css&#34;&gt;
    &lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/katex.min.js&#34;&gt;&lt;/script&gt;
    &lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/contrib/auto-render.min.js&#34;&gt;&lt;/script&gt;
    &lt;style&gt;
        .simulation-container {
            max-width: 1200px;
        }
        
        /* Novo contêiner flexível para layout lado a lado */
        .flex-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
        }
        
        .visualization-area {
            flex: 3;
            min-width: 300px;
        }
        
        .metrics-area {
            flex: 2;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }
        
        .control-panel {
            width: 100%;
            max-width: 800px; /* Match visualization area width */
            margin: 0 auto 20px; /* Center horizontally with bottom margin */
            justify-content: flex-start; /* Left-align slider */
        }

        
        /* Improved Slider Styles */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
            position: relative;
            width: 100%;
            max-width: 350px;
        }
        
        .slider-container label {
            font-weight: bold;
            min-width: 100px;
            color: #333;
            margin-bottom: 8px;
        }
        
        .range-slider {
            width: 100%;
            position: relative;
        }
        
        .range-slider-track {
            height: 8px;
            width: 100%;
            background-color: #ddd;
            border-radius: 4px;
            position: relative;
        }
        
        .range-slider-fill {
            height: 100%;
            background-color: #3b82f6;
            border-radius: 4px;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            transition: width 0.1s ease;
        }
        
        input[type=&#34;range&#34;] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: transparent;
            position: absolute;
            top: 0;
            left: 0;
            margin: 0;
            z-index: 10;
        }

        input[type=&#34;range&#34;]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type=&#34;range&#34;]::-webkit-slider-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        input[type=&#34;range&#34;]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type=&#34;range&#34;]::-moz-range-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        .slider-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #3b82f6;
            background-color: #f0f4ff;
            padding: 4px 8px;
            border-radius: 12px;
            margin-left: 10px;
            border: 1px solid #d1d5db;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            padding-bottom: 70%; /* Ajustado para uma proporção diferente */
            border: 0px solid black;
            overflow: hidden;
            background-color: white;
            margin-bottom: 10px;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: move;
        }
        .quadrant-label {
            position: absolute;
/*            font-weight: bold;*/
            font-size: 17px;
            text-align: center;
            color: #fff;
            background-color: rgba(0, 0, 0, 1);
            padding: 1px 5px;
            border-radius: 10px;
            z-index: 10;
            pointer-events: none;
            transition: all 0.3s ease;
        }
        .metrics-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
        }
        .metric-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        .metric-btn {
            padding: 8px 12px;
            font-size: 24px;
            cursor: pointer;
            background-color: #f8f8f8;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-weight: bold;
            text-align: center;
            line-height: 1.2;
        }
        .metric-btn.active {
            background-color: #e6f0ff;
            border-color: #99c2ff;
        }
        /* Updated Metric Display Styles */
        .metric-display {
            min-height: 0px;
            max-height: 440px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            align-items: center;
            justify-content: flex-start;
            padding-top: 20px;
        }

        .metric-title {
            margin-bottom: 0;
            font-size: 30px;
            color: #000;
            text-align: center;
        }

        .metric-formula {
            font-size: 30px;
            text-align: center;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            max-width: 100%;
            overflow: auto;
            margin-bottom: 0px;
            margin-top: 0px;
            overflow: hidden; /* Remove scrollbar */

        }

        .metric-formula .equation {
            font-size: 22px;
            margin-bottom: 10px;
        }

        .metric-formula .result {
            font-size: 20px;
            color: #007bff;
            font-weight: bold;
        }
        .instruction {
            text-align: center;
            margin: 10px 0;
            color: #666;
            font-style: italic;
        }
        
        /* Responsividade para telas menores */
        @media (max-width: 768px) {
            .flex-container {
                flex-direction: column;
            }
            .visualization-area, .metrics-area {
                width: 100%;
            }
            .metric-btn {
                padding: 10px 15px;
                font-size: 16px;
            }
            .canvas-container {
                padding-bottom: 60%;
            }
        }

        table {
          max-width: 100%;
          overflow-x: hidden;
          table-layout: fixed;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&#34;simulation-container&#34;&gt;
        
        &lt;div class=&#34;control-panel&#34;&gt;
            &lt;div class=&#34;slider-container&#34;&gt;
                &lt;label for=&#34;circleSize&#34;&gt;Raio do círculo&lt;/label&gt;
                &lt;div class=&#34;range-slider&#34;&gt;
                    &lt;div class=&#34;range-slider-track&#34;&gt;
                        &lt;div class=&#34;range-slider-fill&#34; id=&#34;circleSizeFill&#34;&gt;&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;input type=&#34;range&#34; id=&#34;circleSize&#34; min=&#34;0&#34; max=&#34;100&#34; value=&#34;30&#34; step=&#34;1&#34;&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;!-- Novo contêiner flexível para layout lado a lado --&gt;
        &lt;div class=&#34;flex-container&#34;&gt;
            &lt;!-- Área de visualização (lado esquerdo) --&gt;
            &lt;div class=&#34;visualization-area&#34;&gt;
                &lt;div class=&#34;canvas-container&#34;&gt;
                    &lt;canvas id=&#34;canvas&#34;&gt;&lt;/canvas&gt;
                    &lt;div id=&#34;quadrant0&#34; class=&#34;quadrant-label&#34;&gt;False&lt;br&gt;Positives&lt;/div&gt;
                    &lt;div id=&#34;quadrant1&#34; class=&#34;quadrant-label&#34;&gt;True&lt;br&gt;Positives&lt;/div&gt;
                    &lt;div id=&#34;quadrant2&#34; class=&#34;quadrant-label&#34;&gt;True&lt;br&gt;Negatives&lt;/div&gt;
                    &lt;div id=&#34;quadrant3&#34; class=&#34;quadrant-label&#34;&gt;False&lt;br&gt;Negatives&lt;/div&gt;
                &lt;/div&gt;
                
                &lt;div style=&#34;display: flex; justify-content: space-between; width: 100%; font-weight: bold; margin-top: 5px;&#34;&gt;
                    &lt;span&gt;Negatives&lt;/span&gt;
                    &lt;span&gt;Positives&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;!-- Área de métricas (lado direito) --&gt;
            &lt;div class=&#34;metrics-area&#34;&gt;
                &lt;div class=&#34;metrics-container&#34;&gt;
                    
                    &lt;div class=&#34;metric-buttons&#34;&gt;
                        &lt;button id=&#34;btnRecall&#34; class=&#34;metric-btn active&#34;&gt;Recall&lt;br&gt;Sensitivity&lt;/button&gt;
                        &lt;button id=&#34;btnFPR&#34; class=&#34;metric-btn&#34;&gt;FPR&lt;/button&gt;
                        &lt;button id=&#34;btnSpecificity&#34; class=&#34;metric-btn&#34;&gt;Specificity&lt;/button&gt;
                        &lt;button id=&#34;btnFNR&#34; class=&#34;metric-btn&#34;&gt;FNR&lt;/button&gt;
                        &lt;button id=&#34;btnPrecision&#34; class=&#34;metric-btn&#34;&gt;Precision&lt;/button&gt;
                        &lt;button id=&#34;btnAccuracy&#34; class=&#34;metric-btn&#34;&gt;Accuracy&lt;/button&gt;
                        &lt;button id=&#34;btnF1&#34; class=&#34;metric-btn&#34;&gt;F1 Score&lt;/button&gt;
                    &lt;/div&gt;
                    
                    &lt;div class=&#34;metric-display&#34;&gt;
                        &lt;div class=&#34;metric-title&#34; id=&#34;metricTitle&#34;&gt;Recall/Sensitivity (TPR):&lt;/div&gt;
                        &lt;div class=&#34;metric-formula&#34; id=&#34;metricFormula&#34;&gt;Recall = TP/(TP + FN) = 0/0 = 0&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // DOM Elements
        const canvas = document.getElementById(&#39;canvas&#39;);
        const ctx = canvas.getContext(&#39;2d&#39;);
        const circleSizeSlider = document.getElementById(&#39;circleSize&#39;);
        const circleSizeFill = document.getElementById(&#39;circleSizeFill&#39;);
        
        // Quadrant labels
        const quadrantLabels = [
            document.getElementById(&#39;quadrant0&#39;),
            document.getElementById(&#39;quadrant1&#39;),
            document.getElementById(&#39;quadrant2&#39;),
            document.getElementById(&#39;quadrant3&#39;)
        ];
        
        // Metric buttons
        const btnRecall = document.getElementById(&#39;btnRecall&#39;);
        const btnFPR = document.getElementById(&#39;btnFPR&#39;);
        const btnSpecificity = document.getElementById(&#39;btnSpecificity&#39;);
        const btnFNR = document.getElementById(&#39;btnFNR&#39;);
        const btnPrecision = document.getElementById(&#39;btnPrecision&#39;);
        const btnAccuracy = document.getElementById(&#39;btnAccuracy&#39;);
        const btnF1 = document.getElementById(&#39;btnF1&#39;);
        
        // Metric displays
        const metricTitle = document.getElementById(&#39;metricTitle&#39;);
        const metricFormula = document.getElementById(&#39;metricFormula&#39;);
        
        // Variables
        let isDragging = false;
        let truePositives = 0;
        let falsePositives = 0;
        let trueNegatives = 0;
        let falseNegatives = 0;
        let totalPoints = 0;
        let points = [];
        let currentMetric = &#39;recall&#39;;
        
        // Circle properties
        let circleRadius;
        let centerX;
        let centerY;
        let circleCenter = { x: 0.5, y: 0.5 }; // Normalized position (0-1)
        let circleSizePercent = 30; // Percentage of min dimension
        let dragStartPos = { x: 0, y: 0 };
        let dragStartCenter = { x: 0, y: 0 };
        
        // Update slider fill
        function updateSliderFill() {
            const percent = (circleSizeSlider.value - circleSizeSlider.min) / (circleSizeSlider.max - circleSizeSlider.min) * 100;
            circleSizeFill.style.width = percent + &#39;%&#39;;
        }
        
        // Initial slider fill update
        updateSliderFill();
        
        // Update slider values
        circleSizeSlider.addEventListener(&#39;input&#39;, function() {
            circleSizePercent = parseInt(this.value);
            updateSliderFill();
            calculateDimensions();
            redrawCanvas();
            recalculateMetrics();
            updateLabels();
        });
        
        // Resize canvas to fit container
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            calculateDimensions();
            redrawCanvas();
            updateLabels();
        }
        
        // Calculate circle dimensions based on canvas size and current settings
        function calculateDimensions() {
            centerX = canvas.width * circleCenter.x;
            centerY = canvas.height * circleCenter.y;
            const minDimension = Math.min(canvas.width, canvas.height);
            circleRadius = minDimension * (circleSizePercent / 100);
        }
        
        // Generate points once at startup
        function generatePoints(count) {
            points = [];
            
            // Generate half the points on the left side and half on the right
            for (let i = 0; i &lt; count / 2; i++) {
                // Left side point (Negatives)
                points.push({
                    x: Math.random() * (canvas.width / 2 - 5),
                    y: Math.random() * canvas.height
                });
                
                // Right side point (Positives)
                points.push({
                    x: (canvas.width / 2 + 5) + Math.random() * (canvas.width / 2 - 10),
                    y: Math.random() * canvas.height
                });
            }
            
            recalculateMetrics();
        }
        
        // Update the class metrics based on the points
        function recalculateMetrics() {
            // Reset counts
            truePositives = 0;
            falsePositives = 0;
            trueNegatives = 0;
            falseNegatives = 0;
            
            // Recalculate counts for each point
            points.forEach(point =&gt; {
                const isRight = point.x &gt;= canvas.width / 2;
                const isPredictedPositive = isInsideCircle(point.x, point.y);
                
                if (isRight &amp;&amp; isPredictedPositive) truePositives++;
                else if (!isRight &amp;&amp; isPredictedPositive) falsePositives++;
                else if (!isRight &amp;&amp; !isPredictedPositive) trueNegatives++;
                else if (isRight &amp;&amp; !isPredictedPositive) falseNegatives++;
            });
            
            totalPoints = points.length;
            
            // Update the current metric display
            updateMetricDisplay();
        }
        
        // Redraw canvas with all points and current circle position
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPoints();
            drawBase();
        }
        
        // Update quadrant labels dynamically based on circle position
        function updateLabels() {
            // Get vertical dividing line position
            const midX = canvas.width / 2;
            
            // Check if circle overlaps with left or right half
            const leftEdge = centerX - circleRadius;
            const rightEdge = centerX + circleRadius;
            const overlapsLeft = leftEdge &lt; midX;
            const overlapsRight = rightEdge &gt; midX;
            
            // Padding to ensure labels stay within canvas
            const padding = 20;
            const labelWidth = 70;
            const labelHeight = 40;
            
            // Label safety margin (extra distance from circle)
            const safetyMargin = 15;
            
            // 1. False Positives (inside circle, left side)
            if (overlapsLeft &amp;&amp; circleRadius &gt; 1) {
                // Position inside circle on left side
                const fpX = Math.max(padding, Math.min(midX - labelWidth - padding, centerX - 10));
                const fpY = centerY;
                quadrantLabels[0].style.display = &#39;block&#39;;
                quadrantLabels[0].style.left = fpX + &#39;px&#39;;
                quadrantLabels[0].style.top = fpY + &#39;px&#39;;
                quadrantLabels[0].style.right = &#39;auto&#39;;
                quadrantLabels[0].innerHTML = &#34;False&lt;br&gt;Positives&#34;;
                quadrantLabels[0].style.backgroundColor = &#39;rgba(0, 0, 0, 1)&#39;;
            } else {
                quadrantLabels[0].style.display = &#39;none&#39;;
            }
            
            // 2. True Positives (inside circle, right side)
            if (overlapsRight &amp;&amp; circleRadius &gt; 1) {
                // Position inside circle on right side
                const tpX = Math.min(canvas.width - labelWidth - padding, Math.max(midX + padding, centerX + 10));
                const tpY = centerY;
                quadrantLabels[1].style.display = &#39;block&#39;;
                quadrantLabels[1].style.left = tpX + &#39;px&#39;;
                quadrantLabels[1].style.top = tpY + &#39;px&#39;;
                quadrantLabels[1].style.right = &#39;auto&#39;;
                quadrantLabels[1].innerHTML = &#34;True&lt;br&gt;Positives&#34;;
                quadrantLabels[1].style.backgroundColor = &#39;rgba(0, 0, 0, 1)&#39;;
            } else {
                quadrantLabels[1].style.display = &#39;none&#39;;
            }
            
            // 3. True Negatives (outside circle, left side)
            let tnX, tnY;

            // Try different positions for True Negatives to ensure it&#39;s outside the circle
            // Option 1: Far top left
            let tnPosition1 = { x: padding, y: padding };
            // Option 2: Far bottom left
            let tnPosition2 = { x: padding, y: canvas.height - labelHeight - padding };
            // Option 3: Default position but adjusted
            let tnPosition3 = { x: Math.min(midX / 2, leftEdge - labelWidth - safetyMargin), y: canvas.height * 0.2 };

            // Check which position is furthest from circle
            let tnDistances = [
                distanceToCircle(tnPosition1.x, tnPosition1.y),
                distanceToCircle(tnPosition2.x, tnPosition2.y),
                distanceToCircle(tnPosition3.x, tnPosition3.y)
            ];

            // Select the position with the maximum distance from circle
            let tnMaxDistanceIndex = tnDistances.indexOf(Math.max(...tnDistances));

            if (tnMaxDistanceIndex === 0) {
                tnX = tnPosition1.x;
                tnY = tnPosition1.y;
            } else if (tnMaxDistanceIndex === 1) {
                tnX = tnPosition2.x;
                tnY = tnPosition2.y;
            } else {
                tnX = tnPosition3.x;
                tnY = tnPosition3.y;
            }

            // Ensure it&#39;s within bounds and outside the circle
            tnX = Math.max(padding, Math.min(midX - labelWidth - padding, tnX))-15;
            tnY = Math.max(padding, Math.min(canvas.height - labelHeight - padding, tnY));

            // Additional check to ensure the label is outside the circle
            while (isInsideCircle(tnX + labelWidth / 2, tnY + labelHeight / 2)) {
                tnX -= 10; // Move left
                tnY -= 10; // Move up
            }

            quadrantLabels[2].style.display = &#39;block&#39;;
            quadrantLabels[2].style.left = tnX + &#39;px&#39;;
            quadrantLabels[2].style.top = tnY + &#39;px&#39;;
            quadrantLabels[2].style.right = &#39;auto&#39;;
            quadrantLabels[2].innerHTML = &#34;True&lt;br&gt;Negatives&#34;;
            quadrantLabels[2].style.backgroundColor = &#39;rgba(0, 0, 0, 1)&#39;;

            // 4. False Negatives (outside circle, right side)
            let fnX, fnY;

            // Try different positions for False Negatives to ensure it&#39;s outside the circle
            // Option 1: Far top right
            let fnPosition1 = { x: canvas.width - labelWidth - padding, y: padding };
            // Option 2: Far bottom right
            let fnPosition2 = { x: canvas.width - labelWidth - padding, y: canvas.height - labelHeight - padding };
            // Option 3: Default position but adjusted
            let fnPosition3 = { x: Math.max(midX + (canvas.width - midX) / 2, rightEdge + safetyMargin), y: canvas.height * 0.2};

            // Check which position is furthest from circle
            let fnDistances = [
                distanceToCircle(fnPosition1.x, fnPosition1.y),
                distanceToCircle(fnPosition2.x, fnPosition2.y),
                distanceToCircle(fnPosition3.x, fnPosition3.y)
            ];

            // Select the position with the maximum distance from circle
            let fnMaxDistanceIndex = fnDistances.indexOf(Math.max(...fnDistances));

            if (fnMaxDistanceIndex === 0) {
                fnX = fnPosition1.x;
                fnY = fnPosition1.y;
            } else if (fnMaxDistanceIndex === 1) {
                fnX = fnPosition2.x;
                fnY = fnPosition2.y;
            } else {
                fnX = fnPosition3.x;
                fnY = fnPosition3.y;
            }

            // Ensure it&#39;s within bounds and outside the circle
            fnX = Math.max(midX + padding, Math.min(canvas.width - labelWidth - padding, fnX));
            fnY = Math.max(padding, Math.min(canvas.height - labelHeight - padding, fnY));

            // Additional check to ensure the label is outside the circle
            while (isInsideCircle(fnX + labelWidth / 2, fnY + labelHeight / 2)) {
                fnX += 10; // Move right
                fnY -= 10; // Move up
            }

            quadrantLabels[3].style.display = &#39;block&#39;;
            quadrantLabels[3].style.left = fnX + &#39;px&#39;;
            quadrantLabels[3].style.top = fnY + &#39;px&#39;;
            quadrantLabels[3].style.right = &#39;auto&#39;;
            quadrantLabels[3].innerHTML = &#34;False&lt;br&gt;Negatives&#34;;
            quadrantLabels[3].style.backgroundColor = &#39;rgba(0, 0, 0,1)&#39;;
        }
        
        // Calculate distance from a point to the circle
        function distanceToCircle(x, y) {
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return Math.max(0, distance - circleRadius);
        }
        
        // Draw base canvas with vertical line and circle
        function drawBase() {
            // Draw dividing line
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.strokeStyle = &#39;black&#39;;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
            ctx.fillStyle = &#39;rgba(0, 0, 255, 0.15)&#39;;
            ctx.fill();
            ctx.strokeStyle = &#39;dark&#39;;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw border
            ctx.strokeStyle = &#39;#ddd&#39;;
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
            
            // Add coordinate text
            ctx.fillStyle = &#39;rgba(0, 0, 0, 0.7)&#39;;
            ctx.font = &#39;12px Arial&#39;;
            // ctx.fillText(`Center: (${Math.round(circleCenter.x * 100)}%, ${Math.round(circleCenter.y * 100)}%)`, 10, 20);
        }
        
        // Draw all points
        function drawPoints() {
            ctx.save();
            points.forEach(point =&gt; {
                const isRight = point.x &gt;= canvas.width / 2;
                
                // Choose color based on actual class (left/right side)
                if (isRight) {
                    ctx.fillStyle = &#39;blue&#39;; // Actual Positive (right side)
                } else {
                    ctx.fillStyle = &#39;red&#39;; // Actual Negative (left side)
                }
                
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();
        }
        
        // Check if a point is inside the classification circle
        function isInsideCircle(x, y) {
            const dx = x - centerX;
            const dy = y - centerY;
            return (dx * dx + dy * dy) &lt;= (circleRadius * circleRadius);
        }
        
        // Update the metric display based on the current selected metric
        function updateMetricDisplay() {
            // Skip if no points
            if (totalPoints === 0) {
                metricFormula.textContent = getMetricFormula(currentMetric, true);
                renderKatex();
                return;
            }
            
            // Calculate metrics
            const tpr = truePositives / (truePositives + falseNegatives) || 0;
            const fpr = falsePositives / (falsePositives + trueNegatives) || 0;
            const tnr = trueNegatives / (trueNegatives + falsePositives) || 0;
            const fnr = falseNegatives / (falseNegatives + truePositives) || 0;
            const precision = truePositives / (truePositives + falsePositives) || 0;
            const accuracy = (truePositives + trueNegatives) / totalPoints || 0;
            const f1 = 2 * (precision * tpr) / (precision + tpr) || 0;
            
            // Update formula display based on current metric with properly aligned equations
            switch (currentMetric) {
                case &#39;recall&#39;:
                    metricFormula.textContent = `
                    \\begin{aligned}
                    &amp;= \\frac{\\text{TP}}{\\text{TP} + \\text{FN}} \\\\[12pt]
                    &amp;= \\frac{${truePositives}}{${truePositives} + ${falseNegatives}} \\\\[12pt]
                    &amp;= ${tpr.toFixed(3)}
                    \\end{aligned}
                    `;
                    break;
                case &#39;fpr&#39;:
                    metricFormula.textContent = `
                    \\begin{aligned}
                    &amp;= \\frac{\\text{FP}}{\\text{FP} + \\text{TN}} \\\\[12pt]
                    &amp;= \\frac{${falsePositives}}{${falsePositives} + ${trueNegatives}} \\\\[12pt]
                    &amp;= ${fpr.toFixed(3)}
                    \\end{aligned}
                    `;
                    break;
                case &#39;specificity&#39;:
                    metricFormula.textContent = `
                    \\begin{aligned}
                    &amp;= \\frac{\\text{TN}}{\\text{TN} + \\text{FP}} \\\\[12pt]
                    &amp;= \\frac{${trueNegatives}}{${trueNegatives} + ${falsePositives}} \\\\[12pt]
                    &amp;= ${tnr.toFixed(3)}
                    \\end{aligned}
                    `;
                    break;
                case &#39;fnr&#39;:
                    metricFormula.textContent = `
                    \\begin{aligned}
                    &amp;= \\frac{\\text{FN}}{\\text{FN} + \\text{TP}} \\\\[12pt]
                    &amp;= \\frac{${falseNegatives}}{${falseNegatives} + ${truePositives}} \\\\[12pt]
                    &amp;= ${fnr.toFixed(3)}
                    \\end{aligned}
                    `;
                    break;
                case &#39;precision&#39;:
                    metricFormula.textContent = `
                    \\begin{aligned}
                    &amp;= \\frac{\\text{TP}}{\\text{TP} + \\text{FP}} \\\\[12pt]
                    &amp;= \\frac{${truePositives}}{${truePositives} + ${falsePositives}} \\\\[12pt]
                    &amp;= ${precision.toFixed(3)}
                    \\end{aligned}
                    `;
                    break;
                case &#39;accuracy&#39;:
                    metricFormula.textContent = `
                    \\begin{aligned}
                    &amp;= \\frac{\\text{TP} + \\text{TN}}{\\text{Total}} \\\\[12pt]
                    &amp;= \\frac{${truePositives} + ${trueNegatives}}{${totalPoints}} \\\\[12pt]
                    &amp;= ${accuracy.toFixed(3)}
                    \\end{aligned}
                    `;
                    break;
                case &#39;f1&#39;:
                    metricFormula.textContent = `
                    \\begin{aligned}
                    &amp;= \\frac{2 \\times \\text{Precision} \\times \\text{Recall}}{\\text{Precision} + \\text{Recall}} \\\\[12pt]
                    &amp;= \\frac{2 \\times ${precision.toFixed(3)} \\times ${tpr.toFixed(3)}}{${precision.toFixed(3)} + ${tpr.toFixed(3)}} \\\\[12pt]
                    &amp;= ${f1.toFixed(3)}
                    \\end{aligned}
                    `;
                    break;
            }
            
            // Render formula with KaTeX
            renderKatex();
        }
        
        // Get formula template for a metric
        function getMetricFormula(metric, withZeros = false) {
            if (withZeros) {
                switch (metric) {
                    case &#39;recall&#39;:
                        return `
                        \\begin{aligned}
                        &amp;\\frac{\\text{TP}}{\\text{TP} + \\text{FN}} \\\\[12pt]
                        &amp;= \\frac{0}{0 + 0} \\\\[12pt]
                        &amp;= 0
                        \\end{aligned}
                        `;
                    case &#39;fpr&#39;:
                        return `
                        \\begin{aligned}
                        &amp;\\frac{\\text{FP}}{\\text{FP} + \\text{TN}} \\\\[12pt]
                        &amp;= \\frac{0}{0 + 0} \\\\[12pt]
                        &amp;= 0
                        \\end{aligned}
                        `;
                    case &#39;specificity&#39;:
                        return `
                        \\begin{aligned}
                        &amp;\\frac{\\text{TN}}{\\text{TN} + \\text{FP}} \\\\[12pt]
                        &amp;= \\frac{0}{0 + 0} \\\\[12pt]
                        &amp;= 0
                        \\end{aligned}
                        `;
                    case &#39;fnr&#39;:
                        return `
                        \\begin{aligned}
                        &amp;\\frac{\\text{FN}}{\\text{FN} + \\text{TP}} \\\\[12pt]
                        &amp;= \\frac{0}{0 + 0} \\\\[12pt]
                        &amp;= 0
                        \\end{aligned}
                        `;
                    case &#39;precision&#39;:
                        return `
                        \\begin{aligned}
                        &amp;\\frac{\\text{TP}}{\\text{TP} + \\text{FP}} \\\\[12pt]
                        &amp;= \\frac{0}{0 + 0} \\\\[12pt]
                        &amp;= 0
                        \\end{aligned}
                        `;
                    case &#39;accuracy&#39;:
                        return `
                        \\begin{aligned}
                        &amp;\\frac{\\text{TP} + \\text{TN}}{\\text{Total}} \\\\[12pt]
                        &amp;= \\frac{0 + 0}{0} \\\\[12pt]
                        &amp;= 0
                        \\end{aligned}
                        `;
                    case &#39;f1&#39;:
                        return `
                        \\begin{aligned}
                        &amp;\\frac{2 \\times \\text{Precision} \\times \\text{Recall}}{\\text{Precision} + \\text{Recall}} \\\\[12pt]
                        &amp;= \\frac{2 \\times 0 \\times 0}{0 + 0} \\\\[12pt]
                        &amp;= 0
                        \\end{aligned}
                        `;
                }
            }
            return &#39;&#39;;
        }
        
        // Render KaTeX formulas
        function renderKatex() {
            try {
                if (window.katex) {
                    katex.render(metricFormula.textContent, metricFormula, {
                        displayMode: true,
                        throwOnError: false,
                        output: &#34;html&#34;,
                        trust: true    // Allow newline commands
                    });
                }
            } catch (error) {
                console.error(&#34;KaTeX rendering error:&#34;, error);
            }
        }
        
        // Setup metric buttons
        function setupMetricButtons() {
            const allButtons = [btnRecall, btnFPR, btnSpecificity, btnFNR, btnPrecision, btnAccuracy, btnF1];
            
            // Update button styles when a metric is selected
            function updateButtonStyles(selectedButton) {
                allButtons.forEach(btn =&gt; {
                    btn.classList.remove(&#39;active&#39;);
                });
                selectedButton.classList.add(&#39;active&#39;);
            }
            
            btnRecall.addEventListener(&#39;click&#39;, function() {
                currentMetric = &#39;recall&#39;;
                updateButtonStyles(btnRecall);
                metricTitle.textContent = &#39;Recall/Sensitivity (TPR):&#39;;
                updateMetricDisplay();
            });
            
            btnFPR.addEventListener(&#39;click&#39;, function() {
                currentMetric = &#39;fpr&#39;;
                updateButtonStyles(btnFPR);
                metricTitle.textContent = &#39;False Positive Rate (FPR):&#39;;
                updateMetricDisplay();
            });
            
            btnSpecificity.addEventListener(&#39;click&#39;, function() {
                currentMetric = &#39;specificity&#39;;
                updateButtonStyles(btnSpecificity);
                metricTitle.textContent = &#39;Specificity (TNR):&#39;;
                updateMetricDisplay();
            });
            
            btnFNR.addEventListener(&#39;click&#39;, function() {
                currentMetric = &#39;fnr&#39;;
                updateButtonStyles(btnFNR);
                metricTitle.textContent = &#39;False Negative Rate (FNR):&#39;;
                updateMetricDisplay();
            });
            
            btnPrecision.addEventListener(&#39;click&#39;, function() {
                currentMetric = &#39;precision&#39;;
                updateButtonStyles(btnPrecision);
                metricTitle.textContent = &#39;Precision (PPV):&#39;;
                updateMetricDisplay();
            });
            
            btnAccuracy.addEventListener(&#39;click&#39;, function() {
                currentMetric = &#39;accuracy&#39;;
                updateButtonStyles(btnAccuracy);
                metricTitle.textContent = &#39;Accuracy (ACC):&#39;;
                updateMetricDisplay();
            });
            
            btnF1.addEventListener(&#39;click&#39;, function() {
                currentMetric = &#39;f1&#39;;
                updateButtonStyles(btnF1);
                metricTitle.textContent = &#39;F1 Score:&#39;;
                updateMetricDisplay();
            });
        }
        
        // Mouse events for dragging the circle
        function setupDragEvents() {
            canvas.addEventListener(&#39;mousedown&#39;, function(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Check if click is near the circle center
                const dx = mouseX - centerX;
                const dy = mouseY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance &lt;= circleRadius) {
                    isDragging = true;
                    dragStartPos = { x: mouseX, y: mouseY };
                    dragStartCenter = { x: circleCenter.x, y: circleCenter.y };
                    canvas.style.cursor = &#39;grabbing&#39;;
                }
            });
            
            canvas.addEventListener(&#39;mousemove&#39;, function(e) {
                if (!isDragging) return;
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Calculate new center position
                const dx = (mouseX - dragStartPos.x) / canvas.width;
                const dy = (mouseY - dragStartPos.y) / canvas.height;
                
                circleCenter.x = Math.max(0.1, Math.min(0.9, dragStartCenter.x + dx));
                circleCenter.y = Math.max(0.1, Math.min(0.9, dragStartCenter.y + dy));
                
                calculateDimensions();
                redrawCanvas();
                recalculateMetrics();
                updateLabels();
            });
            
            canvas.addEventListener(&#39;mouseup&#39;, function() {
                if (isDragging) {
                    isDragging = false;
                    canvas.style.cursor = &#39;move&#39;;
                }
            });
            
            canvas.addEventListener(&#39;mouseleave&#39;, function() {
                if (isDragging) {
                    isDragging = false;
                    canvas.style.cursor = &#39;move&#39;;
                }
            });
            
            // Set initial cursor
            canvas.style.cursor = &#39;move&#39;;
        }
        
        // Touch events for mobile
        function setupTouchEvents() {
            canvas.addEventListener(&#39;touchstart&#39;, function(e) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                // Check if touch is near the circle center
                const dx = touchX - centerX;
                const dy = touchY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance &lt;= circleRadius) {
                    isDragging = true;
                    dragStartPos = { x: touchX, y: touchY };
                    dragStartCenter = { x: circleCenter.x, y: circleCenter.y };
                }
            });
            
            canvas.addEventListener(&#39;touchmove&#39;, function(e) {
                if (!isDragging) return;
                e.preventDefault();
                
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                // Calculate new center position
                const dx = (touchX - dragStartPos.x) / canvas.width;
                const dy = (touchY - dragStartPos.y) / canvas.height;
                
                circleCenter.x = Math.max(0.1, Math.min(0.9, dragStartCenter.x + dx));
                circleCenter.y = Math.max(0.1, Math.min(0.9, dragStartCenter.y + dy));
                
                calculateDimensions();
                redrawCanvas();
                recalculateMetrics();
                updateLabels();
            });
            
            canvas.addEventListener(&#39;touchend&#39;, function(e) {
                e.preventDefault();
                isDragging = false;
            });
        }
        
        // Initialize
        window.addEventListener(&#39;load&#39;, function() {
            resizeCanvas();
            setupMetricButtons();
            setupDragEvents();
            setupTouchEvents();
            
            // Generate 5,000 points immediately
            generatePoints(10000);
            
            // Initial render
            redrawCanvas();
            updateLabels();
            updateMetricDisplay();
        });
        
        window.addEventListener(&#39;resize&#39;, function() {
            resizeCanvas();
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;p&gt;Ao interagir com a simulação&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;, você poderá observar alguns casos interessantes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Precisão 50%&lt;/strong&gt;: Ocorre quando o círculo está exatamente no centro.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Baixo recall mas precisão de 100%&lt;/strong&gt;: Um círculo pequeno está inteiramente no lado direito.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Recall máximo com FPR máximo&lt;/strong&gt;: O círculo cobre toda a área de simulação, e portanto o modelo classifica tudo como positivo. Obtemos apenas TP e FP; recall máximo, FPR máximo e nenhuma especificidade.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sem recall nem precisão&lt;/strong&gt;: Se reduzirmos o tamanho do círculo a zero, o modelo classificará tudo como negativo, resultando em ausência de recall, precisão e FPR. Mesmo assim, temos uma acurácia de 50% e especificidade de 100%.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;O cenário ideal&lt;/strong&gt;: Um grande círculo que tenta cobrir todo o lado direito e, ao mesmo tempo, possuir a menor área possível no lado esquerdo.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Essa visualização interativa é útil porque permite relacionar conceitos abstratos com representações visuais concretas. Por exemplo, quando alguém diz que “o modelo tem alta precisão, mas baixo recall”, você pode visualizar isso como um círculo pequeno, posicionado quase totalmente no lado direito. Já no caso de “alta especificidade, mas baixa sensibilidade”, uma possível representação seria um círculo centralizado, dividido igualmente entre os dois lados.&lt;/p&gt;
&lt;h1 id=&#34;entendendo-a-curva-roc&#34;&gt;Entendendo a curva ROC&lt;/h1&gt;
&lt;p&gt;Modelos de classificação, como a regressão logística, geralmente não retornam apenas uma resposta binária (sim/não), mas sim uma probabilidade associada a cada classe. Ou seja, ao invés de dizer diretamente &amp;ldquo;positivo&amp;rdquo; ou &amp;ldquo;negativo&amp;rdquo;, o modelo indica quão confiante está de que determinada observação pertence à classe positiva — atribuindo um valor entre 0 e 1.&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;Para transformar essa probabilidade em uma decisão binária, é necessário definir um limiar (threshold). Por exemplo: se a probabilidade for maior que 0,5, classificamos como positivo; caso contrário, como negativo. Mas o que acontece se alterarmos esse valor de 0,5? Como o desempenho do modelo muda com diferentes limiares? É justamente aí que entra a &lt;strong&gt;curva ROC&lt;/strong&gt;&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;. Em vez de avaliar o modelo com base em um único ponto de corte, a curva ROC mostra como o modelo equilibra acertos e erros à medida que o limiar varia. Para construí-la, plotamos TPR (eixo y) versus FPR (eixo x) para todos os limiares de 0 a 1.&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;o-cenário-baseline&#34;&gt;O cenário baseline&lt;/h2&gt;
&lt;p&gt;Para entender melhor a curva ROC, vamos considerar a simulação anterior mas com um círculo estático que cresce exatamente do centro. Uma vez que os pontos estão uniformemente distribuidos no plano, para qualquer limiar, o modelo classifica corretamente os positivos (TPR) na mesma proporção que classifica incorretamente os negativos (FPR).&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;Quando plotamos a curva ROC para este modelo, obtemos uma reta diagonal do tipo $y = x$. Em outras palavras, se o modelo identifica 60% dos positivos corretamente, ele também classifica erroneamente 60% dos negativos como positivos. Varie o tamanho do círculo na simulação abaixo para observar esse comportamento.&lt;/p&gt;
&lt;br&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;
    &lt;link rel=&#34;stylesheet&#34; href=&#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/katex.min.css&#34;&gt;
    &lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/katex.min.js&#34;&gt;&lt;/script&gt;
    &lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/contrib/auto-render.min.js&#34;&gt;&lt;/script&gt;
    &lt;script&gt;
        // Ensure KaTeX is fully loaded before page initialization
        document.addEventListener(&#39;DOMContentLoaded&#39;, function() {
            if (typeof katex !== &#39;undefined&#39;) {
                console.log(&#34;KaTeX loaded successfully&#34;);
            } else {
                console.error(&#34;KaTeX failed to load&#34;);
            }
        });
    &lt;/script&gt;
    &lt;style&gt;
        
        .roc_simulation-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .roc_control-panel {
            width: 100%;
            max-width: 80%;
            margin: 0 auto 20px;
        }
        
        .roc_slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
            position: relative;
            width: 100%;
            max-width: 350px;
        }
        
        .roc_slider-container label {
            font-weight: bold;
            min-width: 100px;
            color: #333;
            margin-bottom: 1px;
        }
        
        .roc_range-slider {
            width: 100%;
            position: relative;
        }
        
        .roc_range-slider-track {
            height: 8px;
            width: 100%;
            background-color: #ddd;
            border-radius: 4px;
            position: relative;
        }
        
        .roc_range-slider-fill {
            height: 100%;
            background-color: #3b82f6;
            border-radius: 4px;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            transition: width 0.1s ease;
        }
        
        input[type=&#34;range&#34;] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: transparent;
            position: absolute;
            top: 0;
            left: 0;
            margin: 0;
            z-index: 10;
        }

        input[type=&#34;range&#34;]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type=&#34;range&#34;]::-webkit-slider-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        input[type=&#34;range&#34;]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type=&#34;range&#34;]::-moz-range-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        .roc_slider-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #3b82f6;
            background-color: #f0f4ff;
            padding: 4px 8px;
            border-radius: 12px;
            margin-left: 10px;
            border: 1px solid #d1d5db;
        }
        
        .roc_flex-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 3%; /* Increased from 20px */
        }
        
        .roc_visualization-area {
            flex: 1;
            min-width: 300px;
        }
        
        .roc_roc-area {
            flex: 1;
            min-width: 300px;
        }
        
        .roc_canvas-container {
            position: relative;
            width: 100%;
            padding-bottom: 85%;
            border: 1px solid #ddd;
            overflow: hidden;
            background-color: white;
        }

        #roc_canvas, #roc_rocCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: move;
        }
        
        .roc_quadrant-label {
            position: absolute;
            white-space: nowrap;
            font-size: 17px;
            text-align: center;
            color: #fff;
            background-color: rgba(0, 0, 0, 1);
            padding: 1px 5px;
            border-radius: 10px;
            z-index: 10;
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        .roc_metrics-display {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f8f9fa;
        }
        
        .roc_metrics-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }
        
        .roc_metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .roc_metric-card {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
        }
        
        .roc_metric-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            color: #333;
        }
        
        .roc_metric-formula {
            text-align: center;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .roc_metric-value {
            text-align: center;
            font-weight: bold;
            font-size: 18px;
            color: #3b82f6;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .roc_flex-container {
                flex-direction: column;
            }
            
            .roc_metrics-grid {
                grid-template-columns: 1fr;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&#34;roc_simulation-container&#34;&gt;
        
        &lt;div class=&#34;roc_control-panel&#34;&gt;
            &lt;div class=&#34;roc_slider-container&#34;&gt;
                &lt;label for=&#34;roc_circleSize&#34;&gt;Tamanho do círculo&lt;/label&gt;
                &lt;div class=&#34;roc_range-slider&#34;&gt;
                    &lt;div class=&#34;roc_range-slider-track&#34;&gt;
                        &lt;div class=&#34;roc_range-slider-fill&#34; id=&#34;roc_circleSizeFill&#34;&gt;&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;input type=&#34;range&#34; id=&#34;roc_circleSize&#34; min=&#34;0&#34; max=&#34;100&#34; value=&#34;0&#34; step=&#34;1&#34;&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class=&#34;roc_flex-container&#34;&gt;
            &lt;!-- Visualization Area --&gt;
            &lt;div class=&#34;roc_visualization-area&#34;&gt;
                &lt;div class=&#34;roc_canvas-container&#34;&gt;
                    &lt;canvas id=&#34;roc_canvas&#34;&gt;&lt;/canvas&gt;
                    &lt;div id=&#34;roc_quadrant0&#34; class=&#34;roc_quadrant-label&#34;&gt;False&lt;br&gt;Positives&lt;/div&gt;
                    &lt;div id=&#34;roc_quadrant1&#34; class=&#34;roc_quadrant-label&#34;&gt;True&lt;br&gt;Positives&lt;/div&gt;
                    &lt;div id=&#34;roc_quadrant2&#34; class=&#34;roc_quadrant-label&#34;&gt;True&lt;br&gt;Negatives&lt;/div&gt;
                    &lt;div id=&#34;roc_quadrant3&#34; class=&#34;roc_quadrant-label&#34;&gt;False&lt;br&gt;Negatives&lt;/div&gt;
                &lt;/div&gt;
                
                &lt;div style=&#34;display: flex; justify-content: space-between; width: 100%; font-weight: bold; margin-top: 5px;&#34;&gt;
                    &lt;span&gt;Negatives&lt;/span&gt;
                    &lt;span&gt;Positives&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;!-- Right side: ROC Curve and Metrics --&gt;
            &lt;div class=&#34;roc_roc-area&#34;&gt;
            &lt;!-- ROC Curve with Y-axis labels --&gt;
            &lt;div style=&#34;display: flex; align-items: stretch; margin-bottom: 0px;&#34;&gt;
                &lt;!-- Y-axis labels --&gt;
                &lt;div style=&#34;display: flex; flex-direction: column; font-weight: bold; width: 40px; position: relative; height: 300px;&#34;&gt;
                    &lt;span style=&#34;position: absolute; top: 0; right: 0;&#34;&gt;1.0&lt;/span&gt;
                    &lt;span style=&#34;position: absolute; writing-mode: vertical-rl; transform: rotate(180deg); left: 10px; top: 50%;&#34;&gt;TPR&lt;/span&gt;
                &lt;/div&gt;
                
                &lt;!-- ROC Curve canvas --&gt;
                &lt;div style=&#34;flex-grow: 1;&#34;&gt;
                    &lt;div class=&#34;roc_canvas-container&#34; style=&#34;padding-bottom: 50%;&#34;&gt;
                        &lt;canvas id=&#34;roc_rocCanvas&#34;&gt;&lt;/canvas&gt;
                    &lt;/div&gt;
                    
                    &lt;!-- X-axis labels --&gt;
                    &lt;div style=&#34;display: flex; justify-content: space-between; width: 100%; font-weight: bold; margin: 5px 0 10px 0;&#34;&gt;
                        &lt;span&gt;0.0&lt;/span&gt;
                        &lt;span style=&#34;text-align: center; flex-grow: 1;&#34;&gt;FPR&lt;/span&gt;
                        &lt;span&gt;1.0&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;/div&gt;
                
                &lt;!-- Compact Metrics Display --&gt;
                &lt;div class=&#34;roc_metrics-display&#34; style=&#34;margin-top: 0; padding: 10px;&#34;&gt;
                    &lt;div class=&#34;roc_metrics-grid&#34; style=&#34;grid-template-columns: 1fr 1fr; gap: 10px;&#34;&gt;
                        &lt;div class=&#34;roc_metric-card&#34; style=&#34;padding: 8px;&#34;&gt;
                            &lt;div class=&#34;roc_metric-name&#34; style=&#34;font-size: 20px; margin-bottom: 5px;text-align: center;&#34;&gt;TPR (True Positive Rate)&lt;/div&gt;
                            &lt;div class=&#34;roc_metric-formula&#34; id=&#34;roc_tprFormula&#34; style=&#34;min-height: 50px; font-size: 18px;&#34;&gt;Loading...&lt;/div&gt;
                            &lt;div class=&#34;roc_metric-value&#34; id=&#34;roc_tprValue&#34; style=&#34;margin-top: 5px; font-size: 22px;&#34;&gt;= 0.000&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class=&#34;roc_metric-card&#34; style=&#34;padding: 8px;&#34;&gt;
                            &lt;div class=&#34;roc_metric-name&#34; style=&#34;font-size: 20px; margin-bottom: 5px;text-align: center;&#34;&gt;FPR (False Positive Rate)&lt;/div&gt;
                            &lt;div class=&#34;roc_metric-formula&#34; id=&#34;roc_fprFormula&#34; style=&#34;min-height: 50px; font-size: 18px;&#34;&gt;Loading...&lt;/div&gt;
                            &lt;div class=&#34;roc_metric-value&#34; id=&#34;roc_fprValue&#34; style=&#34;margin-top: 5px; font-size: 22px;&#34;&gt;= 0.000&lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Ensure KaTeX is loaded completely before page init --&gt;
    &lt;script&gt;
        // Wait for all resources to load, including KaTeX
        window.addEventListener(&#39;load&#39;, function() {
            // Initialize simulation
            roc_init();
        });
        
        function roc_init() {
            // DOM Elements
            const roc_canvas = document.getElementById(&#39;roc_canvas&#39;);
            const roc_ctx = roc_canvas.getContext(&#39;2d&#39;);
            const roc_rocCanvas = document.getElementById(&#39;roc_rocCanvas&#39;);
            const roc_rocCtx = roc_rocCanvas.getContext(&#39;2d&#39;);
            const roc_circleSizeSlider = document.getElementById(&#39;roc_circleSize&#39;);
            const roc_circleSizeFill = document.getElementById(&#39;roc_circleSizeFill&#39;);
            const roc_sizeValue = document.getElementById(&#39;roc_sizeValue&#39;);
        
            // Quadrant labels
            const roc_quadrantLabels = [
                document.getElementById(&#39;roc_quadrant0&#39;),
                document.getElementById(&#39;roc_quadrant1&#39;),
                document.getElementById(&#39;roc_quadrant2&#39;),
                document.getElementById(&#39;roc_quadrant3&#39;)
            ];
            
            // Metric displays
            const roc_tprFormula = document.getElementById(&#39;roc_tprFormula&#39;);
            const roc_tprValue = document.getElementById(&#39;roc_tprValue&#39;);
            const roc_fprFormula = document.getElementById(&#39;roc_fprFormula&#39;);
            const roc_fprValue = document.getElementById(&#39;roc_fprValue&#39;);
            
            // Variables
            let roc_isDragging = false;
            let roc_truePositives = 0;
            let roc_falsePositives = 0;
            let roc_trueNegatives = 0;
            let roc_falseNegatives = 0;
            let roc_totalPoints = 0;
            let roc_points = [];
            let roc_rocPoints = [];
            let roc_currentSize = 0; // Track current circle size
            
            // Circle properties
            let roc_circleRadius;
            let roc_centerX;
            let roc_centerY;
            let roc_circleCenter = { x: 0.5, y: 0.5 }; // Normalized position (0-1)
            let roc_circleSizePercent = 0; // Percentage of min dimension
            let roc_dragStartPos = { x: 0, y: 0 };
            let roc_dragStartCenter = { x: 0, y: 0 };
            
            // Update slider fill
            function roc_updateSliderFill() {
                const percent = (roc_circleSizeSlider.value - roc_circleSizeSlider.min) / (roc_circleSizeSlider.max - roc_circleSizeSlider.min) * 100;
                roc_circleSizeFill.style.width = percent + &#39;%&#39;;
            }
            
            // Initial slider fill update
            roc_updateSliderFill();
            
            // Setup slider events for changing circle size only
            function roc_setupSliderEvents() {
                // Update slider fill and add event listener
                roc_updateSliderFill();
                
                roc_circleSizeSlider.addEventListener(&#39;input&#39;, function() {
                    // Store previous and current size for ROC curve updating
                    const prevSize = roc_circleSizePercent;
                    roc_circleSizePercent = parseInt(this.value);
                    roc_currentSize = roc_circleSizePercent;
                    
                    roc_updateSliderFill();
                    roc_calculateDimensions();
                    roc_redrawCanvas();
                    roc_recalculateMetrics();
                    roc_updateLabels();
                    
                    // Update ROC curve based on whether size increased or decreased
                    if (roc_circleSizePercent &gt; prevSize) {
                        roc_addROCPoint();
                    } else if (roc_circleSizePercent &lt; prevSize) {
                        roc_removeROCPointsAboveSize(roc_circleSizePercent);
                    }
                    
                    roc_drawROCCurve();
                });
            }
            
            // Resize canvas to fit container
            function roc_resizeCanvas() {
                const container = roc_canvas.parentElement;
                roc_canvas.width = container.clientWidth;
                roc_canvas.height = container.clientHeight;
                
                const rocContainer = roc_rocCanvas.parentElement;
                roc_rocCanvas.width = rocContainer.clientWidth;
                roc_rocCanvas.height = rocContainer.clientHeight;
                
                roc_calculateDimensions();
                roc_redrawCanvas();
                roc_drawROCCurve();
                roc_updateLabels();
            }
            
            // Calculate circle dimensions based on canvas size and current settings
            function roc_calculateDimensions() {
                // Fixed center position (prevent dragging)
                roc_centerX = roc_canvas.width * 0.5;
                roc_centerY = roc_canvas.height * 0.5;
                const minDimension = Math.min(roc_canvas.width, roc_canvas.height);
                roc_circleRadius = minDimension * (roc_circleSizePercent / 100);
            }
            
            // Generate points
            function roc_generatePoints(count) {
                roc_points = [];
                
                // Generate half the points on the left side and half on the right
                for (let i = 0; i &lt; count / 2; i++) {
                    // Left side point (Negatives)
                    roc_points.push({
                        x: Math.random() * (roc_canvas.width / 2 - 5),
                        y: Math.random() * roc_canvas.height
                    });
                    
                    // Right side point (Positives)
                    roc_points.push({
                        x: (roc_canvas.width / 2 + 5) + Math.random() * (roc_canvas.width / 2 - 10),
                        y: Math.random() * roc_canvas.height
                    });
                }
                
                roc_recalculateMetrics();
            }
            
            // Update the class metrics based on the points
            function roc_recalculateMetrics() {
                // Reset counts
                roc_truePositives = 0;
                roc_falsePositives = 0;
                roc_trueNegatives = 0;
                roc_falseNegatives = 0;
                
                // Recalculate counts for each point
                roc_points.forEach(point =&gt; {
                    const isRight = point.x &gt;= roc_canvas.width / 2;
                    const isPredictedPositive = roc_isInsideCircle(point.x, point.y);
                    
                    if (isRight &amp;&amp; isPredictedPositive) roc_truePositives++;
                    else if (!isRight &amp;&amp; isPredictedPositive) roc_falsePositives++;
                    else if (!isRight &amp;&amp; !isPredictedPositive) roc_trueNegatives++;
                    else if (isRight &amp;&amp; !isPredictedPositive) roc_falseNegatives++;
                });
                
                roc_totalPoints = roc_points.length;
                
                // Update the metric displays
                roc_updateMetricDisplay();
            }
            
            // Update metric display
            function roc_updateMetricDisplay() {
                // Calculate TPR and FPR
                const tpr = roc_truePositives / (roc_truePositives + roc_falseNegatives) || 0;
                const fpr = roc_falsePositives / (roc_falsePositives + roc_trueNegatives) || 0;
                
                // Update display values with equal sign
                roc_tprValue.textContent = &#34;= &#34; + tpr.toFixed(3);
                roc_fprValue.textContent = &#34;= &#34; + fpr.toFixed(3);
                
                // Properly format the equations for KaTeX
                const tprFormulaText = `\\frac{TP}{TP + FN} = \\frac{${roc_truePositives}}{${roc_truePositives} + ${roc_falseNegatives}}`;
                const fprFormulaText = `\\frac{FP}{FP + TN} = \\frac{${roc_falsePositives}}{${roc_falsePositives} + ${roc_trueNegatives}}`;
                
                // Set the text content for later rendering
                roc_tprFormula.setAttribute(&#39;data-formula&#39;, tprFormulaText);
                roc_fprFormula.setAttribute(&#39;data-formula&#39;, fprFormulaText);
                
                // Render with KaTeX
                roc_renderFormulas();
            }
            
            // Properly format the equations for KaTeX with larger font
            function roc_renderFormulas() {
                try {
                    if (typeof katex !== &#39;undefined&#39;) {
                        const tprFormulaText = roc_tprFormula.getAttribute(&#39;data-formula&#39;);
                        const fprFormulaText = roc_fprFormula.getAttribute(&#39;data-formula&#39;);
                        
                        katex.render(tprFormulaText, roc_tprFormula, {
                            displayMode: true,
                            throwOnError: false,
                            fontSize: &#39;1.2em&#39; // Larger font size
                        });
                        
                        katex.render(fprFormulaText, roc_fprFormula, {
                            displayMode: true,
                            throwOnError: false,
                            fontSize: &#39;1.2em&#39; // Larger font size
                        });
                    } else {
                        console.error(&#34;KaTeX not available for rendering&#34;);
                        // Fallback to plain text if rendering fails
                        roc_tprFormula.textContent = roc_tprFormula.getAttribute(&#39;data-formula&#39;);
                        roc_fprFormula.textContent = roc_fprFormula.getAttribute(&#39;data-formula&#39;);
                    }
                } catch (error) {
                    console.error(&#34;KaTeX rendering error:&#34;, error);
                }
            }
            
            // Draw all points
            function roc_drawPoints() {
                roc_points.forEach(point =&gt; {
                    const isRight = point.x &gt;= roc_canvas.width / 2;
                    
                    // Choose color based on actual class (left/right side)
                    if (isRight) {
                        roc_ctx.fillStyle = &#39;blue&#39;; // Actual Positive (right side)
                    } else {
                        roc_ctx.fillStyle = &#39;red&#39;; // Actual Negative (left side)
                    }
                    
                    roc_ctx.beginPath();
                    roc_ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                    roc_ctx.fill();
                });
            }
            
            // Redraw canvas with all points and current circle position
            function roc_redrawCanvas() {
                roc_ctx.clearRect(0, 0, roc_canvas.width, roc_canvas.height);
                
                // Draw points
                roc_drawPoints();
                
                // Draw dividing line
                roc_ctx.beginPath();
                roc_ctx.moveTo(roc_canvas.width / 2, 0);
                roc_ctx.lineTo(roc_canvas.width / 2, roc_canvas.height);
                roc_ctx.strokeStyle = &#39;black&#39;;
                roc_ctx.lineWidth = 2;
                roc_ctx.stroke();
                
                // Draw circle
                roc_ctx.beginPath();
                roc_ctx.arc(roc_centerX, roc_centerY, roc_circleRadius, 0, Math.PI * 2);
                roc_ctx.fillStyle = &#39;rgba(0, 0, 255, 0.15)&#39;;
                roc_ctx.fill();
                roc_ctx.strokeStyle = &#39;black&#39;; // Changed to black for better visibility
                roc_ctx.lineWidth = 3;
                roc_ctx.stroke();
                
                // Draw border
                roc_ctx.strokeStyle = &#39;#ddd&#39;;
                roc_ctx.lineWidth = 1;
                roc_ctx.strokeRect(0, 0, roc_canvas.width, roc_canvas.height);
            }
            
            // Draw the ROC curve
            function roc_drawROCCurve() {
                roc_rocCtx.clearRect(0, 0, roc_rocCanvas.width, roc_rocCanvas.height);
                
                            // Draw axes
            roc_rocCtx.beginPath();
            // Y-axis (left)
            roc_rocCtx.moveTo(0, roc_rocCanvas.height);
            roc_rocCtx.lineTo(0, 0);
            // X-axis (bottom)
            roc_rocCtx.moveTo(0, roc_rocCanvas.height);
            roc_rocCtx.lineTo(roc_rocCanvas.width, roc_rocCanvas.height);
            roc_rocCtx.stroke();

            // Y-axis label
            roc_rocCtx.save();
            roc_rocCtx.translate(20, roc_rocCanvas.height/2); // Adjust left position
            roc_rocCtx.rotate(-Math.PI/2);
            roc_rocCtx.restore();

            // Y-ticks (only 0 and 1)
            [0, 1].forEach(t =&gt; {
                const y = roc_rocCanvas.height - (t * roc_rocCanvas.height);
                // Tick
                roc_rocCtx.beginPath();
                roc_rocCtx.moveTo(0, y);
                roc_rocCtx.lineTo(5, y);
                roc_rocCtx.stroke();
                // Label
                roc_rocCtx.textAlign = &#34;right&#34;;
                roc_rocCtx.fillText(t.toFixed(0), -8, y + 4);
            });

            // X-ticks (only 0 and 1)
            [0, 1].forEach(t =&gt; {
                const x = t * roc_rocCanvas.width;
                // Tick
                roc_rocCtx.beginPath();
                roc_rocCtx.moveTo(x, roc_rocCanvas.height);
                roc_rocCtx.lineTo(x, roc_rocCanvas.height - 5);
                roc_rocCtx.stroke();
                // Label
                roc_rocCtx.textAlign = &#34;center&#34;;
                roc_rocCtx.fillText(t.toFixed(0), x, roc_rocCanvas.height + 20);
            });

            // X-axis label
                // Draw reference line (random classifier)
                roc_rocCtx.beginPath();
                roc_rocCtx.moveTo(0, roc_rocCanvas.height);
                roc_rocCtx.lineTo(roc_rocCanvas.width, 0);
                roc_rocCtx.strokeStyle = &#39;gray&#39;;
                roc_rocCtx.lineWidth = 1;
                roc_rocCtx.setLineDash([5, 5]);
                roc_rocCtx.stroke();
                roc_rocCtx.setLineDash([]);
                
                // Draw ROC curve points if we have any
                if (roc_rocPoints.length &gt; 0) {
                    // Only draw line if there are multiple points (after user has moved the slider)
                    if (roc_rocPoints.length &gt; 1) {
                        // Draw the curve connecting the points
                        roc_rocCtx.beginPath();
                        roc_rocCtx.moveTo(0, roc_rocCanvas.height); // Start at origin (0,1)
                        
                        // Sort points to ensure proper curve
                        const sortedPoints = [...roc_rocPoints].sort((a, b) =&gt; a.fpr - b.fpr);
                        
                        sortedPoints.forEach(point =&gt; {
                            const x = point.fpr * roc_rocCanvas.width;
                            const y = roc_rocCanvas.height - (point.tpr * roc_rocCanvas.height);
                            roc_rocCtx.lineTo(x, y);
                        });
                        
                        roc_rocCtx.strokeStyle = &#39;gray&#39;; // Changed from blue to gray
                        roc_rocCtx.lineWidth = 2;
                        roc_rocCtx.stroke();
                        
                        // Draw points
                        sortedPoints.forEach(point =&gt; {
                            const x = point.fpr * roc_rocCanvas.width;
                            const y = roc_rocCanvas.height - (point.tpr * roc_rocCanvas.height);
                            
                            roc_rocCtx.beginPath();
                            roc_rocCtx.arc(x, y, 3, 0, Math.PI * 2);
                            roc_rocCtx.fillStyle = &#39;gray&#39;; // Changed from blue to gray
                            roc_rocCtx.fill();
                        });
                    }
                    
                    // Draw current operating point
                    const tpr = roc_truePositives / (roc_truePositives + roc_falseNegatives) || 0;
                    const fpr = roc_falsePositives / (roc_falsePositives + roc_trueNegatives) || 0;
                    
                    const currentX = fpr * roc_rocCanvas.width;
                    const currentY = roc_rocCanvas.height - (tpr * roc_rocCanvas.height);
                    
                    roc_rocCtx.beginPath();
                    roc_rocCtx.arc(currentX, currentY, 6, 0, Math.PI * 2);
                    roc_rocCtx.fillStyle = &#39;gray&#39;; // Changed from red to gray
                    roc_rocCtx.fill();
                    roc_rocCtx.strokeStyle = &#39;black&#39;;
                    roc_rocCtx.lineWidth = 1;
                    roc_rocCtx.stroke();
                }
            }
            
            // Add a new ROC point for current size
            function roc_addROCPoint() {
                const tpr = roc_truePositives / (roc_truePositives + roc_falseNegatives) || 0;
                const fpr = roc_falsePositives / (roc_falsePositives + roc_trueNegatives) || 0;
                
                // Check if we already have a point with the exact same size
                const existingPoint = roc_rocPoints.find(p =&gt; p.size === roc_circleSizePercent);
                
                if (existingPoint) {
                    // Update existing point
                    existingPoint.tpr = tpr;
                    existingPoint.fpr = fpr;
                } else {
                    // Add new point
                    roc_rocPoints.push({
                        tpr,
                        fpr,
                        size: roc_circleSizePercent
                    });
                }
                
                // Sort points by size
                roc_rocPoints.sort((a, b) =&gt; a.size - b.size);
            }
            
            // Remove ROC points above a certain size
            function roc_removeROCPointsAboveSize(size) {
                roc_rocPoints = roc_rocPoints.filter(point =&gt; point.size &lt;= size);
            }
            
            // Update quadrant labels dynamically based on circle position
            function roc_updateLabels() {
                // Get vertical dividing line position
                const midX = roc_canvas.width / 2;
                
                // Check if circle overlaps with left or right half
                const leftEdge = roc_centerX - roc_circleRadius;
                const rightEdge = roc_centerX + roc_circleRadius;
                const topEdge = roc_centerY - roc_circleRadius;
                const bottomEdge = roc_centerY + roc_circleRadius;
                const overlapsLeft = leftEdge &lt; midX;
                const overlapsRight = rightEdge &gt; midX;
                
                // Padding to ensure labels stay within canvas
                const padding = 20;
                const labelWidth = 70;
                const labelHeight = 40;
                
                // 1. False Positives (inside circle, left side)
                if (overlapsLeft &amp;&amp; roc_falsePositives &gt; 0) {
                    const fpX = Math.max(padding, Math.min(midX - labelWidth - padding, roc_centerX - roc_circleRadius / 2));
                    const fpY = roc_centerY;
                    roc_quadrantLabels[0].style.display = &#39;block&#39;;
                    roc_quadrantLabels[0].style.left = fpX + &#39;px&#39;;
                    roc_quadrantLabels[0].style.top = fpY + &#39;px&#39;;
                } else {
                    roc_quadrantLabels[0].style.display = &#39;none&#39;;
                }
                
                // 2. True Positives (inside circle, right side)
                if (overlapsRight &amp;&amp; roc_truePositives &gt; 0) {
                    const tpX = Math.min(roc_canvas.width - labelWidth - padding, Math.max(midX + padding, roc_centerX + roc_circleRadius / 3));
                    const tpY = roc_centerY;
                    roc_quadrantLabels[1].style.display = &#39;block&#39;;
                    roc_quadrantLabels[1].style.left = tpX + &#39;px&#39;;
                    roc_quadrantLabels[1].style.top = tpY + &#39;px&#39;;
                } else {
                    roc_quadrantLabels[1].style.display = &#39;none&#39;;
                }
                
                // 3. True Negatives (outside circle, left side)
                // Only show if there&#39;s sufficient space between the circle and the edge
                const safeDistanceFromCircle = 50; // Minimum distance needed
                const distanceLeftEdge = leftEdge;
                
                if (roc_trueNegatives &gt; 0 &amp;&amp; distanceLeftEdge &gt; safeDistanceFromCircle) {
                    const tnX = padding;
                    const tnY = padding;
                    roc_quadrantLabels[2].style.display = &#39;block&#39;;
                    roc_quadrantLabels[2].style.left = tnX + &#39;px&#39;;
                    roc_quadrantLabels[2].style.top = tnY + &#39;px&#39;;
                } else {
                    // Hide when circle gets too close
                    roc_quadrantLabels[2].style.display = &#39;none&#39;;
                }
                
                // 4. False Negatives (outside circle, right side)
                // Only show if there&#39;s sufficient space between the circle and right edge
                const distanceRightEdge = roc_canvas.width - rightEdge;
                
                if (roc_falseNegatives &gt; 0 &amp;&amp; distanceRightEdge &gt; safeDistanceFromCircle) {
                    const fnX = roc_canvas.width - labelWidth - padding;
                    const fnY = padding;
                    roc_quadrantLabels[3].style.display = &#39;block&#39;;
                    roc_quadrantLabels[3].style.left = fnX + &#39;px&#39;;
                    roc_quadrantLabels[3].style.top = fnY + &#39;px&#39;;
                } else {
                    // Hide when circle gets too close
                    roc_quadrantLabels[3].style.display = &#39;none&#39;;
                }
            }
            
            // Check if a point is inside the circle
            function roc_isInsideCircle(x, y) {
                const dx = x - roc_centerX;
                const dy = y - roc_centerY;
                return (dx * dx + dy * dy) &lt;= (roc_circleRadius * roc_circleRadius);
            }
            
            // Calculate distance from a point to the circle
            function roc_distanceToCircle(x, y) {
                const dx = x - roc_centerX;
                const dy = y - roc_centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return Math.max(0, distance - roc_circleRadius);
            }
            
            // Initialize the first ROC point for the starting size
            function roc_initROCPoint() {
                roc_rocPoints = [];
                roc_addROCPoint();
            }
            
            // Mouse events for dragging the circle
            function roc_setupDragEvents() {
                roc_canvas.addEventListener(&#39;mousedown&#39;, function(e) {
                    const rect = roc_canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Check if click is near the circle center
                    const dx = mouseX - roc_centerX;
                    const dy = mouseY - roc_centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance &lt;= roc_circleRadius) {
                        roc_isDragging = true;
                        roc_dragStartPos = { x: mouseX, y: mouseY };
                        roc_dragStartCenter = { x: roc_circleCenter.x, y: roc_circleCenter.y };
                        roc_canvas.style.cursor = &#39;grabbing&#39;;
                    }
                });
                
                roc_canvas.addEventListener(&#39;mousemove&#39;, function(e) {
                    if (!roc_isDragging) return;
                    
                    const rect = roc_canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Calculate new center position
                    const dx = (mouseX - roc_dragStartPos.x) / roc_canvas.width;
                    const dy = (mouseY - roc_dragStartPos.y) / roc_canvas.height;
                    
                    roc_circleCenter.x = Math.max(0.1, Math.min(0.9, roc_dragStartCenter.x + dx));
                    roc_circleCenter.y = Math.max(0.1, Math.min(0.9, roc_dragStartCenter.y + dy));
                    
                    roc_calculateDimensions();
                    roc_redrawCanvas();
                    roc_recalculateMetrics();
                    roc_updateLabels();
                    roc_updateROCCurve();
                });
                
                roc_canvas.addEventListener(&#39;mouseup&#39;, function() {
                    if (roc_isDragging) {
                        roc_isDragging = false;
                        roc_canvas.style.cursor = &#39;move&#39;;
                    }
                });
                
                roc_canvas.addEventListener(&#39;mouseleave&#39;, function() {
                    if (roc_isDragging) {
                        roc_isDragging = false;
                        roc_canvas.style.cursor = &#39;move&#39;;
                    }
                });
                
                // Set initial cursor
                roc_canvas.style.cursor = &#39;move&#39;;
            }
            
            // Touch events for mobile
            function roc_setupTouchEvents() {
                roc_canvas.addEventListener(&#39;touchstart&#39;, function(e) {
                    e.preventDefault();
                    const rect = roc_canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    
                    // Check if touch is near the circle center
                    const dx = touchX - roc_centerX;
                    const dy = touchY - roc_centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance &lt;= roc_circleRadius) {
                        roc_isDragging = true;
                        roc_dragStartPos = { x: touchX, y: touchY };
                        roc_dragStartCenter = { x: roc_circleCenter.x, y: roc_circleCenter.y };
                    }
                });
                
                roc_canvas.addEventListener(&#39;touchmove&#39;, function(e) {
                    if (!roc_isDragging) return;
                    e.preventDefault();
                    
                    const rect = roc_canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    
                    // Calculate new center position
                    const dx = (touchX - roc_dragStartPos.x) / roc_canvas.width;
                    const dy = (touchY - roc_dragStartPos.y) / roc_canvas.height;
                    
                    roc_circleCenter.x = Math.max(0.1, Math.min(0.9, roc_dragStartCenter.x + dx));
                    roc_circleCenter.y = Math.max(0.1, Math.min(0.9, roc_dragStartCenter.y + dy));
                    
                    roc_calculateDimensions();
                    roc_redrawCanvas();
                    roc_recalculateMetrics();
                    roc_updateLabels();
                    roc_updateROCCurve();
                });
                
                roc_canvas.addEventListener(&#39;touchend&#39;, function(e) {
                    e.preventDefault();
                    roc_isDragging = false;
                });
            }
            
            // Set canvas dimensions
            roc_resizeCanvas();
            
            // Setup events
            roc_setupSliderEvents();
            roc_setupTouchEvents(); // Simple touch events for slider only
            
            // Generate many more points
            roc_generatePoints(10000);
            
            // Initial calculations and rendering
            roc_calculateDimensions();
            roc_recalculateMetrics();
            roc_redrawCanvas();
            roc_updateLabels();
            
            // Initialize the ROC point for current size
            roc_initROCPoint();
            
            // Draw ROC curve
            roc_drawROCCurve();
            
            // Render formulas
            roc_renderFormulas();
            
            // Handle window resize
            window.addEventListener(&#39;resize&#39;, function() {
                roc_resizeCanvas();
                roc_redrawCanvas();
                roc_drawROCCurve();
                roc_updateLabels();
            });
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;br&gt;
&lt;p&gt;Isso seria equivalente a um modelo que faz previsões aleatórias, como jogar uma moeda para decidir entre positivo e negativo. Ou seja, um modelo sem poder preditivo.&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;um-modelo-melhor-que-o-baseline&#34;&gt;Um modelo melhor que o baseline&lt;/h2&gt;
&lt;p&gt;Um bom modelo de classificação consegue obter uma sensibilidade alta sem produzir muitos falsos positivos. Utilizando a mesma simulação, uma possibilidade seria um círculo que cresce com início inteiramente no lado direito (captando mais positivos inicialmente). Aumente o tamanho do círculo na visualização abaixo e observe o que acontece.&lt;/p&gt;
&lt;br&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;
    &lt;link rel=&#34;stylesheet&#34; href=&#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/katex.min.css&#34;&gt;
    &lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/katex.min.js&#34;&gt;&lt;/script&gt;
    &lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/contrib/auto-render.min.js&#34;&gt;&lt;/script&gt;
    &lt;script&gt;
        // Ensure KaTeX is fully loaded before page initialization
        document.addEventListener(&#39;DOMContentLoaded&#39;, function() {
            if (typeof katex !== &#39;undefined&#39;) {
                console.log(&#34;KaTeX loaded successfully&#34;);
            } else {
                console.error(&#34;KaTeX failed to load&#34;);
            }
        });
    &lt;/script&gt;
    &lt;style&gt;
        
        .roc2_simulation-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .roc2_control-panel {
            width: 100%;
            max-width: 80%;
            margin: 0 auto 20px;
        }
        
        .roc2_slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
            position: relative;
            width: 100%;
            max-width: 350px;
        }
        
        .roc2_slider-container label {
            font-weight: bold;
            min-width: 100px;
            color: #333;
            margin-bottom: 1px;
        }
        
        .roc2_range-slider {
            width: 100%;
            position: relative;
        }
        
        .roc2_range-slider-track {
            height: 8px;
            width: 100%;
            background-color: #ddd;
            border-radius: 4px;
            position: relative;
        }
        
        .roc2_range-slider-fill {
            height: 100%;
            background-color: #3b82f6;
            border-radius: 4px;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            transition: width 0.1s ease;
        }
        
        input[type=&#34;range&#34;] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: transparent;
            position: absolute;
            top: 0;
            left: 0;
            margin: 0;
            z-index: 10;
        }

        input[type=&#34;range&#34;]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type=&#34;range&#34;]::-webkit-slider-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        input[type=&#34;range&#34;]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type=&#34;range&#34;]::-moz-range-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        .roc2_slider-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #3b82f6;
            background-color: #f0f4ff;
            padding: 4px 8px;
            border-radius: 12px;
            margin-left: 10px;
            border: 1px solid #d1d5db;
        }
        
        .roc2_flex-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 3%; /* Increased from 20px */
        }
        
        .roc2_visualization-area {
            flex: 1;
            min-width: 300px;
        }
        
        .roc2_roc-area {
            flex: 1;
            min-width: 300px;
        }
        
        .roc2_canvas-container {
            position: relative;
            width: 100%;
            padding-bottom: 85%;
            border: 1px solid #ddd;
            overflow: hidden;
            background-color: white;
        }

        #roc2_canvas, #roc2_rocCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: move;
        }
        
        .roc2_quadrant-label {
            position: absolute;
            white-space: nowrap;
            font-size: 17px;
            text-align: center;
            color: #fff;
            background-color: rgba(0, 0, 0, 1);
            padding: 1px 5px;
            border-radius: 10px;
            z-index: 10;
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        .roc2_metrics-display {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f8f9fa;
        }
        
        .roc2_metrics-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }
        
        .roc2_metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .roc2_metric-card {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
        }
        
        .roc2_metric-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            color: #333;
        }
        
        .roc2_metric-formula {
            text-align: center;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .roc2_metric-value {
            text-align: center;
            font-weight: bold;
            font-size: 18px;
            color: #3b82f6;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .roc2_flex-container {
                flex-direction: column;
            }
            
            .roc2_metrics-grid {
                grid-template-columns: 1fr;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&#34;roc2_simulation-container&#34;&gt;
        
        &lt;div class=&#34;roc2_control-panel&#34;&gt;
            &lt;div class=&#34;roc2_slider-container&#34;&gt;
                &lt;label for=&#34;roc2_circleSize&#34;&gt;Tamanho do círculo&lt;/label&gt;
                &lt;div class=&#34;roc2_range-slider&#34;&gt;
                    &lt;div class=&#34;roc2_range-slider-track&#34;&gt;
                        &lt;div class=&#34;roc2_range-slider-fill&#34; id=&#34;roc2_circleSizeFill&#34;&gt;&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;input type=&#34;range&#34; id=&#34;roc2_circleSize&#34; min=&#34;0&#34; max=&#34;100&#34; value=&#34;0&#34; step=&#34;1&#34;&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class=&#34;roc2_flex-container&#34;&gt;
            &lt;!-- Visualization Area --&gt;
            &lt;div class=&#34;roc2_visualization-area&#34;&gt;
                &lt;div class=&#34;roc2_canvas-container&#34;&gt;
                    &lt;canvas id=&#34;roc2_canvas&#34;&gt;&lt;/canvas&gt;
                    &lt;div id=&#34;roc2_quadrant0&#34; class=&#34;roc2_quadrant-label&#34;&gt;False&lt;br&gt;Positives&lt;/div&gt;
                    &lt;div id=&#34;roc2_quadrant1&#34; class=&#34;roc2_quadrant-label&#34;&gt;True&lt;br&gt;Positives&lt;/div&gt;
                    &lt;div id=&#34;roc2_quadrant2&#34; class=&#34;roc2_quadrant-label&#34;&gt;True&lt;br&gt;Negatives&lt;/div&gt;
                    &lt;div id=&#34;roc2_quadrant3&#34; class=&#34;roc2_quadrant-label&#34;&gt;False&lt;br&gt;Negatives&lt;/div&gt;
                &lt;/div&gt;
                
                &lt;div style=&#34;display: flex; justify-content: space-between; width: 100%; font-weight: bold; margin-top: 5px;&#34;&gt;
                    &lt;span&gt;Negatives&lt;/span&gt;
                    &lt;span&gt;Positives&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;!-- Right side: ROC Curve and Metrics --&gt;
            &lt;div class=&#34;roc2_roc-area&#34;&gt;
            &lt;!-- ROC Curve with Y-axis labels --&gt;
            &lt;div style=&#34;display: flex; align-items: stretch; margin-bottom: 0px;&#34;&gt;
                &lt;!-- Y-axis labels --&gt;
                &lt;div style=&#34;display: flex; flex-direction: column; font-weight: bold; width: 40px; position: relative; height: 300px;&#34;&gt;
                    &lt;span style=&#34;position: absolute; top: 0; right: 0;&#34;&gt;1.0&lt;/span&gt;
                    &lt;span style=&#34;position: absolute; writing-mode: vertical-rl; transform: rotate(180deg); left: 10px; top: 50%;&#34;&gt;TPR&lt;/span&gt;
                &lt;/div&gt;
                
                &lt;!-- ROC Curve canvas --&gt;
                &lt;div style=&#34;flex-grow: 1;&#34;&gt;
                    &lt;div class=&#34;roc2_canvas-container&#34; style=&#34;padding-bottom: 50%;&#34;&gt;
                        &lt;canvas id=&#34;roc2_rocCanvas&#34;&gt;&lt;/canvas&gt;
                    &lt;/div&gt;
                    
                    &lt;!-- X-axis labels --&gt;
                    &lt;div style=&#34;display: flex; justify-content: space-between; width: 100%; font-weight: bold; margin: 5px 0 10px 0;&#34;&gt;
                        &lt;span&gt;0.0&lt;/span&gt;
                        &lt;span style=&#34;text-align: center; flex-grow: 1;&#34;&gt;FPR&lt;/span&gt;
                        &lt;span&gt;1.0&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;/div&gt;
                
                &lt;!-- Compact Metrics Display --&gt;
                &lt;div class=&#34;roc2_metrics-display&#34; style=&#34;margin-top: 0; padding: 10px;&#34;&gt;
                    &lt;div class=&#34;roc2_metrics-grid&#34; style=&#34;grid-template-columns: 1fr 1fr; gap: 10px;&#34;&gt;
                        &lt;div class=&#34;roc2_metric-card&#34; style=&#34;padding: 8px;&#34;&gt;
                            &lt;div class=&#34;roc2_metric-name&#34; style=&#34;font-size: 20px; margin-bottom: 5px;text-align: center;&#34;&gt;TPR (True Positive Rate)&lt;/div&gt;
                            &lt;div class=&#34;roc2_metric-formula&#34; id=&#34;roc2_tprFormula&#34; style=&#34;min-height: 50px; font-size: 18px;&#34;&gt;Loading...&lt;/div&gt;
                            &lt;div class=&#34;roc2_metric-value&#34; id=&#34;roc2_tprValue&#34; style=&#34;margin-top: 5px; font-size: 22px;&#34;&gt;= 0.000&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class=&#34;roc2_metric-card&#34; style=&#34;padding: 8px;&#34;&gt;
                            &lt;div class=&#34;roc2_metric-name&#34; style=&#34;font-size: 20px; margin-bottom: 5px;text-align: center;&#34;&gt;FPR (False Positive Rate)&lt;/div&gt;
                            &lt;div class=&#34;roc2_metric-formula&#34; id=&#34;roc2_fprFormula&#34; style=&#34;min-height: 50px; font-size: 18px;&#34;&gt;Loading...&lt;/div&gt;
                            &lt;div class=&#34;roc2_metric-value&#34; id=&#34;roc2_fprValue&#34; style=&#34;margin-top: 5px; font-size: 22px;&#34;&gt;= 0.000&lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Ensure KaTeX is loaded completely before page init --&gt;
    &lt;script&gt;
        // Wait for all resources to load, including KaTeX
        window.addEventListener(&#39;load&#39;, function() {
            // Initialize simulation
            roc2_init();
        });
        
        function roc2_init() {
            // DOM Elements
            const roc2_canvas = document.getElementById(&#39;roc2_canvas&#39;);
            const roc2_ctx = roc2_canvas.getContext(&#39;2d&#39;);
            const roc2_rocCanvas = document.getElementById(&#39;roc2_rocCanvas&#39;);
            const roc2_rocCtx = roc2_rocCanvas.getContext(&#39;2d&#39;);
            const roc2_circleSizeSlider = document.getElementById(&#39;roc2_circleSize&#39;);
            const roc2_circleSizeFill = document.getElementById(&#39;roc2_circleSizeFill&#39;);
            const roc2_sizeValue = document.getElementById(&#39;roc2_sizeValue&#39;);
        
            // Quadrant labels
            const roc2_quadrantLabels = [
                document.getElementById(&#39;roc2_quadrant0&#39;),
                document.getElementById(&#39;roc2_quadrant1&#39;),
                document.getElementById(&#39;roc2_quadrant2&#39;),
                document.getElementById(&#39;roc2_quadrant3&#39;)
            ];
            
            // Metric displays
            const roc2_tprFormula = document.getElementById(&#39;roc2_tprFormula&#39;);
            const roc2_tprValue = document.getElementById(&#39;roc2_tprValue&#39;);
            const roc2_fprFormula = document.getElementById(&#39;roc2_fprFormula&#39;);
            const roc2_fprValue = document.getElementById(&#39;roc2_fprValue&#39;);
            
            // Variables
            let roc2_isDragging = false;
            let roc2_truePositives = 0;
            let roc2_falsePositives = 0;
            let roc2_trueNegatives = 0;
            let roc2_falseNegatives = 0;
            let roc2_totalPoints = 0;
            let roc2_points = [];
            let roc2_rocPoints = [];
            let roc2_currentSize = 0; // Track current circle size
            
            // Circle properties
            let roc2_circleRadius;
            let roc2_centerX;
            let roc2_centerY;
            let roc2_circleCenter = { x: 0.65, y: 0.5 }; // Normalized position (0-1) - CHANGED X FROM 0.5 TO 0.65
            let roc2_circleSizePercent = 0; // Percentage of min dimension
            let roc2_dragStartPos = { x: 0, y: 0 };
            let roc2_dragStartCenter = { x: 0, y: 0 };
            
            // Update slider fill
            function roc2_updateSliderFill() {
                const percent = (roc2_circleSizeSlider.value - roc2_circleSizeSlider.min) / (roc2_circleSizeSlider.max - roc2_circleSizeSlider.min) * 100;
                roc2_circleSizeFill.style.width = percent + &#39;%&#39;;
            }
            
            // Initial slider fill update
            roc2_updateSliderFill();
            
            // Setup slider events for changing circle size only
            function roc2_setupSliderEvents() {
                // Update slider fill and add event listener
                roc2_updateSliderFill();
                
                roc2_circleSizeSlider.addEventListener(&#39;input&#39;, function() {
                    // Store previous and current size for ROC curve updating
                    const prevSize = roc2_circleSizePercent;
                    roc2_circleSizePercent = parseInt(this.value);
                    roc2_currentSize = roc2_circleSizePercent;
                    
                    roc2_updateSliderFill();
                    roc2_calculateDimensions();
                    roc2_redrawCanvas();
                    roc2_recalculateMetrics();
                    roc2_updateLabels();
                    
                    // Update ROC curve based on whether size increased or decreased
                    if (roc2_circleSizePercent &gt; prevSize) {
                        roc2_addROCPoint();
                    } else if (roc2_circleSizePercent &lt; prevSize) {
                        roc2_removeROCPointsAboveSize(roc2_circleSizePercent);
                    }
                    
                    roc2_drawROCCurve();
                });
            }
            
            // Resize canvas to fit container
            function roc2_resizeCanvas() {
                const container = roc2_canvas.parentElement;
                roc2_canvas.width = container.clientWidth;
                roc2_canvas.height = container.clientHeight;
                
                const rocContainer = roc2_rocCanvas.parentElement;
                roc2_rocCanvas.width = rocContainer.clientWidth;
                roc2_rocCanvas.height = rocContainer.clientHeight;
                
                roc2_calculateDimensions();
                roc2_redrawCanvas();
                roc2_drawROCCurve();
                roc2_updateLabels();
            }
            
            // Calculate circle dimensions based on canvas size and current settings
            function roc2_calculateDimensions() {
                // Fixed center position (prevent dragging)
                roc2_centerX = roc2_canvas.width * roc2_circleCenter.x;
                roc2_centerY = roc2_canvas.height * roc2_circleCenter.y;
                const minDimension = Math.min(roc2_canvas.width, roc2_canvas.height);
                roc2_circleRadius = minDimension * (roc2_circleSizePercent / 100);
            }
            
            // Generate points
            function roc2_generatePoints(count) {
                roc2_points = [];
                
                // Generate half the points on the left side and half on the right
                for (let i = 0; i &lt; count / 2; i++) {
                    // Left side point (Negatives)
                    roc2_points.push({
                        x: Math.random() * (roc2_canvas.width / 2 - 5),
                        y: Math.random() * roc2_canvas.height
                    });
                    
                    // Right side point (Positives)
                    roc2_points.push({
                        x: (roc2_canvas.width / 2 + 5) + Math.random() * (roc2_canvas.width / 2 - 10),
                        y: Math.random() * roc2_canvas.height
                    });
                }
                
                roc2_recalculateMetrics();
            }
            
            // Update the class metrics based on the points
            function roc2_recalculateMetrics() {
                // Reset counts
                roc2_truePositives = 0;
                roc2_falsePositives = 0;
                roc2_trueNegatives = 0;
                roc2_falseNegatives = 0;
                
                // Recalculate counts for each point
                roc2_points.forEach(point =&gt; {
                    const isRight = point.x &gt;= roc2_canvas.width / 2;
                    const isPredictedPositive = roc2_isInsideCircle(point.x, point.y);
                    
                    if (isRight &amp;&amp; isPredictedPositive) roc2_truePositives++;
                    else if (!isRight &amp;&amp; isPredictedPositive) roc2_falsePositives++;
                    else if (!isRight &amp;&amp; !isPredictedPositive) roc2_trueNegatives++;
                    else if (isRight &amp;&amp; !isPredictedPositive) roc2_falseNegatives++;
                });
                
                roc2_totalPoints = roc2_points.length;
                
                // Update the metric displays
                roc2_updateMetricDisplay();
            }
            
            // Update metric display
            function roc2_updateMetricDisplay() {
                // Calculate TPR and FPR
                const tpr = roc2_truePositives / (roc2_truePositives + roc2_falseNegatives) || 0;
                const fpr = roc2_falsePositives / (roc2_falsePositives + roc2_trueNegatives) || 0;
                
                // Update display values with equal sign
                roc2_tprValue.textContent = &#34;= &#34; + tpr.toFixed(3);
                roc2_fprValue.textContent = &#34;= &#34; + fpr.toFixed(3);
                
                // Properly format the equations for KaTeX
                const tprFormulaText = `\\frac{TP}{TP + FN} = \\frac{${roc2_truePositives}}{${roc2_truePositives} + ${roc2_falseNegatives}}`;
                const fprFormulaText = `\\frac{FP}{FP + TN} = \\frac{${roc2_falsePositives}}{${roc2_falsePositives} + ${roc2_trueNegatives}}`;
                
                // Set the text content for later rendering
                roc2_tprFormula.setAttribute(&#39;data-formula&#39;, tprFormulaText);
                roc2_fprFormula.setAttribute(&#39;data-formula&#39;, fprFormulaText);
                
                // Render with KaTeX
                roc2_renderFormulas();
            }
            
            // Properly format the equations for KaTeX with larger font
            function roc2_renderFormulas() {
                try {
                    if (typeof katex !== &#39;undefined&#39;) {
                        const tprFormulaText = roc2_tprFormula.getAttribute(&#39;data-formula&#39;);
                        const fprFormulaText = roc2_fprFormula.getAttribute(&#39;data-formula&#39;);
                        
                        katex.render(tprFormulaText, roc2_tprFormula, {
                            displayMode: true,
                            throwOnError: false,
                            fontSize: &#39;1.2em&#39; // Larger font size
                        });
                        
                        katex.render(fprFormulaText, roc2_fprFormula, {
                            displayMode: true,
                            throwOnError: false,
                            fontSize: &#39;1.2em&#39; // Larger font size
                        });
                    } else {
                        console.error(&#34;KaTeX not available for rendering&#34;);
                        // Fallback to plain text if rendering fails
                        roc2_tprFormula.textContent = roc2_tprFormula.getAttribute(&#39;data-formula&#39;);
                        roc2_fprFormula.textContent = roc2_fprFormula.getAttribute(&#39;data-formula&#39;);
                    }
                } catch (error) {
                    console.error(&#34;KaTeX rendering error:&#34;, error);
                }
            }
            
            // Draw all points
            function roc2_drawPoints() {
                roc2_points.forEach(point =&gt; {
                    const isRight = point.x &gt;= roc2_canvas.width / 2;
                    
                    // Choose color based on actual class (left/right side)
                    if (isRight) {
                        roc2_ctx.fillStyle = &#39;blue&#39;; // Actual Positive (right side)
                    } else {
                        roc2_ctx.fillStyle = &#39;red&#39;; // Actual Negative (left side)
                    }
                    
                    roc2_ctx.beginPath();
                    roc2_ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                    roc2_ctx.fill();
                });
            }
            
            // Redraw canvas with all points and current circle position
            function roc2_redrawCanvas() {
                roc2_ctx.clearRect(0, 0, roc2_canvas.width, roc2_canvas.height);
                
                // Draw points
                roc2_drawPoints();
                
                // Draw dividing line
                roc2_ctx.beginPath();
                roc2_ctx.moveTo(roc2_canvas.width / 2, 0);
                roc2_ctx.lineTo(roc2_canvas.width / 2, roc2_canvas.height);
                roc2_ctx.strokeStyle = &#39;black&#39;;
                roc2_ctx.lineWidth = 2;
                roc2_ctx.stroke();
                
                // Draw circle
                roc2_ctx.beginPath();
                roc2_ctx.arc(roc2_centerX, roc2_centerY, roc2_circleRadius, 0, Math.PI * 2);
                roc2_ctx.fillStyle = &#39;rgba(0, 0, 255, 0.15)&#39;;
                roc2_ctx.fill();
                roc2_ctx.strokeStyle = &#39;black&#39;; // Changed to black for better visibility
                roc2_ctx.lineWidth = 3;
                roc2_ctx.stroke();
                
                // Draw border
                roc2_ctx.strokeStyle = &#39;#ddd&#39;;
                roc2_ctx.lineWidth = 1;
                roc2_ctx.strokeRect(0, 0, roc2_canvas.width, roc2_canvas.height);
            }
            
            // Draw the ROC curve
            function roc2_drawROCCurve() {
                roc2_rocCtx.clearRect(0, 0, roc2_rocCanvas.width, roc2_rocCanvas.height);
                
                            // Draw axes
            roc2_rocCtx.beginPath();
            // Y-axis (left)
            roc2_rocCtx.moveTo(0, roc2_rocCanvas.height);
            roc2_rocCtx.lineTo(0, 0);
            // X-axis (bottom)
            roc2_rocCtx.moveTo(0, roc2_rocCanvas.height);
            roc2_rocCtx.lineTo(roc2_rocCanvas.width, roc2_rocCanvas.height);
            roc2_rocCtx.stroke();

            // Y-axis label
            roc2_rocCtx.save();
            roc2_rocCtx.translate(20, roc2_rocCanvas.height/2); // Adjust left position
            roc2_rocCtx.rotate(-Math.PI/2);
            roc2_rocCtx.restore();

            // Y-ticks (only 0 and 1)
            [0, 1].forEach(t =&gt; {
                const y = roc2_rocCanvas.height - (t * roc2_rocCanvas.height);
                // Tick
                roc2_rocCtx.beginPath();
                roc2_rocCtx.moveTo(0, y);
                roc2_rocCtx.lineTo(5, y);
                roc2_rocCtx.stroke();
                // Label
                roc2_rocCtx.textAlign = &#34;right&#34;;
                roc2_rocCtx.fillText(t.toFixed(0), -8, y + 4);
            });

            // X-ticks (only 0 and 1)
            [0, 1].forEach(t =&gt; {
                const x = t * roc2_rocCanvas.width;
                // Tick
                roc2_rocCtx.beginPath();
                roc2_rocCtx.moveTo(x, roc2_rocCanvas.height);
                roc2_rocCtx.lineTo(x, roc2_rocCanvas.height - 5);
                roc2_rocCtx.stroke();
                // Label
                roc2_rocCtx.textAlign = &#34;center&#34;;
                roc2_rocCtx.fillText(t.toFixed(0), x, roc2_rocCanvas.height + 20);
            });

            // X-axis label
                // Draw reference line (random classifier)
                roc2_rocCtx.beginPath();
                roc2_rocCtx.moveTo(0, roc2_rocCanvas.height);
                roc2_rocCtx.lineTo(roc2_rocCanvas.width, 0);
                roc2_rocCtx.strokeStyle = &#39;gray&#39;;
                roc2_rocCtx.lineWidth = 1;
                roc2_rocCtx.setLineDash([5, 5]);
                roc2_rocCtx.stroke();
                roc2_rocCtx.setLineDash([]);
                
                // Draw ROC curve points if we have any
                if (roc2_rocPoints.length &gt; 0) {
                    // Only draw line if there are multiple points (after user has moved the slider)
                    if (roc2_rocPoints.length &gt; 1) {
                        // Draw the curve connecting the points
                        roc2_rocCtx.beginPath();
                        roc2_rocCtx.moveTo(0, roc2_rocCanvas.height); // Start at origin (0,1)
                        
                        // Sort points to ensure proper curve
                        const sortedPoints = [...roc2_rocPoints].sort((a, b) =&gt; a.fpr - b.fpr);
                        
                        sortedPoints.forEach(point =&gt; {
                            const x = point.fpr * roc2_rocCanvas.width;
                            const y = roc2_rocCanvas.height - (point.tpr * roc2_rocCanvas.height);
                            roc2_rocCtx.lineTo(x, y);
                        });
                        
                        roc2_rocCtx.strokeStyle = &#39;gray&#39;; // Changed from blue to gray
                        roc2_rocCtx.lineWidth = 2;
                        roc2_rocCtx.stroke();
                        
                        // Draw points
                        sortedPoints.forEach(point =&gt; {
                            const x = point.fpr * roc2_rocCanvas.width;
                            const y = roc2_rocCanvas.height - (point.tpr * roc2_rocCanvas.height);
                            
                            roc2_rocCtx.beginPath();
                            roc2_rocCtx.arc(x, y, 3, 0, Math.PI * 2);
                            roc2_rocCtx.fillStyle = &#39;gray&#39;; // Changed from blue to gray
                            roc2_rocCtx.fill();
                        });
                    }
                    
                    // Draw current operating point
                    const tpr = roc2_truePositives / (roc2_truePositives + roc2_falseNegatives) || 0;
                    const fpr = roc2_falsePositives / (roc2_falsePositives + roc2_trueNegatives) || 0;
                    
                    const currentX = fpr * roc2_rocCanvas.width;
                    const currentY = roc2_rocCanvas.height - (tpr * roc2_rocCanvas.height);
                    
                    roc2_rocCtx.beginPath();
                    roc2_rocCtx.arc(currentX, currentY, 6, 0, Math.PI * 2);
                    roc2_rocCtx.fillStyle = &#39;gray&#39;; // Changed from red to gray
                    roc2_rocCtx.fill();
                    roc2_rocCtx.strokeStyle = &#39;black&#39;;
                    roc2_rocCtx.lineWidth = 1;
                    roc2_rocCtx.stroke();
                }
            }
            
            // Add a new ROC point for current size
            function roc2_addROCPoint() {
                const tpr = roc2_truePositives / (roc2_truePositives + roc2_falseNegatives) || 0;
                const fpr = roc2_falsePositives / (roc2_falsePositives + roc2_trueNegatives) || 0;
                
                // Check if we already have a point with the exact same size
                const existingPoint = roc2_rocPoints.find(p =&gt; p.size === roc2_circleSizePercent);
                
                if (existingPoint) {
                    // Update existing point
                    existingPoint.tpr = tpr;
                    existingPoint.fpr = fpr;
                } else {
                    // Add new point
                    roc2_rocPoints.push({
                        tpr,
                        fpr,
                        size: roc2_circleSizePercent
                    });
                }
                
                // Sort points by size
                roc2_rocPoints.sort((a, b) =&gt; a.size - b.size);
            }
            
            // Remove ROC points above a certain size
            function roc2_removeROCPointsAboveSize(size) {
                roc2_rocPoints = roc2_rocPoints.filter(point =&gt; point.size &lt;= size);
            }
            
            // Update quadrant labels dynamically based on circle position
            function roc2_updateLabels() {
                // Get vertical dividing line position
                const midX = roc2_canvas.width / 2;
                
                // Check if circle overlaps with left or right half
                const leftEdge = roc2_centerX - roc2_circleRadius;
                const rightEdge = roc2_centerX + roc2_circleRadius;
                const topEdge = roc2_centerY - roc2_circleRadius;
                const bottomEdge = roc2_centerY + roc2_circleRadius;
                const overlapsLeft = leftEdge &lt; midX;
                const overlapsRight = rightEdge &gt; midX;
                
                // Padding to ensure labels stay within canvas
                const padding = 20;
                const labelWidth = 70;
                const labelHeight = 40;
                
                // 1. False Positives (inside circle, left side)
                if (overlapsLeft &amp;&amp; roc2_falsePositives &gt; 0) {
                    const fpX = Math.max(padding, Math.min(midX - labelWidth - padding, roc2_centerX - roc2_circleRadius / 2));
                    const fpY = roc2_centerY;
                    roc2_quadrantLabels[0].style.display = &#39;block&#39;;
                    roc2_quadrantLabels[0].style.left = fpX + &#39;px&#39;;
                    roc2_quadrantLabels[0].style.top = fpY + &#39;px&#39;;
                } else {
                    roc2_quadrantLabels[0].style.display = &#39;none&#39;;
                }
                
                // 2. True Positives (inside circle, right side)
                if (overlapsRight &amp;&amp; roc2_truePositives &gt; 0) {
                    const tpX = Math.min(roc2_canvas.width - labelWidth - padding, Math.max(midX + padding, roc2_centerX + roc2_circleRadius / 3));
                    const tpY = roc2_centerY;
                    roc2_quadrantLabels[1].style.display = &#39;block&#39;;
                    roc2_quadrantLabels[1].style.left = tpX + &#39;px&#39;;
                    roc2_quadrantLabels[1].style.top = tpY + &#39;px&#39;;
                } else {
                    roc2_quadrantLabels[1].style.display = &#39;none&#39;;
                }
                
                // 3. True Negatives (outside circle, left side)
                // Only show if there&#39;s sufficient space between the circle and the edge
                const safeDistanceFromCircle = 5; // Minimum distance needed
                const distanceLeftEdge = leftEdge;
                
                if (roc2_trueNegatives &gt; 0 &amp;&amp; distanceLeftEdge &gt; safeDistanceFromCircle) {
                    const tnX = padding;
                    const tnY = padding;
                    roc2_quadrantLabels[2].style.display = &#39;block&#39;;
                    roc2_quadrantLabels[2].style.left = tnX + &#39;px&#39;;
                    roc2_quadrantLabels[2].style.top = tnY + &#39;px&#39;;
                } else {
                    // Hide when circle gets too close
                    roc2_quadrantLabels[2].style.display = &#39;none&#39;;
                }
                
                // 4. False Negatives (outside circle, right side)
                // Only show if there&#39;s sufficient space between the circle and right edge
                const distanceRightEdge = roc2_canvas.width - rightEdge;
                
                if (roc2_falseNegatives &gt; 0 &amp;&amp; distanceRightEdge &gt; safeDistanceFromCircle) {
                    const fnX = roc2_canvas.width - labelWidth - padding;
                    const fnY = padding;
                    roc2_quadrantLabels[3].style.display = &#39;block&#39;;
                    roc2_quadrantLabels[3].style.left = fnX + &#39;px&#39;;
                    roc2_quadrantLabels[3].style.top = fnY + &#39;px&#39;;
                } else {
                    // Hide when circle gets too close
                    roc2_quadrantLabels[3].style.display = &#39;none&#39;;
                }
            }
            
            // Check if a point is inside the circle
            function roc2_isInsideCircle(x, y) {
                const dx = x - roc2_centerX;
                const dy = y - roc2_centerY;
                return (dx * dx + dy * dy) &lt;= (roc2_circleRadius * roc2_circleRadius);
            }
            
            // Calculate distance from a point to the circle
            function roc2_distanceToCircle(x, y) {
                const dx = x - roc2_centerX;
                const dy = y - roc2_centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return Math.max(0, distance - roc2_circleRadius);
            }
            
            // Initialize the first ROC point for the starting size
            function roc2_initROCPoint() {
                roc2_rocPoints = [];
                roc2_addROCPoint();
            }
            
            // Mouse events for dragging the circle
            function roc2_setupDragEvents() {
                roc2_canvas.addEventListener(&#39;mousedown&#39;, function(e) {
                    const rect = roc2_canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Check if click is near the circle center
                    const dx = mouseX - roc2_centerX;
                    const dy = mouseY - roc2_centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance &lt;= roc2_circleRadius) {
                        roc2_isDragging = true;
                        roc2_dragStartPos = { x: mouseX, y: mouseY };
                        roc2_dragStartCenter = { x: roc2_circleCenter.x, y: roc2_circleCenter.y };
                        roc2_canvas.style.cursor = &#39;grabbing&#39;;
                    }
                });
                
                roc2_canvas.addEventListener(&#39;mousemove&#39;, function(e) {
                    if (!roc2_isDragging) return;
                    
                    const rect = roc2_canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Calculate new center position
                    const dx = (mouseX - roc2_dragStartPos.x) / roc2_canvas.width;
                    const dy = (mouseY - roc2_dragStartPos.y) / roc2_canvas.height;
                    
                    roc2_circleCenter.x = Math.max(0.1, Math.min(0.9, roc2_dragStartCenter.x + dx));
                    roc2_circleCenter.y = Math.max(0.1, Math.min(0.9, roc2_dragStartCenter.y + dy));
                    
                    roc2_calculateDimensions();
                    roc2_redrawCanvas();
                    roc2_recalculateMetrics();
                    roc2_updateLabels();
                    roc2_updateROCCurve();
                });
                
                roc2_canvas.addEventListener(&#39;mouseup&#39;, function() {
                    if (roc2_isDragging) {
                        roc2_isDragging = false;
                        roc2_canvas.style.cursor = &#39;move&#39;;
                    }
                });
                
                roc2_canvas.addEventListener(&#39;mouseleave&#39;, function() {
                    if (roc2_isDragging) {
                        roc2_isDragging = false;
                        roc2_canvas.style.cursor = &#39;move&#39;;
                    }
                });
                
                // Set initial cursor
                roc2_canvas.style.cursor = &#39;move&#39;;
            }
            
            // Touch events for mobile
            function roc2_setupTouchEvents() {
                roc2_canvas.addEventListener(&#39;touchstart&#39;, function(e) {
                    e.preventDefault();
                    const rect = roc2_canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    
                    // Check if touch is near the circle center
                    const dx = touchX - roc2_centerX;
                    const dy = touchY - roc2_centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance &lt;= roc2_circleRadius) {
                        roc2_isDragging = true;
                        roc2_dragStartPos = { x: touchX, y: touchY };
                        roc2_dragStartCenter = { x: roc2_circleCenter.x, y: roc2_circleCenter.y };
                    }
                });
                
                roc2_canvas.addEventListener(&#39;touchmove&#39;, function(e) {
                    if (!roc2_isDragging) return;
                    e.preventDefault();
                    
                    const rect = roc2_canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    
                    // Calculate new center position
                    const dx = (touchX - roc2_dragStartPos.x) / roc2_canvas.width;
                    const dy = (touchY - roc2_dragStartPos.y) / roc2_canvas.height;
                    
                    roc2_circleCenter.x = Math.max(0.1, Math.min(0.9, roc2_dragStartCenter.x + dx));
                    roc2_circleCenter.y = Math.max(0.1, Math.min(0.9, roc2_dragStartCenter.y + dy));
                    
                    roc2_calculateDimensions();
                    roc2_redrawCanvas();
                    roc2_recalculateMetrics();
                    roc2_updateLabels();
                    roc2_updateROCCurve();
                });
                
                roc2_canvas.addEventListener(&#39;touchend&#39;, function(e) {
                    e.preventDefault();
                    roc2_isDragging = false;
                });
            }
            
            // Set canvas dimensions
            roc2_resizeCanvas();
            
            // Setup events
            roc2_setupSliderEvents();
            roc2_setupTouchEvents(); // Simple touch events for slider only
            
            // Generate many more points
            roc2_generatePoints(10000);
            
            // Initial calculations and rendering
            roc2_calculateDimensions();
            roc2_recalculateMetrics();
            roc2_redrawCanvas();
            roc2_updateLabels();
            
            // Initialize the ROC point for current size
            roc2_initROCPoint();
            
            // Draw ROC curve
            roc2_drawROCCurve();
            
            // Render formulas
            roc2_renderFormulas();
            
            // Handle window resize
            window.addEventListener(&#39;resize&#39;, function() {
                roc2_resizeCanvas();
                roc2_redrawCanvas();
                roc2_drawROCCurve();
                roc2_updateLabels();
            });
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;br&gt;
&lt;p&gt;Como observamos, após certa medida, o círculo começa a captar parte do lado esquerdo, gerando falsos positivos. Quando plotamos a curva ROC nesse caso, obtemos uma curva que se arqueia para o canto superior esquerdo do gráfico&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;Vale a pena destacar que a curva ROC pode ser enganosa para conjuntos de dados muito desbalanceados. Como um último exemplo, vamos observar o que acontece com a curva nesse cenário.&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;dados-desbalanceados&#34;&gt;Dados Desbalanceados&lt;/h2&gt;
&lt;p&gt;Quando os dados são altamente desbalanceados (por exemplo, fraude bancária onde menos de 0,1% das transações são fraudulentas), a curva ROC pode mascarar problemas de desempenho. Na curva ROC, os falsos positivos são medidos em relação ao número total de negativos (FPR = FP/N). Com muitos exemplos negativos, cada falso positivo tem um impacto pequeno na taxa de falsos positivos. Isso pode fazer com que um modelo pareça melhor do que realmente é. Para dados desbalanceados, considere usar a curva &lt;strong&gt;Precisão-Recall (PR)&lt;/strong&gt;.&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;A simulação abaixo mostra na prática a diferença entre as curvas ROC e PR. É possível alterar tanto o tamanho do círculo quanto a porcentagem da classe positiva no conjunto de dados. Varie primeiramente o tamanho do círculo e veja as duas curvas surgindo.&lt;/p&gt;
&lt;br&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;
    &lt;style&gt;
        
        .dual_simulation-container {
            max-width: 1200px;
            margin: 0 auto;
            /* You can adjust this min-height to increase simulation height */
            min-height: 600px;
        }
        
        .dual_dataset-info {
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
        }
        
        .dual_flex-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 3%;
        }
        
        .dual_side {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
        }
        
        .dual_slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
            position: relative;
            width: 100%;
            margin-bottom: 20px;
        }
        
        .dual_slider-container label {
            font-weight: bold;
            min-width: 120px;
            color: #333;
            margin-bottom: 1px;
        }
        
        .dual_range-slider {
            flex: 1;
            position: relative;
        }
        
        .dual_range-slider-track {
            height: 8px;
            width: 100%;
            background-color: #ddd;
            border-radius: 4px;
            position: relative;
        }
        
        .dual_range-slider-fill {
            height: 100%;
            background-color: #3b82f6;
            border-radius: 4px;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            transition: width 0.1s ease;
        }
        
        input[type=&#34;range&#34;] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: transparent;
            position: absolute;
            top: 0;
            left: 0;
            margin: 0;
            z-index: 10;
        }

        input[type=&#34;range&#34;]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type=&#34;range&#34;]::-webkit-slider-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        input[type=&#34;range&#34;]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type=&#34;range&#34;]::-moz-range-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }
        
        .dual_value-display {
            min-width: 60px;
            text-align: center;
            font-weight: bold;
            color: #3b82f6;
            background-color: #f0f4ff;
            padding: 4px 8px;
            border-radius: 12px;
            border: 1px solid #d1d5db;
            margin-left: 10px;
        }
        
        .dual_canvas-container {
            position: relative;
            width: 100%;
            padding-bottom: 100%;
            border: 1px solid #ddd;
            overflow: hidden;
            background-color: white;
        }

        .dual_curves-area {
            display: flex;
            flex-direction: column;
        }
        
        .dual_curve-container {
            position: relative;
            width: 100%;
            padding-bottom: 40%;
            border: 1px solid #ddd;
            background-color: white;
        }

        #dual_canvas, #dual_rocCanvas, #dual_prCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .dual_quadrant-label {
            position: absolute;
            white-space: nowrap;
            font-size: 17px;
            text-align: center;
            color: #fff;
            background-color: rgba(0, 0, 0, 1);
            padding: 1px 5px;
            border-radius: 10px;
            z-index: 10;
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        .dual_curve-title {
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .dual_instructions {
            background-color: #e9f5ff;
            border: 1px solid #b8daff;
            border-radius: 5px;
            padding: 10px;
            margin-top: 15px;
            font-size: 14px;
        }
        
        .dual_axis-container {
            display: flex;
            align-items: stretch;
            position: relative;
            margin-bottom: 5px;
        }
        
        .dual_y-axis-label {
            width: 30px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            margin-right: 5px;
            text-align: center;
        }
        
        .dual_y-axis-label span {
            transform: rotate(-90deg);
            white-space: nowrap;
            display: block;
            width: 40px;
            font-size: 18px;
            position: absolute;
            left: -10px;
        }
        
        .dual_graph-container {
            flex-grow: 1;
            position: relative;
        }
        
        .dual_tick-label {
            position: absolute;
            font-size: 18px;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .dual_flex-container {
                flex-direction: column;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&#34;dual_simulation-container&#34;&gt;
        &lt;div class=&#34;dual_flex-container&#34;&gt;
            &lt;!-- Left Side - Visualization --&gt;
            &lt;div class=&#34;dual_side&#34;&gt;
                &lt;!-- Slider for Positive Class Ratio --&gt;
                &lt;div class=&#34;dual_slider-container&#34;&gt;
                    &lt;label for=&#34;dual_positiveRatio&#34;&gt;Classe positiva:&lt;/label&gt;
                    &lt;div class=&#34;dual_range-slider&#34;&gt;
                        &lt;div class=&#34;dual_range-slider-track&#34;&gt;
                            &lt;div class=&#34;dual_range-slider-fill&#34; id=&#34;dual_positiveRatioFill&#34;&gt;&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;input type=&#34;range&#34; id=&#34;dual_positiveRatio&#34; min=&#34;1&#34; max=&#34;50&#34; value=&#34;1&#34; step=&#34;1&#34;&gt;
                    &lt;/div&gt;
                    &lt;div class=&#34;dual_value-display&#34; id=&#34;dual_positiveRatioValue&#34;&gt;1%&lt;/div&gt;
                &lt;/div&gt;
                
                &lt;!-- Visualization Area --&gt;
                &lt;div class=&#34;dual_canvas-container&#34;&gt;
                    &lt;canvas id=&#34;dual_canvas&#34;&gt;&lt;/canvas&gt;
                    &lt;div id=&#34;dual_quadrant0&#34; class=&#34;dual_quadrant-label&#34;&gt;False&lt;br&gt;Positives&lt;/div&gt;
                    &lt;div id=&#34;dual_quadrant1&#34; class=&#34;dual_quadrant-label&#34;&gt;True&lt;br&gt;Positives&lt;/div&gt;
                    &lt;div id=&#34;dual_quadrant2&#34; class=&#34;dual_quadrant-label&#34;&gt;True&lt;br&gt;Negatives&lt;/div&gt;
                    &lt;div id=&#34;dual_quadrant3&#34; class=&#34;dual_quadrant-label&#34;&gt;False&lt;br&gt;Negatives&lt;/div&gt;
                &lt;/div&gt;
                
                &lt;div style=&#34;display: flex; justify-content: space-between; width: 100%; font-weight: bold; margin-top: 5px;&#34;&gt;
                    &lt;span id=&#34;dual_negativeLabel&#34;&gt;Negatives (99%)&lt;/span&gt;
                    &lt;span id=&#34;dual_positiveLabel&#34;&gt;Positives (1%)&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;!-- Right side - ROC and PR Curves --&gt;
            &lt;div class=&#34;dual_side&#34;&gt;
                &lt;!-- Slider for Circle Size --&gt;
                &lt;div class=&#34;dual_slider-container&#34;&gt;
                    &lt;label for=&#34;dual_circleSize&#34;&gt;Tamanho do círculo&lt;/label&gt;
                    &lt;div class=&#34;dual_range-slider&#34;&gt;
                        &lt;div class=&#34;dual_range-slider-track&#34;&gt;
                            &lt;div class=&#34;dual_range-slider-fill&#34; id=&#34;dual_circleSizeFill&#34;&gt;&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;input type=&#34;range&#34; id=&#34;dual_circleSize&#34; min=&#34;0&#34; max=&#34;100&#34; value=&#34;0&#34; step=&#34;1&#34;&gt;
                    &lt;/div&gt;
                    &lt;div class=&#34;dual_value-display&#34; id=&#34;dual_circleSizeValue&#34;&gt;0&lt;/div&gt;
                &lt;/div&gt;
                
                &lt;!-- Curves Area --&gt;
                &lt;div class=&#34;dual_curves-area&#34;&gt;
                    &lt;!-- ROC Curve --&gt;
                    &lt;div&gt;
                        &lt;div class=&#34;dual_curve-title&#34;&gt;ROC Curve&lt;/div&gt;
                        &lt;div class=&#34;dual_axis-container&#34;&gt;
                            &lt;div class=&#34;dual_y-axis-label&#34;&gt;
                                &lt;span&gt;TPR&lt;/span&gt;
                            &lt;/div&gt;
                            &lt;div class=&#34;dual_graph-container&#34;&gt;
                                &lt;div class=&#34;dual_curve-container&#34;&gt;
                                    &lt;canvas id=&#34;dual_rocCanvas&#34;&gt;&lt;/canvas&gt;
                                    &lt;!-- Fixed tick labels positioned over canvas --&gt;
                                    &lt;div class=&#34;dual_tick-label&#34; style=&#34;left: -30px; top: 0;&#34;&gt;1.0&lt;/div&gt;
                                    &lt;div class=&#34;dual_tick-label&#34; style=&#34;bottom: -30px; left: 0;&#34;&gt;0.0&lt;/div&gt;
                                    &lt;div class=&#34;dual_tick-label&#34; style=&#34;bottom: -30px; right: 0;&#34;&gt;1.0&lt;/div&gt;
                                &lt;/div&gt;
                                
                                &lt;!-- X-axis label --&gt;
                                &lt;div style=&#34;text-align: center; font-weight: bold; margin: 20px 0 10px 0;&#34;&gt;
                                    FPR
                                &lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    
                    &lt;!-- PR Curve --&gt;
                    &lt;div&gt;
                        &lt;div class=&#34;dual_curve-title&#34;&gt;Precision-Recall Curve&lt;/div&gt;
                        &lt;div class=&#34;dual_axis-container&#34;&gt;
                            &lt;div class=&#34;dual_y-axis-label&#34;&gt;
                                &lt;span&gt;Precision&lt;/span&gt;
                            &lt;/div&gt;
                            &lt;div class=&#34;dual_graph-container&#34;&gt;
                                &lt;div class=&#34;dual_curve-container&#34;&gt;
                                    &lt;canvas id=&#34;dual_prCanvas&#34;&gt;&lt;/canvas&gt;
                                    &lt;!-- Fixed tick labels positioned over canvas --&gt;
                                    &lt;div class=&#34;dual_tick-label&#34; style=&#34;left: -30px; top: 0;&#34;&gt;1.0&lt;/div&gt;
                                    &lt;div class=&#34;dual_tick-label&#34; style=&#34;bottom: -30px; left: 0;&#34;&gt;0.0&lt;/div&gt;
                                    &lt;div class=&#34;dual_tick-label&#34; style=&#34;bottom: -30px; right: 0;&#34;&gt;1.0&lt;/div&gt;
                                &lt;/div&gt;
                                
                                &lt;!-- X-axis label --&gt;
                                &lt;div style=&#34;text-align: center; font-weight: bold; margin: 20px 0 10px 0;&#34;&gt;
                                    Recall
                                &lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
        
    &lt;script&gt;
        // Wait for all resources to load
        window.addEventListener(&#39;load&#39;, function() {
            // Initialize simulation
            dual_init();
        });
        
        function dual_init() {
            // DOM Elements
            const dual_canvas = document.getElementById(&#39;dual_canvas&#39;);
            const dual_ctx = dual_canvas.getContext(&#39;2d&#39;);
            const dual_rocCanvas = document.getElementById(&#39;dual_rocCanvas&#39;);
            const dual_rocCtx = dual_rocCanvas.getContext(&#39;2d&#39;);
            const dual_prCanvas = document.getElementById(&#39;dual_prCanvas&#39;);
            const dual_prCtx = dual_prCanvas.getContext(&#39;2d&#39;);
            const dual_circleSizeSlider = document.getElementById(&#39;dual_circleSize&#39;);
            const dual_circleSizeFill = document.getElementById(&#39;dual_circleSizeFill&#39;);
            const dual_circleSizeValue = document.getElementById(&#39;dual_circleSizeValue&#39;);
            const dual_positiveRatioSlider = document.getElementById(&#39;dual_positiveRatio&#39;);
            const dual_positiveRatioFill = document.getElementById(&#39;dual_positiveRatioFill&#39;);
            const dual_positiveRatioValue = document.getElementById(&#39;dual_positiveRatioValue&#39;);
            const dual_positiveLabel = document.getElementById(&#39;dual_positiveLabel&#39;);
            const dual_negativeLabel = document.getElementById(&#39;dual_negativeLabel&#39;);
        
            // Quadrant labels
            const dual_quadrantLabels = [
                document.getElementById(&#39;dual_quadrant0&#39;),
                document.getElementById(&#39;dual_quadrant1&#39;),
                document.getElementById(&#39;dual_quadrant2&#39;),
                document.getElementById(&#39;dual_quadrant3&#39;)
            ];
            
            // Variables
            let dual_truePositives = 0;
            let dual_falsePositives = 0;
            let dual_trueNegatives = 0;
            let dual_falseNegatives = 0;
            let dual_totalPoints = 0;
            let dual_points = [];
            let dual_rocPoints = [];
            let dual_prPoints = [];
            let dual_currentSize = 0; // Track current circle size
            let dual_positiveClassRatio = 0.01; // Starting point: 1%
            
            // Set extra space above y=1 for visibility (expressed as a fraction of canvas height)
            const dual_extraSpace = 0.05; // 5% extra space above y=1.0
            
            // Circle properties - fixed center at 0.65, 0.5
            let dual_circleRadius;
            let dual_centerX;
            let dual_centerY;
            let dual_circleCenter = { x: 0.65, y: 0.5 }; // Fixed position
            let dual_circleSizePercent = 0; // Percentage of min dimension
            
            // Update positive ratio slider fill and label
            function dual_updatePositiveRatioSlider() {
                const percent = (dual_positiveRatioSlider.value - dual_positiveRatioSlider.min) / 
                                (dual_positiveRatioSlider.max - dual_positiveRatioSlider.min) * 100;
                dual_positiveRatioFill.style.width = percent + &#39;%&#39;;
                
                // Update the display value
                const ratioValue = parseInt(dual_positiveRatioSlider.value);
                dual_positiveRatioValue.textContent = ratioValue + &#39;%&#39;;
                
                // Convert to decimal
                dual_positiveClassRatio = ratioValue / 100;
                
                // Update dataset info text and labels
                dual_positiveLabel.textContent = `Positives (${ratioValue}%)`;
                dual_negativeLabel.textContent = `Negatives (${100-ratioValue}%)`;
            }
            
            // Update circle size slider fill and value
            function dual_updateCircleSizeSlider() {
                const percent = (dual_circleSizeSlider.value - dual_circleSizeSlider.min) / 
                               (dual_circleSizeSlider.max - dual_circleSizeSlider.min) * 100;
                dual_circleSizeFill.style.width = percent;
                dual_circleSizeValue.textContent = dual_circleSizeSlider.value;
            }
            
            // Initial slider fill updates
            dual_updateCircleSizeSlider();
            dual_updatePositiveRatioSlider();
            
            // Setup slider events
            function dual_setupSliderEvents() {
                // Circle size slider
                dual_circleSizeSlider.addEventListener(&#39;input&#39;, function() {
                    // Store previous and current size for curve updating
                    const prevSize = dual_circleSizePercent;
                    dual_circleSizePercent = parseInt(this.value);
                    dual_currentSize = dual_circleSizePercent;
                    
                    dual_updateCircleSizeSlider();
                    dual_calculateDimensions();
                    dual_redrawCanvas();
                    dual_recalculateMetrics();
                    dual_updateQuadrantLabels();
                    
                    // Update curve points based on whether size increased or decreased
                    if (dual_circleSizePercent &gt; prevSize) {
                        dual_addCurvePoints();
                    } else if (dual_circleSizePercent &lt; prevSize) {
                        dual_removeCurvePointsAboveSize(dual_circleSizePercent);
                    }
                    
                    dual_drawROCCurve();
                    dual_drawPRCurve();
                });
                
                // Positive class ratio slider
                dual_positiveRatioSlider.addEventListener(&#39;input&#39;, function() {
                    dual_updatePositiveRatioSlider();
                    
                    // Clear previous points and regenerate with new ratio
                    dual_generatePoints(10000);
                    
                    // Reset curves for the new distribution
                    dual_rocPoints = [];
                    dual_prPoints = [];
                    dual_addCurvePoints();
                    
                    // Redraw everything
                    dual_redrawCanvas();
                    dual_drawROCCurve();
                    dual_drawPRCurve();
                    dual_updateQuadrantLabels();
                });
            }
            
            // Resize canvas to fit container
            function dual_resizeCanvas() {
                const container = dual_canvas.parentElement;
                dual_canvas.width = container.clientWidth;
                dual_canvas.height = container.clientHeight;
                
                const rocContainer = dual_rocCanvas.parentElement;
                dual_rocCanvas.width = rocContainer.clientWidth;
                dual_rocCanvas.height = rocContainer.clientHeight;
                
                const prContainer = dual_prCanvas.parentElement;
                dual_prCanvas.width = prContainer.clientWidth;
                dual_prCanvas.height = prContainer.clientHeight;
                
                dual_calculateDimensions();
                dual_redrawCanvas();
                dual_drawROCCurve();
                dual_drawPRCurve();
                dual_updateQuadrantLabels();
            }
            
            // Calculate circle dimensions based on canvas size and current settings
            function dual_calculateDimensions() {
                // Fixed center position (no dragging)
                dual_centerX = dual_canvas.width * dual_circleCenter.x;
                dual_centerY = dual_canvas.height * dual_circleCenter.y;
                const minDimension = Math.min(dual_canvas.width, dual_canvas.height);
                dual_circleRadius = minDimension * (dual_circleSizePercent / 100);
            }
            
            // Generate points with adjustable positive class ratio
            function dual_generatePoints(count) {
                dual_points = [];
                
                // Calculate number of points for each class
                const positiveCount = Math.round(count * dual_positiveClassRatio);
                const negativeCount = count - positiveCount;
                
                // Generate negative points (left side)
                for (let i = 0; i &lt; negativeCount; i++) {
                    dual_points.push({
                        x: Math.random() * (dual_canvas.width / 2 - 5),
                        y: Math.random() * dual_canvas.height
                    });
                }
                
                // Generate positive points (right side)
                for (let i = 0; i &lt; positiveCount; i++) {
                    dual_points.push({
                        x: (dual_canvas.width / 2 + 5) + Math.random() * (dual_canvas.width / 2 - 10),
                        y: Math.random() * dual_canvas.height
                    });
                }
                
                dual_recalculateMetrics();
            }
            
            // Update the class metrics based on the points
            function dual_recalculateMetrics() {
                // Reset counts
                dual_truePositives = 0;
                dual_falsePositives = 0;
                dual_trueNegatives = 0;
                dual_falseNegatives = 0;
                
                // Recalculate counts for each point
                dual_points.forEach(point =&gt; {
                    const isRight = point.x &gt;= dual_canvas.width / 2;
                    const isPredictedPositive = dual_isInsideCircle(point.x, point.y);
                    
                    if (isRight &amp;&amp; isPredictedPositive) dual_truePositives++;
                    else if (!isRight &amp;&amp; isPredictedPositive) dual_falsePositives++;
                    else if (!isRight &amp;&amp; !isPredictedPositive) dual_trueNegatives++;
                    else if (isRight &amp;&amp; !isPredictedPositive) dual_falseNegatives++;
                });
                
                dual_totalPoints = dual_points.length;
            }
            
            // Draw all points
            function dual_drawPoints() {
                dual_points.forEach(point =&gt; {
                    const isRight = point.x &gt;= dual_canvas.width / 2;
                    
                    // Choose color based on actual class (left/right side)
                    if (isRight) {
                        dual_ctx.fillStyle = &#39;blue&#39;; // Actual Positive (right side)
                    } else {
                        dual_ctx.fillStyle = &#39;red&#39;; // Actual Negative (left side)
                    }
                    
                    dual_ctx.beginPath();
                    dual_ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                    dual_ctx.fill();
                });
            }
            
            // Redraw canvas with all points and current circle position
            function dual_redrawCanvas() {
                dual_ctx.clearRect(0, 0, dual_canvas.width, dual_canvas.height);
                
                // Draw points
                dual_drawPoints();
                
                // Draw dividing line
                dual_ctx.beginPath();
                dual_ctx.moveTo(dual_canvas.width / 2, 0);
                dual_ctx.lineTo(dual_canvas.width / 2, dual_canvas.height);
                dual_ctx.strokeStyle = &#39;black&#39;;
                dual_ctx.lineWidth = 2;
                dual_ctx.stroke();
                
                // Draw circle
                dual_ctx.beginPath();
                dual_ctx.arc(dual_centerX, dual_centerY, dual_circleRadius, 0, Math.PI * 2);
                dual_ctx.fillStyle = &#39;rgba(0, 0, 255, 0.15)&#39;;
                dual_ctx.fill();
                dual_ctx.strokeStyle = &#39;black&#39;;
                dual_ctx.lineWidth = 3;
                dual_ctx.stroke();
                
                // Draw border
                dual_ctx.strokeStyle = &#39;#ddd&#39;;
                dual_ctx.lineWidth = 1;
                dual_ctx.strokeRect(0, 0, dual_canvas.width, dual_canvas.height);
            }
            
            // Draw the ROC curve with corrected y-coordinate calculation
            function dual_drawROCCurve() {
                dual_rocCtx.clearRect(0, 0, dual_rocCanvas.width, dual_rocCanvas.height);
                
                // Calculate the actual data area height (reduced to make room for the extra space)
                const dataAreaHeight = dual_rocCanvas.height / (1 + dual_extraSpace);
                
                // Draw axes
                dual_rocCtx.beginPath();
                // Y-axis (left)
                dual_rocCtx.moveTo(0, dual_rocCanvas.height);
                dual_rocCtx.lineTo(0, 0);
                // X-axis (bottom)
                dual_rocCtx.moveTo(0, dual_rocCanvas.height);
                dual_rocCtx.lineTo(dual_rocCanvas.width, dual_rocCanvas.height);
                dual_rocCtx.stroke();

                // Draw reference line (random classifier)
                dual_rocCtx.beginPath();
                dual_rocCtx.moveTo(0, dual_rocCanvas.height); // (0,0) in canvas coordinates
                dual_rocCtx.lineTo(dual_rocCanvas.width, dual_rocCanvas.height - dataAreaHeight); // (1,1) in canvas coordinates
                dual_rocCtx.strokeStyle = &#39;gray&#39;;
                dual_rocCtx.lineWidth = 1;
                dual_rocCtx.setLineDash([5, 5]);
                dual_rocCtx.stroke();
                dual_rocCtx.setLineDash([]);
                
                // Draw ROC curve points if we have any
                if (dual_rocPoints.length &gt; 0) {
                    // Only draw line if there are multiple points
                    if (dual_rocPoints.length &gt; 1) {
                        // Draw the curve connecting the points
                        dual_rocCtx.beginPath();
                        dual_rocCtx.moveTo(0, dual_rocCanvas.height); // Start at origin (0,0)
                        
                        // Sort points to ensure proper curve
                        const sortedPoints = [...dual_rocPoints].sort((a, b) =&gt; a.fpr - b.fpr);
                        
                        sortedPoints.forEach(point =&gt; {
                            const x = point.fpr * dual_rocCanvas.width;
                            // Corrected y-coordinate calculation
                            const y = dual_rocCanvas.height - (point.tpr * dataAreaHeight);
                            dual_rocCtx.lineTo(x, y);
                        });
                        
                        dual_rocCtx.strokeStyle = &#39;blue&#39;;
                        dual_rocCtx.lineWidth = 2;
                        dual_rocCtx.stroke();
                        
                        // Draw points
                        sortedPoints.forEach(point =&gt; {
                            const x = point.fpr * dual_rocCanvas.width;
                            // Corrected y-coordinate calculation
                            const y = dual_rocCanvas.height - (point.tpr * dataAreaHeight);
                            
                            dual_rocCtx.beginPath();
                            dual_rocCtx.arc(x, y, 3, 0, Math.PI * 2);
                            dual_rocCtx.fillStyle = &#39;blue&#39;;
                            dual_rocCtx.fill();
                        });
                    }
                    
                    // Draw current operating point
                    const tpr = dual_truePositives / (dual_truePositives + dual_falseNegatives) || 0;
                    const fpr = dual_falsePositives / (dual_falsePositives + dual_trueNegatives) || 0;
                    
                    const currentX = fpr * dual_rocCanvas.width;
                    // Corrected y-coordinate calculation
                    const currentY = dual_rocCanvas.height - (tpr * dataAreaHeight);
                    
                    dual_rocCtx.beginPath();
                    dual_rocCtx.arc(currentX, currentY, 6, 0, Math.PI * 2);
                    dual_rocCtx.fillStyle = &#39;red&#39;;
                    dual_rocCtx.fill();
                    dual_rocCtx.strokeStyle = &#39;black&#39;;
                    dual_rocCtx.lineWidth = 1;
                    dual_rocCtx.stroke();
                }
            }
            
            // Draw the PR curve with corrected y-coordinate calculation
            function dual_drawPRCurve() {
                dual_prCtx.clearRect(0, 0, dual_prCanvas.width, dual_prCanvas.height);
                
                // Calculate the actual data area height (reduced to make room for the extra space)
                const dataAreaHeight = dual_prCanvas.height / (1 + dual_extraSpace);
                
                // Draw axes
                dual_prCtx.beginPath();
                // Y-axis (left)
                dual_prCtx.moveTo(0, dual_prCanvas.height);
                dual_prCtx.lineTo(0, 0);
                // X-axis (bottom)
                dual_prCtx.moveTo(0, dual_prCanvas.height);
                dual_prCtx.lineTo(dual_prCanvas.width, dual_prCanvas.height);
                dual_prCtx.stroke();
                
                // Baseline removed as requested
                
                // Draw PR curve points if we have any
                if (dual_prPoints.length &gt; 0) {
                    // Only draw line if there are multiple points
                    if (dual_prPoints.length &gt; 1) {
                        // Draw the curve connecting the points
                        dual_prCtx.beginPath();
                        
                        // Sort points to ensure proper curve - for PR curve, we sort by recall (x-axis)
                        const sortedPoints = [...dual_prPoints].sort((a, b) =&gt; a.recall - b.recall);
                        
                        // Start point - unlike ROC, PR curves don&#39;t start at origin
                        const firstPoint = sortedPoints[0];
                        const firstX = firstPoint.recall * dual_prCanvas.width;
                        // Corrected y-coordinate calculation
                        const firstY = dual_prCanvas.height - (firstPoint.precision * dataAreaHeight);
                        dual_prCtx.moveTo(firstX, firstY);
                        
                        // Connect the rest of the points
                        for (let i = 1; i &lt; sortedPoints.length; i++) {
                            const point = sortedPoints[i];
                            const x = point.recall * dual_prCanvas.width;
                            // Corrected y-coordinate calculation
                            const y = dual_prCanvas.height - (point.precision * dataAreaHeight);
                            dual_prCtx.lineTo(x, y);
                        }
                        
                        dual_prCtx.strokeStyle = &#39;green&#39;;
                        dual_prCtx.lineWidth = 2;
                        dual_prCtx.stroke();
                        
                        // Draw points
                        sortedPoints.forEach(point =&gt; {
                            const x = point.recall * dual_prCanvas.width;
                            // Corrected y-coordinate calculation
                            const y = dual_prCanvas.height - (point.precision * dataAreaHeight);
                            
                            dual_prCtx.beginPath();
                            dual_prCtx.arc(x, y, 3, 0, Math.PI * 2);
                            dual_prCtx.fillStyle = &#39;green&#39;;
                            dual_prCtx.fill();
                        });
                    }
                    
                    // Draw current operating point
                    const precision = dual_truePositives / (dual_truePositives + dual_falsePositives) || 0;
                    const recall = dual_truePositives / (dual_truePositives + dual_falseNegatives) || 0;
                    
                    const currentX = recall * dual_prCanvas.width;
                    // Corrected y-coordinate calculation
                    const currentY = dual_prCanvas.height - (precision * dataAreaHeight);
                    
                    dual_prCtx.beginPath();
                    dual_prCtx.arc(currentX, currentY, 6, 0, Math.PI * 2);
                    dual_prCtx.fillStyle = &#39;red&#39;;
                    dual_prCtx.fill();
                    dual_prCtx.strokeStyle = &#39;black&#39;;
                    dual_prCtx.lineWidth = 1;
                    dual_prCtx.stroke();
                }
            }
            
            // Add new curve points for current size
            function dual_addCurvePoints() {
                const tpr = dual_truePositives / (dual_truePositives + dual_falseNegatives) || 0;
                const fpr = dual_falsePositives / (dual_falsePositives + dual_trueNegatives) || 0;
                const precision = dual_truePositives / (dual_truePositives + dual_falsePositives) || 0;
                const recall = tpr; // Recall is the same as TPR
                
                // Check if we already have points with the exact same size
                const existingRocPoint = dual_rocPoints.find(p =&gt; p.size === dual_circleSizePercent);
                const existingPrPoint = dual_prPoints.find(p =&gt; p.size === dual_circleSizePercent);
                
                // Update ROC point
                if (existingRocPoint) {
                    existingRocPoint.tpr = tpr;
                    existingRocPoint.fpr = fpr;
                } else {
                    dual_rocPoints.push({
                        tpr,
                        fpr,
                        size: dual_circleSizePercent
                    });
                }
                
                // Update PR point
                if (existingPrPoint) {
                    existingPrPoint.precision = precision;
                    existingPrPoint.recall = recall;
                } else {
                    dual_prPoints.push({
                        precision,
                        recall,
                        size: dual_circleSizePercent
                    });
                }
                
                // Sort points by size
                dual_rocPoints.sort((a, b) =&gt; a.size - b.size);
                dual_prPoints.sort((a, b) =&gt; a.size - b.size);
            }
            
            // Remove curve points above a certain size
            function dual_removeCurvePointsAboveSize(size) {
                dual_rocPoints = dual_rocPoints.filter(point =&gt; point.size &lt;= size);
                dual_prPoints = dual_prPoints.filter(point =&gt; point.size &lt;= size);
            }
            
            // Update quadrant labels dynamically based on circle position
            function dual_updateQuadrantLabels() {
                // Get vertical dividing line position
                const midX = dual_canvas.width / 2;
                
                // Check if circle overlaps with left or right half
                const leftEdge = dual_centerX - dual_circleRadius;
                const rightEdge = dual_centerX + dual_circleRadius;
                const topEdge = dual_centerY - dual_circleRadius;
                const bottomEdge = dual_centerY + dual_circleRadius;
                const overlapsLeft = leftEdge &lt; midX;
                const overlapsRight = rightEdge &gt; midX;
                
                // Padding to ensure labels stay within canvas
                const padding = 20;
                const labelWidth = 70;
                const labelHeight = 40;
                
                // 1. False Positives (inside circle, left side)
                if (overlapsLeft &amp;&amp; dual_falsePositives &gt; 0) {
                    const fpX = Math.max(padding, Math.min(midX - labelWidth - padding, dual_centerX - dual_circleRadius / 2));
                    const fpY = dual_centerY;
                    dual_quadrantLabels[0].style.display = &#39;block&#39;;
                    dual_quadrantLabels[0].style.left = fpX + &#39;px&#39;;
                    dual_quadrantLabels[0].style.top = fpY + &#39;px&#39;;
                } else {
                    dual_quadrantLabels[0].style.display = &#39;none&#39;;
                }
                
                // 2. True Positives (inside circle, right side)
                if (overlapsRight &amp;&amp; dual_truePositives &gt; 0) {
                    const tpX = Math.min(dual_canvas.width - labelWidth - padding, Math.max(midX + padding, dual_centerX + dual_circleRadius / 3));
                    const tpY = dual_centerY;
                    dual_quadrantLabels[1].style.display = &#39;block&#39;;
                    dual_quadrantLabels[1].style.left = tpX + &#39;px&#39;;
                    dual_quadrantLabels[1].style.top = tpY + &#39;px&#39;;
                } else {
                    dual_quadrantLabels[1].style.display = &#39;none&#39;;
                }
                
                // 3. True Negatives (outside circle, left side)
                // Only show if there&#39;s sufficient space between the circle and the edge
                const safeDistanceFromCircle = 5; // Minimum distance needed
                const distanceLeftEdge = leftEdge;
                
                if (dual_trueNegatives &gt; 0 &amp;&amp; distanceLeftEdge &gt; safeDistanceFromCircle) {
                    const tnX = padding;
                    const tnY = padding;
                    dual_quadrantLabels[2].style.display = &#39;block&#39;;
                    dual_quadrantLabels[2].style.left = tnX + &#39;px&#39;;
                    dual_quadrantLabels[2].style.top = tnY + &#39;px&#39;;
                } else {
                    // Hide when circle gets too close
                    dual_quadrantLabels[2].style.display = &#39;none&#39;;
                }
                
                // 4. False Negatives (outside circle, right side)
                // Only show if there&#39;s sufficient space between the circle and right edge
                const distanceRightEdge = dual_canvas.width - rightEdge;
                
                if (dual_falseNegatives &gt; 0 &amp;&amp; distanceRightEdge &gt; safeDistanceFromCircle) {
                    const fnX = dual_canvas.width - labelWidth - padding;
                    const fnY = padding;
                    dual_quadrantLabels[3].style.display = &#39;block&#39;;
                    dual_quadrantLabels[3].style.left = fnX + &#39;px&#39;;
                    dual_quadrantLabels[3].style.top = fnY + &#39;px&#39;;
                } else {
                    // Hide when circle gets too close
                    dual_quadrantLabels[3].style.display = &#39;none&#39;;
                }
            }
            
            // Check if a point is inside the circle
            function dual_isInsideCircle(x, y) {
                const dx = x - dual_centerX;
                const dy = y - dual_centerY;
                return (dx * dx + dy * dy) &lt;= (dual_circleRadius * dual_circleRadius);
            }
            
            // Initialize the first curve points for the starting size
            function dual_initCurvePoints() {
                dual_rocPoints = [];
                dual_prPoints = [];
                dual_addCurvePoints();
            }
            
            // Set canvas dimensions
            dual_resizeCanvas();
            
            // Setup slider events
            dual_setupSliderEvents();
            
            // Generate points with imbalanced distribution
            dual_generatePoints(10000);
            
            // Initial calculations and rendering
            dual_calculateDimensions();
            dual_recalculateMetrics();
            dual_redrawCanvas();
            dual_updateQuadrantLabels();
            
            // Initialize the curve points for current size
            dual_initCurvePoints();
            
            // Draw curves
            dual_drawROCCurve();
            dual_drawPRCurve();
            
            // Handle window resize
            window.addEventListener(&#39;resize&#39;, function() {
                dual_resizeCanvas();
                dual_redrawCanvas();
                dual_drawROCCurve();
                dual_drawPRCurve();
                dual_updateQuadrantLabels();
            });
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;p&gt;Repare que, com apenas 1% de exemplos positivos, aumentar o tamanho do círculo faz com que a curva PR sofra uma queda acentuada na precisão — já que o número de falsos positivos aumenta muito mais do que o de verdadeiros positivos. Esse efeito, porém, não é capturado pela curva ROC, que permanece praticamente inalterada.&lt;/p&gt;
&lt;br&gt;
&lt;div style=&#34;display: flex; align-items: center;&#34;&gt;
&lt;div style=&#34;flex: 1; padding-right: 20px;&#34;&gt;
&lt;p&gt;Outro efeito interessante pode ser observado com a seguinte configuração: defina o tamanho do círculo em 40 e varie a porcentagem da classe positiva de 1% até 100%, e depois retorne a 1%. Você notará que o ponto correspondente na curva ROC praticamente não se move — a taxa de falsos positivos (FPR) permanece quase constante. Por outro lado, na curva PR, a precisão cai drasticamente à medida que a proporção de positivos se torna menor.&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&#34;flex: 1;&#34;&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/JCMaZmj5tks&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Em geral, com precisão e recall estamos mais focados na classe minoritária (positiva, nesse caso), o que torna essas métricas mais informativas para dados desbalanceados. Um falso positivo não tem muito peso na curva ROC se temos muitos exemplos negativos. Porém, o mesmo falso positivo terá um impacto maior na curva PR porque FP está no denominador da precisão.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Um modelo ideal seria representado por um retângulo idêntico ao lado direito, posicionado exatamente sobre ele.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Os dois tipos de erros possuem nomes conhecidos. Falsos positivos (FP) são erros tipo I e falsos negativos (FN) são erros tipo II.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Nas simulações desta postagem, os pontos estão distribuídos uniformemente no plano. Essa escolha tem fins didáticos, pois facilita a explicação dos conceitos. No entanto, vale lembrar que, na vida real, os dados não necessariamente seguem essa distribuição.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;A abordagem dessa postagem se aplica a casos binários (por exemplo, positivo/negativo). Para problemas multiclasse, teríamos uma curva ROC para cada classe (one-vs-all).&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Quanto mais próxima a curva ROC estiver do canto superior esquerdo, melhor é o desempenho do modelo. Para quantificar o desempenho, calculamos a área sob a curva (AUC), que representa a performance geral do modelo: AUC = 1,0: modelo perfeito. AUC = 0,5: modelo aleatório (sem poder preditivo). AUC &amp;lt; 0,5: pior que aleatório (inverta suas previsões).&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Unveiling the hidden patterns of corruption networks</title>
      <link>https://alvarofrancomartins.com/post/corruption-networks/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      <guid>https://alvarofrancomartins.com/post/corruption-networks/</guid>
      <description>&lt;p&gt;Political corruption is an inherent problem in our societies. Corrupt behavior is a multifaceted phenomenon responsible for a variety of socioeconomic limitations. In general, isolated agents engaged in criminal acts rarely pose a major threat to society. However, this scenario changes completely when we consider, for example, multiple corruption scandals.&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;Although the people involved in corruption obviously want to keep it in secrecy, they do not operate without leaving traces. A natural approach to consider this collective behavior can be taken from a combination of scientific fields, such as network science, complexity science, and data science.&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;Criminal networks are not simply social networks operating in criminal contexts. The interactions within these systems go beyond social norms and are often shaped by trade-offs between concealment and efficiency. Political corruption networks represent an additional layer of complexity. Frequently involving high ranking individuals, a great deal of polarization and many controversies, political corruption weakens democracy, damages political stability and spreads mistrust in the rule of law.&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;In our recent paper &lt;a href=&#34;https://www.nature.com/articles/s41598-022-10909-2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Universality of political corruption networks&lt;/a&gt;, we used publicly available data from Brazil and Spain to reveal the underlying patterns of political corruption networks. Our work has revealed fascinating statistical similarities in the growth of these networks. This work include many results I obtained during my master&amp;rsquo;s degree and ongoing PhD. Here I summarize our main findings:&lt;/p&gt;
&lt;br&gt;
&lt;ol&gt;
&lt;li&gt;We have found that, in both countries, the size of corruption scandals is approximately exponentially distributed. These distributions have, on average, roughly 7 people per scandal. Therefore, people tend to act in small groups when they are involved in corruption processes.&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
    &lt;img src=&#34;figs/fig1.png&#34; width=&#34;730px&#34; height=&#34;443px&#34; /&gt;
    &lt;figcaption&gt;Figure 1: Complementary cumulative distribution of scandals sizes in (A) Spain and (B) Brazil.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;The networks consist of nodes representing people listed in the scandals and links indicating that two people were involved in the same corruption scandal. These networks share surprising features, such as high clustering coefficients, moderately high assortativity coefficients, and low average shortest path length.&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
    &lt;img src=&#34;figs/fig2.png&#34; width=&#34;800px&#34; height=&#34;443px&#34; /&gt;
    &lt;figcaption&gt;Figure 2: (A) Spanish and (B) Brazilian political corruption networks.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;The networks&#39; degree distributions are well approximated by exponential distributions. Moreover, the characteristic degrees evolved to a similar plateau, roughly with the same average number of connections.&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
    &lt;img src=&#34;figs/fig3.png&#34; width=&#34;730px&#34; height=&#34;443px&#34; /&gt;
    &lt;figcaption&gt;Figure 3: Changes in the characteristic degree over the years for (A) Spanish and (B) Brazilian corruption networks. The insets show the cumulative distributions of the vertex degree (on a log-linear scale) for the last year of the networks.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;The networks present community structures where the number of modules is linearly associated with the total number of scandals.&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
    &lt;img src=&#34;figs/figa.png&#34; width=&#34;730px&#34; height=&#34;443px&#34; /&gt;
    &lt;figcaption&gt;Figure 4: (A) Spanish and (B) Brazilian number of modules versus number of scandals.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;The time evolution of the networks are characterized by abrupt changes in the size of the largest connected component, which is due to the coalescence (or connection) of different network components. This process is caused by recidivists (&lt;em&gt;i.e.&lt;/em&gt;, individuals involved in at least two scandals).&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
    &lt;img src=&#34;figs/fig5.png&#34; width=&#34;830px&#34; height=&#34;443px&#34; /&gt;
    &lt;figcaption&gt;Figure 5: Coalescence processes observed in both political corruption networks.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;The number of recidivists is linearly associated with the total number of people. The recidivism rates (number of repeat offenders / total number of offenders) are 9% in Spain and 14.2% in Brazil.&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
    &lt;img src=&#34;figs/fig6.png&#34; width=&#34;730px&#34; height=&#34;443px&#34; /&gt;
    &lt;figcaption&gt;Figure 7: Linear relationships between the number of repeat offenders and the total number of people.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;Recidivists are vertices that connect different parts of the network, functioning as brokers (they have the highest betweenness centrality values). In this sense, the recidivism rate plays an important role in the evolution, structure, and dynamics of corruption networks.&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
    &lt;img src=&#34;figs/fig7.png&#34; width=&#34;530px&#34; height=&#34;500px&#34; /&gt;
    &lt;figcaption&gt;Figure 7: Spanish political corruption network showing recidivists nodes in red.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;We have proposed a &lt;a href=&#34;https://alvarofrancomartins.com/post/corruption-networks-model/&#34;&gt;computational model&lt;/a&gt; to simulate corruption networks. The model takes into account two results: the recidivists linear pattern and the size distribution of scandals. We can see below that our model generate networks visually similar to the empirical corruption networks.&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
    &lt;img src=&#34;figs/sfig1.png&#34; width=&#34;830px&#34; height=&#34;443px&#34; /&gt;
    &lt;figcaption&gt;Figure 8: (A) Spanish and (B) Brazilian political corruption networks. Model simulations of the empirical networks using (C) Spanish and (D) Brazilian recidivism rates. &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;More importantly, we have verified that the model is capable of simulating networks with features very similar to those observed in the empirical data.&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
    &lt;img src=&#34;figs/sfig5.png&#34; width=&#34;930px&#34; height=&#34;443px&#34; /&gt;
    &lt;figcaption&gt;Figure 9: The model generates realistic networks that are able to reproduce the empirical network properties. The degree distributions of the model networks can be reasonably described by exponential degree distributions. Furthermore, the network simulations present a linear relationship between the number of modules and the number of complete graphs. &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Overall, we have presented a comprehensive investigation of corruption networks related to political scandals in Spain and Brazil over nearly three decades. It is important to remember that these countries have a long history of political corruption and are known worldwide for having huge corruption scandals.&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;Our results show that corruption networks share universal characteristics that are independent of social and cultural differences among countries. Ultimately, this work emphasizes the influence of recidivists on organized crime, indicating its susceptibility to interventions targeting these criminals.&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;I believe that this work significantly improves the understanding of political corruption networks and organized crime. For more details, please do not hesitate to contact me. I would be happy to talk about my work.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
