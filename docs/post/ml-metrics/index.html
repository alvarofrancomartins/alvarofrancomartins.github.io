<!DOCTYPE html><html lang="en-us" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.3.0 for Hugo" />
  

  
  









  




  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Roboto&display&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&display&display=swap" media="print" onload="this.media='all'">
    
  

  
    <meta name="google-site-verification" content="U7jZ7b0hmEF2h3bCJtTey4gPa2RTG1IAj4UtXfCMvdU" />
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Alvaro Franco Martins" />

  
  
  
    
  
  <meta name="description" content="Aprenda de forma visual as principais métricas de classificação por meio de simulações interativas." />

  
  <link rel="alternate" hreflang="en-us" href="https://alvarofrancomartins.com/post/ml-metrics/" />

  
  
  
    <meta name="theme-color" content="#1565c0" />
  

  
  
    
    <script src="/js/mathjax-config.js"></script>
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.f1ecf783c14edc00c9320c205831ad8e.css" media="print" onload="this.media='all'">

  
  
  
    
    

    
    
    
    
      
      
    
    
    

    
    
    
      
    
    

    
    
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.css" integrity="sha512-1xoFisiGdy9nvho8EgXuXvnpR5GAMSjFwp40gSRE3NwdUdIMIKuPa7bqoUhLD0O/5tPNhteAsE5XyyMi5reQVA==" crossorigin="anonymous" media="print" onload="this.media='all'">
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" integrity="" crossorigin="anonymous" async></script>
      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.cc1fa952786c7d5551c3adc1183830fe.css" />

  




<script async src="https://www.googletagmanager.com/gtag/js?id=G-QGS19RLHHY"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
      dataLayer.push(arguments);
  }

  function trackOutboundLink(url, target) {
    gtag('event', 'click', {
         'event_category': 'outbound',
         'event_label': url,
         'transport_type': 'beacon',
         'event_callback': function () {
           if (target !== '_blank') {
             document.location = url;
           }
         }
    });
    console.debug("Outbound link clicked: " + url);
  }

  function onClickCallback(event) {
    if ((event.target.tagName !== 'A') || (event.target.host === window.location.host)) {
      return;
    }
    trackOutboundLink(event.target, event.target.getAttribute('target'));  
  }

  gtag('js', new Date());
  gtag('config', 'G-QGS19RLHHY', {});
  gtag('set', {'cookie_flags': 'SameSite=None;Secure'});

  
  document.addEventListener('click', onClickCallback, false);
</script>


  

  

  




  
  
  

  

  
    <link rel="manifest" href="/manifest.webmanifest" />
  

  <link rel="icon" type="image/png" href="/media/icon_hu2554c39cea7f7ac56f2127a9008220c1_75996_32x32_fill_lanczos_center_3.png" />
  <link rel="apple-touch-icon" type="image/png" href="/media/icon_hu2554c39cea7f7ac56f2127a9008220c1_75996_180x180_fill_lanczos_center_3.png" />

  <link rel="canonical" href="https://alvarofrancomartins.com/post/ml-metrics/" />

  
  
  
  
  
  
  
  
    
  
  

  
  
    
    
  
  <meta property="twitter:card" content="summary_large_image" />
  
    <meta property="twitter:site" content="@alvarofmartins" />
    <meta property="twitter:creator" content="@alvarofmartins" />
  
  <meta property="og:site_name" content="Alvaro Franco Martins" />
  <meta property="og:url" content="https://alvarofrancomartins.com/post/ml-metrics/" />
  <meta property="og:title" content="Sensibilidade, especificidade e curvas ROC: Um guia visual para não se confundir mais! | Alvaro Franco Martins" />
  <meta property="og:description" content="Aprenda de forma visual as principais métricas de classificação por meio de simulações interativas." /><meta property="og:image" content="https://alvarofrancomartins.com/post/ml-metrics/featured.png" />
    <meta property="twitter:image" content="https://alvarofrancomartins.com/post/ml-metrics/featured.png" /><meta property="og:locale" content="en-us" />
  
    
      <meta
        property="article:published_time"
        content="2025-03-23T00:00:00&#43;00:00"
      />
    
    <meta property="article:modified_time" content="2025-03-23T00:00:00&#43;00:00">
  

  


    






  




<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://alvarofrancomartins.com/post/ml-metrics/"
  },
  "headline": "Sensibilidade, especificidade e curvas ROC: Um guia visual para não se confundir mais!",
  
  "image": [
    "https://alvarofrancomartins.com/post/ml-metrics/featured.png"
  ],
  
  "datePublished": "2025-03-23T00:00:00Z",
  "dateModified": "2025-03-23T00:00:00Z",
  
  "author": {
    "@type": "Person",
    "name": "Alvaro Franco Martins"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "Alvaro Franco Martins",
    "logo": {
      "@type": "ImageObject",
      "url": "https://alvarofrancomartins.com/media/icon_hu2554c39cea7f7ac56f2127a9008220c1_75996_192x192_fill_lanczos_center_3.png"
    }
  },
  "description": "Aprenda de forma visual as principais métricas de classificação por meio de simulações interativas."
}
</script>

  

  

  

  <head>
   <style>
   p {
      margin-top: 0;
      margin-bottom: 0rem;
      text-align: justify;
   }

   .article-container {
      max-width: 1250px;
   }

 

   #container-publications {
      overflow: visible !important;
   }

   .see-all {
      text-transform: none !important;
   }

   html {
   scroll-behavior: smooth !important;
   }

   .docs-toc {
      padding-top:  3.2rem;
   }

   figure {
    display: flex;
    flex-flow: column;
}
   .stream-item {
      padding-top: 25px;
   }

figcaption {
   
  font-family: "Roboto", sans-serif;
  font-weight: 500;
  margin-top: 0.5rem !important; 
  margin-bottom: 0rem !important;
  margin-right:  0.5rem !important;
  line-height: 1.25;
  color: inherit;
  text-rendering: optimizeLegibility;
   
  overflow-wrap: break-word; 
  word-wrap: break-word;
  word-break: break-word;
   
  -webkit-hyphens: manual;
  -ms-hyphens: manual;
  hyphens: manual; 
}

div.alert > div {
text-align: justify;

}



   </style>

   <script src="/js/prism.js"></script>

   <link rel="stylesheet" href="/css/prism.css" type="text/css"/> 

</head>

  <title>Sensibilidade, especificidade e curvas ROC: Um guia visual para não se confundir mais! | Alvaro Franco Martins</title>
</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="3227cdf648c7dd9f894f23e141854b36" >

  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.da42964e270e05a6063fbca894d7ccff.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="Close"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="Search...">
        
      </div>

      
      

      

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    












<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container-xl">

    
    <div class="d-none d-lg-inline-flex">
      <a class="navbar-brand" href="/">Alvaro Franco Martins</a>
    </div>
    

    
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="Toggle navigation">
    <span><i class="fas fa-bars"></i></span>
    </button>
    

    
    <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
      <a class="navbar-brand" href="/">Alvaro Franco Martins</a>
    </div>
    

    
    
    <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

      
      <ul class="navbar-nav d-md-inline-flex">
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#about"><span>About</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
        

        <li class="nav-item">
          <a class="nav-link  active" href="/post"><span>Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/experience"><span>Experience</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/publication"><span>Publications</span></a>
        </li>

        
        

      

        
      </ul>
    </div>

    <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

      
      
        
      

      
      
      <li class="nav-item">
        <a class="nav-link js-search" href="#" aria-label="Search"><i class="fas fa-search" aria-hidden="true"></i></a>
      </li>
      

      
      

      
      

    </ul>

  </div>
</nav>


  </div>

  <div class="page-body">
    
        <article class="article">
            




















  
  


<div class="article-container pt-3">
  <h1>Sensibilidade, especificidade e curvas ROC: Um guia visual para não se confundir mais!</h1>

  
  <p class="page-subtitle">Um guia visual e intuitivo para descomplicar métricas de classificação</p>
  

  


<div class="article-metadata">

  
  
  
  
  <div>
    

  <span class="author-highlighted">
      <a href="/author/alvaro-franco-martins/">Alvaro Franco Martins</a></span>
  </div>
  
  

  
  <span class="article-date">
    
    
      
    
    Mar 23, 2025
  </span>
  

  

  

  
  
  
  
  
  

  
  
  <span class="middot-divider"></span>
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/category/data-science/">data science</a>, <a href="/category/machine-learning/">machine learning</a>, <a href="/category/estatistica/">estatística</a>, <a href="/category/educacao/">educação</a></span>
  

</div>

  





</div>


<div class="article-header container-fluid featured-image-wrapper mt-4 mb-4" style="max-width: 739px; max-height: 558px;">
  <div style="position: relative">
    <img src="/post/ml-metrics/featured.png" width="739" height="558" alt="" class="featured-image">
    
  </div>
</div>


            <div class="article-container">
              <div class="article-style">
                <h1 id="descomplicando-as-métricas-de-classificação">Descomplicando as métricas de classificação</h1>
<p>Você já se viu diante do desafio de memorizar todas aquelas métricas de classificação?</p>
<blockquote>
<p><em>&ldquo;Era sensibilidade que priorizava acertar os positivos ou era especificidade? E a precisão&hellip; se refere a quê mesmo?&quot;</em></p>
</blockquote>
<p>Se você já se fez essas perguntas, não está sozinho. Essas métricas são confusas porque muitas vezes são ensinadas apenas com fórmulas matemáticas, sem uma compreensão visual ou prática do que realmente significam.</p>
<br>
<p>Neste post, vamos transformar conceitos abstratos em intuições visuais. Ao invés de decorar fórmulas, você vai entender o que cada métrica realmente representa e quando deve ser aplicada. Esta postagem inclui simulações interativas, assim você poderá observar como cada métrica se comporta em tempo real.</p>
<h2 id="o-cenário-básico-separando-positivos-e-negativos">O cenário básico: separando positivos e negativos</h2>
<div style="display: flex; align-items: center;">
<div style="flex: 1; padding-right: 20px;">
<p>No diagrama apresentado, utilizamos uma representação visual simplificada para facilitar a compreensão dos conceitos. O retângulo é dividido em duas seções distintas:</p>
<ul>
<li><span style="color: red;">Lado esquerdo</span>: representa casos negativos (exemplos: pessoas sem doença, transação legítima, etc&hellip;);</li>
<li><span style="color: blue;">Lado direito</span>: representa casos positivos (exemplos: pessoas com doença, transação fraudulenta, etc&hellip;).</li>
</ul>
</div>
<div style="flex: 1;">














<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /post/ml-metrics/img/separacao_hu3f58973be1ed0536e63e064b1fdcb669_68287_3de44b4fcbfe16561abd143e6202f3b9.png 400w,
               /post/ml-metrics/img/separacao_hu3f58973be1ed0536e63e064b1fdcb669_68287_0451326f5176334c2702dee5ca1ce4d3.png 760w,
               /post/ml-metrics/img/separacao_hu3f58973be1ed0536e63e064b1fdcb669_68287_1200x1200_fit_lanczos_3.png 1200w"
               src="/post/ml-metrics/img/separacao_hu3f58973be1ed0536e63e064b1fdcb669_68287_3de44b4fcbfe16561abd143e6202f3b9.png"
               width="60%"
               height="760"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</div>
</div>
<p>Para entender as métricas de classificação, podemos visualizar o que um modelo está fazendo. Considere que nosso modelo (por exemplo, que determina se a pessoa possui ou não determinada doença) é representado por um círculo azul no centro desse retângulo. Tudo o que está dentro deste círculo o modelo prevê que é positivo. Portanto, tudo que está fora dele é previsto como negativo.</p>
<div style="display: flex; align-items: center; margin-top: 30px;">
<div style="flex: 1; padding-right: 20px;">
<br>
<p>Observamos claramente que o modelo não é perfeito<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. Ele comete dois tipos de erros:</p>
<ol>
<li>Classifica alguns negativos como positivos (dentro do círculo, à esquerda);</li>
<li>Classifica alguns positivos como negativos (fora do círculo, à direita).</li>
</ol>
</div>
<div style="flex: 1;">














<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /post/ml-metrics/img/separacao_modelo_hu04f02f5379807a38989e453224f67c1d_87762_3d7256dca6c2f1a5a69583887cc6efb5.png 400w,
               /post/ml-metrics/img/separacao_modelo_hu04f02f5379807a38989e453224f67c1d_87762_1ea16d9e8305ae7435780ea59b24fec3.png 760w,
               /post/ml-metrics/img/separacao_modelo_hu04f02f5379807a38989e453224f67c1d_87762_1200x1200_fit_lanczos_3.png 1200w"
               src="/post/ml-metrics/img/separacao_modelo_hu04f02f5379807a38989e453224f67c1d_87762_3d7256dca6c2f1a5a69583887cc6efb5.png"
               width="60%"
               height="760"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</div>
</div>
<h2 id="as-quatro-situações-fundamentais">As quatro situações fundamentais</h2>
<div style="display: flex; align-items: center;">
<div style="flex: 1; padding-right: 20px;">
<p>Esses erros<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> e acertos possuem nomes e são representados nas quatro regiões da figura ao lado. Suas descrições são as seguintes:</p>
<br>
<table>
<thead>
<tr>
<th>Sigla</th>
<th>Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TP</strong></td>
<td>Verdadeiro positivo, acerto</td>
</tr>
<tr>
<td><strong>FN</strong></td>
<td>Falso negativo, erro de omissão, subestimação</td>
</tr>
<tr>
<td><strong>FP</strong></td>
<td>Falso positivo, falso alarme, superestimação</td>
</tr>
<tr>
<td><strong>TN</strong></td>
<td>Verdadeiro negativo, rejeição correta</td>
</tr>
</tbody>
</table>
  </div>
<div style="flex: 1;">

<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visualização Interativa das Métricas de Classificação</title>
  <style>
    .simulation_container {
      max-width: 600px;
      margin: 0 auto;
      font-family: Arial, sans-serif;
    }
    
    .visualization {
      position: relative;
      width: 400px;
      height: 400px;
      margin: 20px auto;
      border: 2px solid #000;
      background-color: #ffffff;
    }
    
    .divider {
      position: absolute;
      top: 0;
      left: 50%;
      width: 2px;
      height: 100%;
      background-color: #000;
    }
    
    .circle {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 65%;
      height: 65%;
      border: 3px solid blue;
      border-radius: 50%;
      background-color: rgba(0, 0, 255, 0.08);
      z-index: 1;
    }
    
    .dot {
      position: absolute;
      width: 7px;
      height: 7px;
      border-radius: 50%;
      margin: -3.5px 0 0 -3.5px;
    }
    
    .negative {
      background-color: red;
    }
    
    .positive {
      background-color: blue;
    }
    
    .label {
      position: absolute;
      font-size: 32px;
      font-weight: bold;
      z-index: 3;
      cursor: pointer;
      padding: 6px 12px;
      border-radius: 8px;
      transition: all 0.2s ease;
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 1);
      color: #000;
      background-color: rgba(255, 255, 255, 0.9);
      border: 2px dashed rgba(0, 0, 0, 0.1);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .label:hover {
      transform: scale(1.1);
      background-color: rgba(255, 255, 255, 1);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 1);
      border: 2px dashed rgba(0, 0, 0, 0.7);
    }
    
    /* Posicionamento correto baseado nas posições fornecidas */
    .tn-label {
      top: 7%;
      left: 10%;
      color: #000;
    }
    
    .fn-label {
      top: 7%;
      right: 10%;
      color: #000;
    }
    
    .fp-label {
      bottom: 42%;
      left: 30%;
      color: #000;
    }
    
    .tp-label {
      bottom: 42%;
      right: 30%;
      color: #000;
    }
    
    .side-label {
      position: absolute;
      font-size: 24px;
      font-weight: bold;
      bottom: -40px;
      text-align: center;
      width: 45%;
    }
    
    .negative-label {
      left: 0;
      color: #ff0000;
    }
    
    .positive-label {
      right: 0;
      color: blue;
    }
    
    .info-box {
      position: absolute;
      top: 95%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(255, 255, 255, 1);
      border: 2px solid #333;
      border-radius: 10px;
      padding: 7px;
      width: 100%;
      max-width: 400px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      z-index: 10;
      display: none;
    }
    
    .info-title {
      font-size: 22px;
      font-weight: bold;
      margin-bottom: 15px;
      text-align: center;
      border-bottom: 1px solid #ddd;
      padding-bottom: 10px;
    }
    
    .info-description {
      font-size: 16px;
      margin-bottom: 15px;
      line-height: 1.5;
      white-space: pre-line;
    }
    
    .close-btn {
      background-color: #4a5568;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      display: block;
      margin: 0 auto;
      font-weight: bold;
      transition: background-color 0.2s;
    }
    
    .close-btn:hover {
      background-color: #2d3748;
    }
    
    .instructions {
      text-align: center;
      margin-bottom: 20px;
      font-style: italic;
      color: #555;
      background-color: #f0f0f0;
      padding: 12px;
      border-radius: 8px;
      border-left: 6px solid #4a5568;
      font-size: 18px;
    }
    
    /* Responsividade para telas menores */
    @media (max-width: 600px) {
      .visualization {
        width: 100%;
        height: 90vw;
        max-height: 500px;
      }
      
      .label {
        font-size: 18px;
      }
      
      .side-label {
        font-size: 18px;
      }
    }

    table {
      font-size: 1rem !important;
      width: 100%;
    }
    table td, table th {
      padding: 18px;
      font-size: 1rem !important;
}

  </style>
</head>
<body>
  <div class="simulation_container">    
    <div class="visualization" id="classification-viz">
      <div class="divider"></div>
      <div class="circle"></div>
      
      <!-- Rótulos clicáveis -->
      <div class="label tn-label" data-type="tn">TN</div>
      <div class="label fn-label" data-type="fn">FN</div>
      <div class="label fp-label" data-type="fp">FP</div>
      <div class="label tp-label" data-type="tp">TP</div>
      
      <!-- Rótulos laterais -->
      <div class="side-label negative-label">Negativos</div>
      <div class="side-label positive-label">Positivos</div>
      
      <!-- Caixa de informações -->
      <div class="info-box" id="info-box">
        <div class="info-title" id="info-title"></div>
        <div class="info-description" id="info-description"></div>
        <button class="close-btn" id="close-btn">Fechar</button>
      </div>
    </div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const visualization = document.getElementById('classification-viz');
      const infoBox = document.getElementById('info-box');
      const infoTitle = document.getElementById('info-title');
      const infoDescription = document.getElementById('info-description');
      const closeBtn = document.getElementById('close-btn');
      const circle = document.querySelector('.circle');
      
      // Dados para cada quadrante - definições precisas
      const quadrantInfo = {
        tn: {
          title: 'TN - Verdadeiro Negativo',
          description: 'O modelo classificou como NEGATIVO, e realmente era NEGATIVO.\n\nEstes são os pontos vermelhos (negativos) que estão FORA do círculo (classificados como negativos pelo modelo).'
        },
        fn: {
          title: 'FN - Falso Negativo',
          description: 'O modelo classificou como NEGATIVO, mas na verdade era POSITIVO.\n\nEstes são os pontos azuis (positivos) que estão FORA do círculo (classificados como negativos pelo modelo).'
        },
        fp: {
          title: 'FP - Falso Positivo',
          description: 'O modelo classificou como POSITIVO, mas na verdade era NEGATIVO.\n\nEstes são os pontos vermelhos (negativos) que estão DENTRO do círculo (classificados como positivos pelo modelo).'
        },
        tp: {
          title: 'TP - Verdadeiro Positivo',
          description: 'O modelo classificou como POSITIVO, e realmente era POSITIVO.\n\nEstes são os pontos azuis (positivos) que estão DENTRO do círculo (classificados como positivos pelo modelo).'
        }
      };
      
      // Obter as dimensões do círculo e área de visualização
      function getCircleProperties() {
        const rect = circle.getBoundingClientRect();
        const vizRect = visualization.getBoundingClientRect();
        
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const radius = rect.width / 2;
        
        return { centerX, centerY, radius, vizWidth: vizRect.width, vizHeight: vizRect.height };
      }
      
      // Verificar se um ponto está dentro do círculo
      function isInsideCircle(x, y) {
        const rect = circle.getBoundingClientRect();
        const vizRect = visualization.getBoundingClientRect();
        
        const circleX = rect.left + rect.width / 2 - vizRect.left;
        const circleY = rect.top + rect.height / 2 - vizRect.top;
        const radius = rect.width / 2;
        
        const dx = x - circleX;
        const dy = y - circleY;
        return dx * dx + dy * dy <= radius * radius;
      }
      
      // Gerar pontos aleatórios
      function generateDots() {
        // Limpar pontos existentes
        const existingDots = document.querySelectorAll('.dot');
        existingDots.forEach(dot => dot.remove());
        
        const { vizWidth, vizHeight } = getCircleProperties();
        const midX = vizWidth / 2;
        
        // Gerar novos pontos
        for (let i = 0; i < 500; i++) {
          const dot = document.createElement('div');
          dot.className = 'dot';
          
          // Metade dos pontos são negativos (esquerda), metade positivos (direita)
          const isPositive = i >= 250;
          dot.classList.add(isPositive ? 'positive' : 'negative');
          
          // Posicionar os pontos respeitando a divisão central
          let x, y;
          
          if (isPositive) {
            // Pontos positivos (lado direito)
            x = Math.random() * (vizWidth / 2 - 10) + midX + 5;  // 5px de margem da linha central
          } else {
            // Pontos negativos (lado esquerdo)
            x = Math.random() * (vizWidth / 2 - 10) + 5;         // 5px de margem da borda
          }
          
          y = Math.random() * (vizHeight - 10) + 5;    // 5px de margem da borda superior e inferior
          
          // Melhor distribuição para TN, FP, FN, TP
          const insideCircle = isInsideCircle(x, y);
          
          // Queremos uma distribuição de pontos que seja consistente com a visualização
          // Se for FP (negativo dentro do círculo) ou FN (positivo fora do círculo)
          // reduzimos a probabilidade para ter mais TP e TN
          if ((!isPositive && insideCircle) || (isPositive && !insideCircle)) {
            if (Math.random() > 0.6) {
              // Tentar novamente para obter mais TP e TN
              i--;
              continue;
            }
          }
          
          dot.style.left = x + 'px';
          dot.style.top = y + 'px';
          
          visualization.appendChild(dot);
        }
      }
      
      // Mostrar informações quando um rótulo é clicado
      const labels = document.querySelectorAll('.label');
      labels.forEach(label => {
        label.addEventListener('click', function() {
          const type = this.getAttribute('data-type');
          const info = quadrantInfo[type];
          
          infoTitle.textContent = info.title;
          infoDescription.textContent = info.description;
          
          infoBox.style.display = 'block';
          
          // Destacar o rótulo clicado
          labels.forEach(l => l.style.backgroundColor = '');
          this.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
        });
      });
      
      // Fechar a caixa de informações
      closeBtn.addEventListener('click', function() {
        infoBox.style.display = 'none';
        
        // Remover destaque de todos os rótulos
        labels.forEach(l => l.style.backgroundColor = '');
      });
      
      // Fechar a caixa quando clicar fora dela
      visualization.addEventListener('click', function(e) {
        if (e.target === visualization || e.target === document.querySelector('.circle') || e.target === document.querySelector('.divider')) {
          infoBox.style.display = 'none';
          
          // Remover destaque de todos os rótulos
          labels.forEach(l => l.style.backgroundColor = '');
        }
      });
      
      // Inicializar a visualização
      window.addEventListener('resize', generateDots);
      generateDots();
    });
  </script>
</body>
</html>
<br>
<div class="instructions">No painel acima, clique em cada rótulo (TN, FP, FN, TP) para aprender mais sobre as quatro situações fundamentais. </div>
</div>
</div>
<br>
<p>Com base nessas quatro situações, podemos calcular métricas que nos ajudam a avaliar o desempenho de um modelo.</p>
<h2 id="entendendo-cada-métrica-visualmente">Entendendo Cada Métrica Visualmente</h2>
<h3 id="1-sensibilidade-recall-ou-tpr">1. Sensibilidade (Recall ou TPR)</h3>
<div style="display: flex; align-items: center;">
<div style="flex: 1; padding-right: 20px;">
<p><strong>Pergunta-chave: &ldquo;De todos os casos realmente positivos, quantos o modelo classificou como positivos?&quot;</strong></p>
<br>
<div style="text-align: center;">
$$\text{Sensibilidade} = \frac{TP}{TP + FN}$$
</div>
<br>
<p>A <strong>sensibilidade</strong> indica quanto do lado direito foi coberto pelo círculo — ou seja, a proporção entre a parte azul dentro do círculo (TP) e todo o lado direito (TP + FN).</p>
</div>
<div style="flex: 1;">














<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /post/ml-metrics/img/tpr_hu83acb151a3873ecb5acdbb19fdef72f9_88387_a28f82fe6d55a7ba15b2887f3d912c99.png 400w,
               /post/ml-metrics/img/tpr_hu83acb151a3873ecb5acdbb19fdef72f9_88387_0975becfbc9e35fa0d01b25d49bd1e2b.png 760w,
               /post/ml-metrics/img/tpr_hu83acb151a3873ecb5acdbb19fdef72f9_88387_1200x1200_fit_lanczos_3.png 1200w"
               src="/post/ml-metrics/img/tpr_hu83acb151a3873ecb5acdbb19fdef72f9_88387_a28f82fe6d55a7ba15b2887f3d912c99.png"
               width="60%"
               height="760"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</div>
</div>
<h3 id="2-taxa-de-falsos-negativos-fnr">2. Taxa de Falsos Negativos (FNR)</h3>
<div style="display: flex; align-items: center;">
<div style="flex: 1; padding-right: 20px;">
<p><strong>Pergunta-chave: &ldquo;De todos os casos realmente positivos, quantos o modelo classificou como negativos?&quot;</strong></p>
<br>
<div style="text-align: center;">
$$\text{FNR} = \frac{FN}{TP + FN} = 1 - \text{Sensibilidade}$$
</div>
<br>
<p>É a proporção entre o que o círculo não cobriu do lado direito (FN) em relação ao lado direito inteiro (TP + FN).</p>
</div>
<div style="flex: 1;">














<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /post/ml-metrics/img/fnr_hu12acc418103c2365ca44d1387167aa06_82701_9e9a288eb11238d76cbe97cd7e1c418e.png 400w,
               /post/ml-metrics/img/fnr_hu12acc418103c2365ca44d1387167aa06_82701_576f67fb3635cc80f3b1360bfdea8255.png 760w,
               /post/ml-metrics/img/fnr_hu12acc418103c2365ca44d1387167aa06_82701_1200x1200_fit_lanczos_3.png 1200w"
               src="/post/ml-metrics/img/fnr_hu12acc418103c2365ca44d1387167aa06_82701_9e9a288eb11238d76cbe97cd7e1c418e.png"
               width="60%"
               height="626"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</div>
</div>
<h3 id="3-especificidade-tnr">3. Especificidade (TNR)</h3>
<div style="display: flex; align-items: center;">
<div style="flex: 1; padding-right: 20px;">
<p><strong>Pergunta-chave: &ldquo;De todos os casos realmente negativos, quantos o modelo classificou como negativos?&quot;</strong></p>
<br>
<div style="text-align: center;">
$$\text{Especificidade} = \frac{TN}{TN + FP}$$
</div>
<br>
<p>A <strong>especificidade</strong> representa a proporção do lado esquerdo que o círculo não cobriu (TN) em relação ao lado esquerdo inteiro (TN + FP).</p>
</div>
<div style="flex: 1;">














<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /post/ml-metrics/img/tnr_hu898c36af63707939ee0fc9f92b553a00_87616_e1f42cb1315e2f27e339e4783b54b2bb.png 400w,
               /post/ml-metrics/img/tnr_hu898c36af63707939ee0fc9f92b553a00_87616_05e1cd55e74a7ccc1c39fbd7cca622ac.png 760w,
               /post/ml-metrics/img/tnr_hu898c36af63707939ee0fc9f92b553a00_87616_1200x1200_fit_lanczos_3.png 1200w"
               src="/post/ml-metrics/img/tnr_hu898c36af63707939ee0fc9f92b553a00_87616_e1f42cb1315e2f27e339e4783b54b2bb.png"
               width="60%"
               height="760"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</div>
</div>
<h3 id="4-taxa-de-falsos-positivos-fpr">4. Taxa de Falsos Positivos (FPR)</h3>
<div style="display: flex; align-items: center;">
<div style="flex: 1; padding-right: 20px;">
<p><strong>Pergunta-chave: &ldquo;De todos os casos realmente negativos, quantos o modelo  classificou como positivos?&quot;</strong></p>
<br>
<div style="text-align: center;">
$$\text{FPR} = \frac{FP}{TN + FP} = 1 - \text{Especificidade}$$
</div>
<br>
<p>É a proporção entre o que o círculo cobriu do lado esquerdo (FP) e o lado esquerdo inteiro (TN + FP). É o complemento da especificidade.</p>
</div>
<div style="flex: 1;">














<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /post/ml-metrics/img/fpr_hu2d1878e6feaffb64491d611c1a439f6e_88246_385ab302cd18c19653c23c4fa6b2f037.png 400w,
               /post/ml-metrics/img/fpr_hu2d1878e6feaffb64491d611c1a439f6e_88246_53c00ec90bea212034d32e374515e84f.png 760w,
               /post/ml-metrics/img/fpr_hu2d1878e6feaffb64491d611c1a439f6e_88246_1200x1200_fit_lanczos_3.png 1200w"
               src="/post/ml-metrics/img/fpr_hu2d1878e6feaffb64491d611c1a439f6e_88246_385ab302cd18c19653c23c4fa6b2f037.png"
               width="60%"
               height="760"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</div>
</div>
<h3 id="5-precisão-precision-ou-ppv">5. Precisão (Precision ou PPV)</h3>
<div style="display: flex; align-items: center;">
<div style="flex: 1; padding-right: 20px;">
<p><strong>Pergunta-chave: &ldquo;Quando o modelo diz &lsquo;positivo&rsquo;, com que frequência ele está correto?&quot;</strong></p>
<br>
<div style="text-align: center;">
$$\text{Precisão} = \frac{TP}{TP + FP}$$
</div>
<br>
<p>Considerando a região interna do círculo (tudo o que o modelo classificou como positivo), a <strong>precisão</strong> representa a proporção da área à direita (TP) em relação à área total do círculo (TP + FP). Essa métrica também é conhecida como PPV (Positive predicted value).</p>
</div>
<div style="flex: 1;">














<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /post/ml-metrics/img/prec_hu87f480ea6cdf39eeaeec3942b42ab3b6_113788_a994763ebed4b5ae20598529275689ae.png 400w,
               /post/ml-metrics/img/prec_hu87f480ea6cdf39eeaeec3942b42ab3b6_113788_11a057d11ebf9b73109b79018bc3f7c0.png 760w,
               /post/ml-metrics/img/prec_hu87f480ea6cdf39eeaeec3942b42ab3b6_113788_1200x1200_fit_lanczos_3.png 1200w"
               src="/post/ml-metrics/img/prec_hu87f480ea6cdf39eeaeec3942b42ab3b6_113788_a994763ebed4b5ae20598529275689ae.png"
               width="60%"
               height="760"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</div>
</div>
<h3 id="6-acurácia">6. Acurácia</h3>
<div style="display: flex; align-items: center;">
<div style="flex: 1; padding-right: 20px;">
<p><strong>Pergunta-chave: &ldquo;Qual a porcentagem total de previsões corretas?&quot;</strong></p>
<div style="text-align: center;">
$$\text{Acurácia} = \frac{TP + TN}{TP + TN + FP + FN}$$
</div>
<br>
<p>A <strong>acurácia</strong> representa a proporção da área coberta pelo circulo à direita (TP) mais a área não coberta pelo círculo à esquerda (TN) em relação à área total.</p>
</div>
<div style="flex: 1;">














<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /post/ml-metrics/img/acuracia_huaf85c404ff198c2ba9fa7f1480b5b36b_156621_55e735f14940870b5d2fb976dfc7bab1.png 400w,
               /post/ml-metrics/img/acuracia_huaf85c404ff198c2ba9fa7f1480b5b36b_156621_f1c4c3bbdebf55a66a61ccbec37aa736.png 760w,
               /post/ml-metrics/img/acuracia_huaf85c404ff198c2ba9fa7f1480b5b36b_156621_1200x1200_fit_lanczos_3.png 1200w"
               src="/post/ml-metrics/img/acuracia_huaf85c404ff198c2ba9fa7f1480b5b36b_156621_55e735f14940870b5d2fb976dfc7bab1.png"
               width="60%"
               height="760"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</div>
</div>
<h1 id="simulações-interativas">Simulações interativas</h1>
<p>Para realmente compreender esses conceitos, nada melhor que ver como eles se comportam em tempo real.</p>
<h2 id="métricas-de-classificação">Métricas de classificação</h2>
<p>A simulação abaixo ilustra interativamente os conceitos fundamentais de métricas de classificação. Pontos são uniformemente e aleatoriamente gerados, separados entre as classes positiva (direita) e negativa (esquerda). Você pode alterar o tamanho do cículo, bem como movê-lo e assim observar como se comportam as métricas discutidas acima.</p>
<br>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/contrib/auto-render.min.js"></script>
    <style>
        .simulation-container {
            max-width: 1200px;
        }
        
        /* Novo contêiner flexível para layout lado a lado */
        .flex-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
        }
        
        .visualization-area {
            flex: 3;
            min-width: 300px;
        }
        
        .metrics-area {
            flex: 2;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }
        
        .control-panel {
            width: 100%;
            max-width: 800px; /* Match visualization area width */
            margin: 0 auto 20px; /* Center horizontally with bottom margin */
            justify-content: flex-start; /* Left-align slider */
        }

        
        /* Improved Slider Styles */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
            position: relative;
            width: 100%;
            max-width: 350px;
        }
        
        .slider-container label {
            font-weight: bold;
            min-width: 100px;
            color: #333;
            margin-bottom: 8px;
        }
        
        .range-slider {
            width: 100%;
            position: relative;
        }
        
        .range-slider-track {
            height: 8px;
            width: 100%;
            background-color: #ddd;
            border-radius: 4px;
            position: relative;
        }
        
        .range-slider-fill {
            height: 100%;
            background-color: #3b82f6;
            border-radius: 4px;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            transition: width 0.1s ease;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: transparent;
            position: absolute;
            top: 0;
            left: 0;
            margin: 0;
            z-index: 10;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        .slider-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #3b82f6;
            background-color: #f0f4ff;
            padding: 4px 8px;
            border-radius: 12px;
            margin-left: 10px;
            border: 1px solid #d1d5db;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            padding-bottom: 70%; /* Ajustado para uma proporção diferente */
            border: 0px solid black;
            overflow: hidden;
            background-color: white;
            margin-bottom: 10px;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: move;
        }
        .quadrant-label {
            position: absolute;
/*            font-weight: bold;*/
            font-size: 17px;
            text-align: center;
            color: #fff;
            background-color: rgba(0, 0, 0, 1);
            padding: 1px 5px;
            border-radius: 10px;
            z-index: 10;
            pointer-events: none;
            transition: all 0.3s ease;
        }
        .metrics-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
        }
        .metric-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        .metric-btn {
            padding: 8px 12px;
            font-size: 24px;
            cursor: pointer;
            background-color: #f8f8f8;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-weight: bold;
            text-align: center;
            line-height: 1.2;
        }
        .metric-btn.active {
            background-color: #e6f0ff;
            border-color: #99c2ff;
        }
        /* Updated Metric Display Styles */
        .metric-display {
            min-height: 0px;
            max-height: 440px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            align-items: center;
            justify-content: flex-start;
            padding-top: 20px;
        }

        .metric-title {
            margin-bottom: 0;
            font-size: 30px;
            color: #000;
            text-align: center;
        }

        .metric-formula {
            font-size: 30px;
            text-align: center;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            max-width: 100%;
            overflow: auto;
            margin-bottom: 0px;
            margin-top: 0px;
            overflow: hidden; /* Remove scrollbar */

        }

        .metric-formula .equation {
            font-size: 22px;
            margin-bottom: 10px;
        }

        .metric-formula .result {
            font-size: 20px;
            color: #007bff;
            font-weight: bold;
        }
        .instruction {
            text-align: center;
            margin: 10px 0;
            color: #666;
            font-style: italic;
        }
        
        /* Responsividade para telas menores */
        @media (max-width: 768px) {
            .flex-container {
                flex-direction: column;
            }
            .visualization-area, .metrics-area {
                width: 100%;
            }
            .metric-btn {
                padding: 10px 15px;
                font-size: 16px;
            }
            .canvas-container {
                padding-bottom: 60%;
            }
        }

        table {
          max-width: 100%;
          overflow-x: hidden;
          table-layout: fixed;
        }
    </style>
</head>
<body>
    <div class="simulation-container">
        
        <div class="control-panel">
            <div class="slider-container">
                <label for="circleSize">Raio do círculo</label>
                <div class="range-slider">
                    <div class="range-slider-track">
                        <div class="range-slider-fill" id="circleSizeFill"></div>
                    </div>
                    <input type="range" id="circleSize" min="0" max="100" value="30" step="1">
                </div>
            </div>
        </div>
        
        <!-- Novo contêiner flexível para layout lado a lado -->
        <div class="flex-container">
            <!-- Área de visualização (lado esquerdo) -->
            <div class="visualization-area">
                <div class="canvas-container">
                    <canvas id="canvas"></canvas>
                    <div id="quadrant0" class="quadrant-label">False<br>Positives</div>
                    <div id="quadrant1" class="quadrant-label">True<br>Positives</div>
                    <div id="quadrant2" class="quadrant-label">True<br>Negatives</div>
                    <div id="quadrant3" class="quadrant-label">False<br>Negatives</div>
                </div>
                
                <div style="display: flex; justify-content: space-between; width: 100%; font-weight: bold; margin-top: 5px;">
                    <span>Negatives</span>
                    <span>Positives</span>
                </div>
            </div>
            
            <!-- Área de métricas (lado direito) -->
            <div class="metrics-area">
                <div class="metrics-container">
                    
                    <div class="metric-buttons">
                        <button id="btnRecall" class="metric-btn active">Recall<br>Sensitivity</button>
                        <button id="btnFPR" class="metric-btn">FPR</button>
                        <button id="btnSpecificity" class="metric-btn">Specificity</button>
                        <button id="btnFNR" class="metric-btn">FNR</button>
                        <button id="btnPrecision" class="metric-btn">Precision</button>
                        <button id="btnAccuracy" class="metric-btn">Accuracy</button>
                        <button id="btnF1" class="metric-btn">F1 Score</button>
                    </div>
                    
                    <div class="metric-display">
                        <div class="metric-title" id="metricTitle">Recall/Sensitivity (TPR):</div>
                        <div class="metric-formula" id="metricFormula">Recall = TP/(TP + FN) = 0/0 = 0</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const circleSizeSlider = document.getElementById('circleSize');
        const circleSizeFill = document.getElementById('circleSizeFill');
        
        // Quadrant labels
        const quadrantLabels = [
            document.getElementById('quadrant0'),
            document.getElementById('quadrant1'),
            document.getElementById('quadrant2'),
            document.getElementById('quadrant3')
        ];
        
        // Metric buttons
        const btnRecall = document.getElementById('btnRecall');
        const btnFPR = document.getElementById('btnFPR');
        const btnSpecificity = document.getElementById('btnSpecificity');
        const btnFNR = document.getElementById('btnFNR');
        const btnPrecision = document.getElementById('btnPrecision');
        const btnAccuracy = document.getElementById('btnAccuracy');
        const btnF1 = document.getElementById('btnF1');
        
        // Metric displays
        const metricTitle = document.getElementById('metricTitle');
        const metricFormula = document.getElementById('metricFormula');
        
        // Variables
        let isDragging = false;
        let truePositives = 0;
        let falsePositives = 0;
        let trueNegatives = 0;
        let falseNegatives = 0;
        let totalPoints = 0;
        let points = [];
        let currentMetric = 'recall';
        
        // Circle properties
        let circleRadius;
        let centerX;
        let centerY;
        let circleCenter = { x: 0.5, y: 0.5 }; // Normalized position (0-1)
        let circleSizePercent = 30; // Percentage of min dimension
        let dragStartPos = { x: 0, y: 0 };
        let dragStartCenter = { x: 0, y: 0 };
        
        // Update slider fill
        function updateSliderFill() {
            const percent = (circleSizeSlider.value - circleSizeSlider.min) / (circleSizeSlider.max - circleSizeSlider.min) * 100;
            circleSizeFill.style.width = percent + '%';
        }
        
        // Initial slider fill update
        updateSliderFill();
        
        // Update slider values
        circleSizeSlider.addEventListener('input', function() {
            circleSizePercent = parseInt(this.value);
            updateSliderFill();
            calculateDimensions();
            redrawCanvas();
            recalculateMetrics();
            updateLabels();
        });
        
        // Resize canvas to fit container
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            calculateDimensions();
            redrawCanvas();
            updateLabels();
        }
        
        // Calculate circle dimensions based on canvas size and current settings
        function calculateDimensions() {
            centerX = canvas.width * circleCenter.x;
            centerY = canvas.height * circleCenter.y;
            const minDimension = Math.min(canvas.width, canvas.height);
            circleRadius = minDimension * (circleSizePercent / 100);
        }
        
        // Generate points once at startup
        function generatePoints(count) {
            points = [];
            
            // Generate half the points on the left side and half on the right
            for (let i = 0; i < count / 2; i++) {
                // Left side point (Negatives)
                points.push({
                    x: Math.random() * (canvas.width / 2 - 5),
                    y: Math.random() * canvas.height
                });
                
                // Right side point (Positives)
                points.push({
                    x: (canvas.width / 2 + 5) + Math.random() * (canvas.width / 2 - 10),
                    y: Math.random() * canvas.height
                });
            }
            
            recalculateMetrics();
        }
        
        // Update the class metrics based on the points
        function recalculateMetrics() {
            // Reset counts
            truePositives = 0;
            falsePositives = 0;
            trueNegatives = 0;
            falseNegatives = 0;
            
            // Recalculate counts for each point
            points.forEach(point => {
                const isRight = point.x >= canvas.width / 2;
                const isPredictedPositive = isInsideCircle(point.x, point.y);
                
                if (isRight && isPredictedPositive) truePositives++;
                else if (!isRight && isPredictedPositive) falsePositives++;
                else if (!isRight && !isPredictedPositive) trueNegatives++;
                else if (isRight && !isPredictedPositive) falseNegatives++;
            });
            
            totalPoints = points.length;
            
            // Update the current metric display
            updateMetricDisplay();
        }
        
        // Redraw canvas with all points and current circle position
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPoints();
            drawBase();
        }
        
        // Update quadrant labels dynamically based on circle position
        function updateLabels() {
            // Get vertical dividing line position
            const midX = canvas.width / 2;
            
            // Check if circle overlaps with left or right half
            const leftEdge = centerX - circleRadius;
            const rightEdge = centerX + circleRadius;
            const overlapsLeft = leftEdge < midX;
            const overlapsRight = rightEdge > midX;
            
            // Padding to ensure labels stay within canvas
            const padding = 20;
            const labelWidth = 70;
            const labelHeight = 40;
            
            // Label safety margin (extra distance from circle)
            const safetyMargin = 15;
            
            // 1. False Positives (inside circle, left side)
            if (overlapsLeft && circleRadius > 1) {
                // Position inside circle on left side
                const fpX = Math.max(padding, Math.min(midX - labelWidth - padding, centerX - 10));
                const fpY = centerY;
                quadrantLabels[0].style.display = 'block';
                quadrantLabels[0].style.left = fpX + 'px';
                quadrantLabels[0].style.top = fpY + 'px';
                quadrantLabels[0].style.right = 'auto';
                quadrantLabels[0].innerHTML = "False<br>Positives";
                quadrantLabels[0].style.backgroundColor = 'rgba(0, 0, 0, 1)';
            } else {
                quadrantLabels[0].style.display = 'none';
            }
            
            // 2. True Positives (inside circle, right side)
            if (overlapsRight && circleRadius > 1) {
                // Position inside circle on right side
                const tpX = Math.min(canvas.width - labelWidth - padding, Math.max(midX + padding, centerX + 10));
                const tpY = centerY;
                quadrantLabels[1].style.display = 'block';
                quadrantLabels[1].style.left = tpX + 'px';
                quadrantLabels[1].style.top = tpY + 'px';
                quadrantLabels[1].style.right = 'auto';
                quadrantLabels[1].innerHTML = "True<br>Positives";
                quadrantLabels[1].style.backgroundColor = 'rgba(0, 0, 0, 1)';
            } else {
                quadrantLabels[1].style.display = 'none';
            }
            
            // 3. True Negatives (outside circle, left side)
            let tnX, tnY;

            // Try different positions for True Negatives to ensure it's outside the circle
            // Option 1: Far top left
            let tnPosition1 = { x: padding, y: padding };
            // Option 2: Far bottom left
            let tnPosition2 = { x: padding, y: canvas.height - labelHeight - padding };
            // Option 3: Default position but adjusted
            let tnPosition3 = { x: Math.min(midX / 2, leftEdge - labelWidth - safetyMargin), y: canvas.height * 0.2 };

            // Check which position is furthest from circle
            let tnDistances = [
                distanceToCircle(tnPosition1.x, tnPosition1.y),
                distanceToCircle(tnPosition2.x, tnPosition2.y),
                distanceToCircle(tnPosition3.x, tnPosition3.y)
            ];

            // Select the position with the maximum distance from circle
            let tnMaxDistanceIndex = tnDistances.indexOf(Math.max(...tnDistances));

            if (tnMaxDistanceIndex === 0) {
                tnX = tnPosition1.x;
                tnY = tnPosition1.y;
            } else if (tnMaxDistanceIndex === 1) {
                tnX = tnPosition2.x;
                tnY = tnPosition2.y;
            } else {
                tnX = tnPosition3.x;
                tnY = tnPosition3.y;
            }

            // Ensure it's within bounds and outside the circle
            tnX = Math.max(padding, Math.min(midX - labelWidth - padding, tnX))-15;
            tnY = Math.max(padding, Math.min(canvas.height - labelHeight - padding, tnY));

            // Additional check to ensure the label is outside the circle
            while (isInsideCircle(tnX + labelWidth / 2, tnY + labelHeight / 2)) {
                tnX -= 10; // Move left
                tnY -= 10; // Move up
            }

            quadrantLabels[2].style.display = 'block';
            quadrantLabels[2].style.left = tnX + 'px';
            quadrantLabels[2].style.top = tnY + 'px';
            quadrantLabels[2].style.right = 'auto';
            quadrantLabels[2].innerHTML = "True<br>Negatives";
            quadrantLabels[2].style.backgroundColor = 'rgba(0, 0, 0, 1)';

            // 4. False Negatives (outside circle, right side)
            let fnX, fnY;

            // Try different positions for False Negatives to ensure it's outside the circle
            // Option 1: Far top right
            let fnPosition1 = { x: canvas.width - labelWidth - padding, y: padding };
            // Option 2: Far bottom right
            let fnPosition2 = { x: canvas.width - labelWidth - padding, y: canvas.height - labelHeight - padding };
            // Option 3: Default position but adjusted
            let fnPosition3 = { x: Math.max(midX + (canvas.width - midX) / 2, rightEdge + safetyMargin), y: canvas.height * 0.2};

            // Check which position is furthest from circle
            let fnDistances = [
                distanceToCircle(fnPosition1.x, fnPosition1.y),
                distanceToCircle(fnPosition2.x, fnPosition2.y),
                distanceToCircle(fnPosition3.x, fnPosition3.y)
            ];

            // Select the position with the maximum distance from circle
            let fnMaxDistanceIndex = fnDistances.indexOf(Math.max(...fnDistances));

            if (fnMaxDistanceIndex === 0) {
                fnX = fnPosition1.x;
                fnY = fnPosition1.y;
            } else if (fnMaxDistanceIndex === 1) {
                fnX = fnPosition2.x;
                fnY = fnPosition2.y;
            } else {
                fnX = fnPosition3.x;
                fnY = fnPosition3.y;
            }

            // Ensure it's within bounds and outside the circle
            fnX = Math.max(midX + padding, Math.min(canvas.width - labelWidth - padding, fnX));
            fnY = Math.max(padding, Math.min(canvas.height - labelHeight - padding, fnY));

            // Additional check to ensure the label is outside the circle
            while (isInsideCircle(fnX + labelWidth / 2, fnY + labelHeight / 2)) {
                fnX += 10; // Move right
                fnY -= 10; // Move up
            }

            quadrantLabels[3].style.display = 'block';
            quadrantLabels[3].style.left = fnX + 'px';
            quadrantLabels[3].style.top = fnY + 'px';
            quadrantLabels[3].style.right = 'auto';
            quadrantLabels[3].innerHTML = "False<br>Negatives";
            quadrantLabels[3].style.backgroundColor = 'rgba(0, 0, 0,1)';
        }
        
        // Calculate distance from a point to the circle
        function distanceToCircle(x, y) {
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return Math.max(0, distance - circleRadius);
        }
        
        // Draw base canvas with vertical line and circle
        function drawBase() {
            // Draw dividing line
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 0, 255, 0.15)';
            ctx.fill();
            ctx.strokeStyle = 'dark';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw border
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
            
            // Add coordinate text
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.font = '12px Arial';
            // ctx.fillText(`Center: (${Math.round(circleCenter.x * 100)}%, ${Math.round(circleCenter.y * 100)}%)`, 10, 20);
        }
        
        // Draw all points
        function drawPoints() {
            ctx.save();
            points.forEach(point => {
                const isRight = point.x >= canvas.width / 2;
                
                // Choose color based on actual class (left/right side)
                if (isRight) {
                    ctx.fillStyle = 'blue'; // Actual Positive (right side)
                } else {
                    ctx.fillStyle = 'red'; // Actual Negative (left side)
                }
                
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();
        }
        
        // Check if a point is inside the classification circle
        function isInsideCircle(x, y) {
            const dx = x - centerX;
            const dy = y - centerY;
            return (dx * dx + dy * dy) <= (circleRadius * circleRadius);
        }
        
        // Update the metric display based on the current selected metric
        function updateMetricDisplay() {
            // Skip if no points
            if (totalPoints === 0) {
                metricFormula.textContent = getMetricFormula(currentMetric, true);
                renderKatex();
                return;
            }
            
            // Calculate metrics
            const tpr = truePositives / (truePositives + falseNegatives) || 0;
            const fpr = falsePositives / (falsePositives + trueNegatives) || 0;
            const tnr = trueNegatives / (trueNegatives + falsePositives) || 0;
            const fnr = falseNegatives / (falseNegatives + truePositives) || 0;
            const precision = truePositives / (truePositives + falsePositives) || 0;
            const accuracy = (truePositives + trueNegatives) / totalPoints || 0;
            const f1 = 2 * (precision * tpr) / (precision + tpr) || 0;
            
            // Update formula display based on current metric with properly aligned equations
            switch (currentMetric) {
                case 'recall':
                    metricFormula.textContent = `
                    \\begin{aligned}
                    &= \\frac{\\text{TP}}{\\text{TP} + \\text{FN}} \\\\[12pt]
                    &= \\frac{${truePositives}}{${truePositives} + ${falseNegatives}} \\\\[12pt]
                    &= ${tpr.toFixed(3)}
                    \\end{aligned}
                    `;
                    break;
                case 'fpr':
                    metricFormula.textContent = `
                    \\begin{aligned}
                    &= \\frac{\\text{FP}}{\\text{FP} + \\text{TN}} \\\\[12pt]
                    &= \\frac{${falsePositives}}{${falsePositives} + ${trueNegatives}} \\\\[12pt]
                    &= ${fpr.toFixed(3)}
                    \\end{aligned}
                    `;
                    break;
                case 'specificity':
                    metricFormula.textContent = `
                    \\begin{aligned}
                    &= \\frac{\\text{TN}}{\\text{TN} + \\text{FP}} \\\\[12pt]
                    &= \\frac{${trueNegatives}}{${trueNegatives} + ${falsePositives}} \\\\[12pt]
                    &= ${tnr.toFixed(3)}
                    \\end{aligned}
                    `;
                    break;
                case 'fnr':
                    metricFormula.textContent = `
                    \\begin{aligned}
                    &= \\frac{\\text{FN}}{\\text{FN} + \\text{TP}} \\\\[12pt]
                    &= \\frac{${falseNegatives}}{${falseNegatives} + ${truePositives}} \\\\[12pt]
                    &= ${fnr.toFixed(3)}
                    \\end{aligned}
                    `;
                    break;
                case 'precision':
                    metricFormula.textContent = `
                    \\begin{aligned}
                    &= \\frac{\\text{TP}}{\\text{TP} + \\text{FP}} \\\\[12pt]
                    &= \\frac{${truePositives}}{${truePositives} + ${falsePositives}} \\\\[12pt]
                    &= ${precision.toFixed(3)}
                    \\end{aligned}
                    `;
                    break;
                case 'accuracy':
                    metricFormula.textContent = `
                    \\begin{aligned}
                    &= \\frac{\\text{TP} + \\text{TN}}{\\text{Total}} \\\\[12pt]
                    &= \\frac{${truePositives} + ${trueNegatives}}{${totalPoints}} \\\\[12pt]
                    &= ${accuracy.toFixed(3)}
                    \\end{aligned}
                    `;
                    break;
                case 'f1':
                    metricFormula.textContent = `
                    \\begin{aligned}
                    &= \\frac{2 \\times \\text{Precision} \\times \\text{Recall}}{\\text{Precision} + \\text{Recall}} \\\\[12pt]
                    &= \\frac{2 \\times ${precision.toFixed(3)} \\times ${tpr.toFixed(3)}}{${precision.toFixed(3)} + ${tpr.toFixed(3)}} \\\\[12pt]
                    &= ${f1.toFixed(3)}
                    \\end{aligned}
                    `;
                    break;
            }
            
            // Render formula with KaTeX
            renderKatex();
        }
        
        // Get formula template for a metric
        function getMetricFormula(metric, withZeros = false) {
            if (withZeros) {
                switch (metric) {
                    case 'recall':
                        return `
                        \\begin{aligned}
                        &\\frac{\\text{TP}}{\\text{TP} + \\text{FN}} \\\\[12pt]
                        &= \\frac{0}{0 + 0} \\\\[12pt]
                        &= 0
                        \\end{aligned}
                        `;
                    case 'fpr':
                        return `
                        \\begin{aligned}
                        &\\frac{\\text{FP}}{\\text{FP} + \\text{TN}} \\\\[12pt]
                        &= \\frac{0}{0 + 0} \\\\[12pt]
                        &= 0
                        \\end{aligned}
                        `;
                    case 'specificity':
                        return `
                        \\begin{aligned}
                        &\\frac{\\text{TN}}{\\text{TN} + \\text{FP}} \\\\[12pt]
                        &= \\frac{0}{0 + 0} \\\\[12pt]
                        &= 0
                        \\end{aligned}
                        `;
                    case 'fnr':
                        return `
                        \\begin{aligned}
                        &\\frac{\\text{FN}}{\\text{FN} + \\text{TP}} \\\\[12pt]
                        &= \\frac{0}{0 + 0} \\\\[12pt]
                        &= 0
                        \\end{aligned}
                        `;
                    case 'precision':
                        return `
                        \\begin{aligned}
                        &\\frac{\\text{TP}}{\\text{TP} + \\text{FP}} \\\\[12pt]
                        &= \\frac{0}{0 + 0} \\\\[12pt]
                        &= 0
                        \\end{aligned}
                        `;
                    case 'accuracy':
                        return `
                        \\begin{aligned}
                        &\\frac{\\text{TP} + \\text{TN}}{\\text{Total}} \\\\[12pt]
                        &= \\frac{0 + 0}{0} \\\\[12pt]
                        &= 0
                        \\end{aligned}
                        `;
                    case 'f1':
                        return `
                        \\begin{aligned}
                        &\\frac{2 \\times \\text{Precision} \\times \\text{Recall}}{\\text{Precision} + \\text{Recall}} \\\\[12pt]
                        &= \\frac{2 \\times 0 \\times 0}{0 + 0} \\\\[12pt]
                        &= 0
                        \\end{aligned}
                        `;
                }
            }
            return '';
        }
        
        // Render KaTeX formulas
        function renderKatex() {
            try {
                if (window.katex) {
                    katex.render(metricFormula.textContent, metricFormula, {
                        displayMode: true,
                        throwOnError: false,
                        output: "html",
                        trust: true    // Allow newline commands
                    });
                }
            } catch (error) {
                console.error("KaTeX rendering error:", error);
            }
        }
        
        // Setup metric buttons
        function setupMetricButtons() {
            const allButtons = [btnRecall, btnFPR, btnSpecificity, btnFNR, btnPrecision, btnAccuracy, btnF1];
            
            // Update button styles when a metric is selected
            function updateButtonStyles(selectedButton) {
                allButtons.forEach(btn => {
                    btn.classList.remove('active');
                });
                selectedButton.classList.add('active');
            }
            
            btnRecall.addEventListener('click', function() {
                currentMetric = 'recall';
                updateButtonStyles(btnRecall);
                metricTitle.textContent = 'Recall/Sensitivity (TPR):';
                updateMetricDisplay();
            });
            
            btnFPR.addEventListener('click', function() {
                currentMetric = 'fpr';
                updateButtonStyles(btnFPR);
                metricTitle.textContent = 'False Positive Rate (FPR):';
                updateMetricDisplay();
            });
            
            btnSpecificity.addEventListener('click', function() {
                currentMetric = 'specificity';
                updateButtonStyles(btnSpecificity);
                metricTitle.textContent = 'Specificity (TNR):';
                updateMetricDisplay();
            });
            
            btnFNR.addEventListener('click', function() {
                currentMetric = 'fnr';
                updateButtonStyles(btnFNR);
                metricTitle.textContent = 'False Negative Rate (FNR):';
                updateMetricDisplay();
            });
            
            btnPrecision.addEventListener('click', function() {
                currentMetric = 'precision';
                updateButtonStyles(btnPrecision);
                metricTitle.textContent = 'Precision (PPV):';
                updateMetricDisplay();
            });
            
            btnAccuracy.addEventListener('click', function() {
                currentMetric = 'accuracy';
                updateButtonStyles(btnAccuracy);
                metricTitle.textContent = 'Accuracy (ACC):';
                updateMetricDisplay();
            });
            
            btnF1.addEventListener('click', function() {
                currentMetric = 'f1';
                updateButtonStyles(btnF1);
                metricTitle.textContent = 'F1 Score:';
                updateMetricDisplay();
            });
        }
        
        // Mouse events for dragging the circle
        function setupDragEvents() {
            canvas.addEventListener('mousedown', function(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Check if click is near the circle center
                const dx = mouseX - centerX;
                const dy = mouseY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= circleRadius) {
                    isDragging = true;
                    dragStartPos = { x: mouseX, y: mouseY };
                    dragStartCenter = { x: circleCenter.x, y: circleCenter.y };
                    canvas.style.cursor = 'grabbing';
                }
            });
            
            canvas.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Calculate new center position
                const dx = (mouseX - dragStartPos.x) / canvas.width;
                const dy = (mouseY - dragStartPos.y) / canvas.height;
                
                circleCenter.x = Math.max(0.1, Math.min(0.9, dragStartCenter.x + dx));
                circleCenter.y = Math.max(0.1, Math.min(0.9, dragStartCenter.y + dy));
                
                calculateDimensions();
                redrawCanvas();
                recalculateMetrics();
                updateLabels();
            });
            
            canvas.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    canvas.style.cursor = 'move';
                }
            });
            
            canvas.addEventListener('mouseleave', function() {
                if (isDragging) {
                    isDragging = false;
                    canvas.style.cursor = 'move';
                }
            });
            
            // Set initial cursor
            canvas.style.cursor = 'move';
        }
        
        // Touch events for mobile
        function setupTouchEvents() {
            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                // Check if touch is near the circle center
                const dx = touchX - centerX;
                const dy = touchY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= circleRadius) {
                    isDragging = true;
                    dragStartPos = { x: touchX, y: touchY };
                    dragStartCenter = { x: circleCenter.x, y: circleCenter.y };
                }
            });
            
            canvas.addEventListener('touchmove', function(e) {
                if (!isDragging) return;
                e.preventDefault();
                
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                // Calculate new center position
                const dx = (touchX - dragStartPos.x) / canvas.width;
                const dy = (touchY - dragStartPos.y) / canvas.height;
                
                circleCenter.x = Math.max(0.1, Math.min(0.9, dragStartCenter.x + dx));
                circleCenter.y = Math.max(0.1, Math.min(0.9, dragStartCenter.y + dy));
                
                calculateDimensions();
                redrawCanvas();
                recalculateMetrics();
                updateLabels();
            });
            
            canvas.addEventListener('touchend', function(e) {
                e.preventDefault();
                isDragging = false;
            });
        }
        
        // Initialize
        window.addEventListener('load', function() {
            resizeCanvas();
            setupMetricButtons();
            setupDragEvents();
            setupTouchEvents();
            
            // Generate 5,000 points immediately
            generatePoints(10000);
            
            // Initial render
            redrawCanvas();
            updateLabels();
            updateMetricDisplay();
        });
        
        window.addEventListener('resize', function() {
            resizeCanvas();
        });
    </script>
</body>
</html>
<p>Ao interagir com a simulação<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>, você poderá observar alguns casos interessantes:</p>
<ul>
<li><strong>Precisão 50%</strong>: Ocorre quando o círculo está exatamente no centro.</li>
<li><strong>Baixo recall mas precisão de 100%</strong>: Um círculo pequeno está inteiramente no lado direito.</li>
<li><strong>Recall máximo com FPR máximo</strong>: O círculo cobre toda a área de simulação, e portanto o modelo classifica tudo como positivo. Obtemos apenas TP e FP; recall máximo, FPR máximo e nenhuma especificidade.</li>
<li><strong>Sem recall nem precisão</strong>: Se reduzirmos o tamanho do círculo a zero, o modelo classificará tudo como negativo, resultando em ausência de recall, precisão e FPR. Mesmo assim, temos uma acurácia de 50% e especificidade de 100%.</li>
<li><strong>O cenário ideal</strong>: Um grande círculo que tenta cobrir todo o lado direito e, ao mesmo tempo, possuir a menor área possível no lado esquerdo.</li>
</ul>
<p>Essa visualização interativa é útil porque permite relacionar conceitos abstratos com representações visuais concretas. Por exemplo, quando alguém diz que “o modelo tem alta precisão, mas baixo recall”, você pode visualizar isso como um círculo pequeno, posicionado quase totalmente no lado direito. Já no caso de “alta especificidade, mas baixa sensibilidade”, uma possível representação seria um círculo centralizado, dividido igualmente entre os dois lados.</p>
<h1 id="entendendo-a-curva-roc">Entendendo a curva ROC</h1>
<p>Modelos de classificação, como a regressão logística, geralmente não retornam apenas uma resposta binária (sim/não), mas sim uma probabilidade associada a cada classe. Ou seja, ao invés de dizer diretamente &ldquo;positivo&rdquo; ou &ldquo;negativo&rdquo;, o modelo indica quão confiante está de que determinada observação pertence à classe positiva — atribuindo um valor entre 0 e 1.</p>
<br>
<p>Para transformar essa probabilidade em uma decisão binária, é necessário definir um limiar (threshold). Por exemplo: se a probabilidade for maior que 0,5, classificamos como positivo; caso contrário, como negativo. Mas o que acontece se alterarmos esse valor de 0,5? Como o desempenho do modelo muda com diferentes limiares? É justamente aí que entra a <strong>curva ROC</strong><sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>. Em vez de avaliar o modelo com base em um único ponto de corte, a curva ROC mostra como o modelo equilibra acertos e erros à medida que o limiar varia. Para construí-la, plotamos TPR (eixo y) versus FPR (eixo x) para todos os limiares de 0 a 1.</p>
<br>
<h2 id="o-cenário-baseline">O cenário baseline</h2>
<p>Para entender melhor a curva ROC, vamos considerar a simulação anterior mas com um círculo estático que cresce exatamente do centro. Uma vez que os pontos estão uniformemente distribuidos no plano, para qualquer limiar, o modelo classifica corretamente os positivos (TPR) na mesma proporção que classifica incorretamente os negativos (FPR).</p>
<br>
<p>Quando plotamos a curva ROC para este modelo, obtemos uma reta diagonal do tipo $y = x$. Em outras palavras, se o modelo identifica 60% dos positivos corretamente, ele também classifica erroneamente 60% dos negativos como positivos. Varie o tamanho do círculo na simulação abaixo para observar esse comportamento.</p>
<br>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/contrib/auto-render.min.js"></script>
    <script>
        // Ensure KaTeX is fully loaded before page initialization
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof katex !== 'undefined') {
                console.log("KaTeX loaded successfully");
            } else {
                console.error("KaTeX failed to load");
            }
        });
    </script>
    <style>
        
        .roc_simulation-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .roc_control-panel {
            width: 100%;
            max-width: 80%;
            margin: 0 auto 20px;
        }
        
        .roc_slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
            position: relative;
            width: 100%;
            max-width: 350px;
        }
        
        .roc_slider-container label {
            font-weight: bold;
            min-width: 100px;
            color: #333;
            margin-bottom: 1px;
        }
        
        .roc_range-slider {
            width: 100%;
            position: relative;
        }
        
        .roc_range-slider-track {
            height: 8px;
            width: 100%;
            background-color: #ddd;
            border-radius: 4px;
            position: relative;
        }
        
        .roc_range-slider-fill {
            height: 100%;
            background-color: #3b82f6;
            border-radius: 4px;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            transition: width 0.1s ease;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: transparent;
            position: absolute;
            top: 0;
            left: 0;
            margin: 0;
            z-index: 10;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        .roc_slider-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #3b82f6;
            background-color: #f0f4ff;
            padding: 4px 8px;
            border-radius: 12px;
            margin-left: 10px;
            border: 1px solid #d1d5db;
        }
        
        .roc_flex-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 3%; /* Increased from 20px */
        }
        
        .roc_visualization-area {
            flex: 1;
            min-width: 300px;
        }
        
        .roc_roc-area {
            flex: 1;
            min-width: 300px;
        }
        
        .roc_canvas-container {
            position: relative;
            width: 100%;
            padding-bottom: 85%;
            border: 1px solid #ddd;
            overflow: hidden;
            background-color: white;
        }

        #roc_canvas, #roc_rocCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: move;
        }
        
        .roc_quadrant-label {
            position: absolute;
            white-space: nowrap;
            font-size: 17px;
            text-align: center;
            color: #fff;
            background-color: rgba(0, 0, 0, 1);
            padding: 1px 5px;
            border-radius: 10px;
            z-index: 10;
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        .roc_metrics-display {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f8f9fa;
        }
        
        .roc_metrics-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }
        
        .roc_metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .roc_metric-card {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
        }
        
        .roc_metric-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            color: #333;
        }
        
        .roc_metric-formula {
            text-align: center;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .roc_metric-value {
            text-align: center;
            font-weight: bold;
            font-size: 18px;
            color: #3b82f6;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .roc_flex-container {
                flex-direction: column;
            }
            
            .roc_metrics-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="roc_simulation-container">
        
        <div class="roc_control-panel">
            <div class="roc_slider-container">
                <label for="roc_circleSize">Tamanho do círculo</label>
                <div class="roc_range-slider">
                    <div class="roc_range-slider-track">
                        <div class="roc_range-slider-fill" id="roc_circleSizeFill"></div>
                    </div>
                    <input type="range" id="roc_circleSize" min="0" max="100" value="0" step="1">
                </div>
            </div>
        </div>
        
        <div class="roc_flex-container">
            <!-- Visualization Area -->
            <div class="roc_visualization-area">
                <div class="roc_canvas-container">
                    <canvas id="roc_canvas"></canvas>
                    <div id="roc_quadrant0" class="roc_quadrant-label">False<br>Positives</div>
                    <div id="roc_quadrant1" class="roc_quadrant-label">True<br>Positives</div>
                    <div id="roc_quadrant2" class="roc_quadrant-label">True<br>Negatives</div>
                    <div id="roc_quadrant3" class="roc_quadrant-label">False<br>Negatives</div>
                </div>
                
                <div style="display: flex; justify-content: space-between; width: 100%; font-weight: bold; margin-top: 5px;">
                    <span>Negatives</span>
                    <span>Positives</span>
                </div>
            </div>
            
            <!-- Right side: ROC Curve and Metrics -->
            <div class="roc_roc-area">
            <!-- ROC Curve with Y-axis labels -->
            <div style="display: flex; align-items: stretch; margin-bottom: 0px;">
                <!-- Y-axis labels -->
                <div style="display: flex; flex-direction: column; font-weight: bold; width: 40px; position: relative; height: 300px;">
                    <span style="position: absolute; top: 0; right: 0;">1.0</span>
                    <span style="position: absolute; writing-mode: vertical-rl; transform: rotate(180deg); left: 10px; top: 50%;">TPR</span>
                </div>
                
                <!-- ROC Curve canvas -->
                <div style="flex-grow: 1;">
                    <div class="roc_canvas-container" style="padding-bottom: 50%;">
                        <canvas id="roc_rocCanvas"></canvas>
                    </div>
                    
                    <!-- X-axis labels -->
                    <div style="display: flex; justify-content: space-between; width: 100%; font-weight: bold; margin: 5px 0 10px 0;">
                        <span>0.0</span>
                        <span style="text-align: center; flex-grow: 1;">FPR</span>
                        <span>1.0</span>
                    </div>
                </div>
                </div>
                
                <!-- Compact Metrics Display -->
                <div class="roc_metrics-display" style="margin-top: 0; padding: 10px;">
                    <div class="roc_metrics-grid" style="grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div class="roc_metric-card" style="padding: 8px;">
                            <div class="roc_metric-name" style="font-size: 20px; margin-bottom: 5px;text-align: center;">TPR (True Positive Rate)</div>
                            <div class="roc_metric-formula" id="roc_tprFormula" style="min-height: 50px; font-size: 18px;">Loading...</div>
                            <div class="roc_metric-value" id="roc_tprValue" style="margin-top: 5px; font-size: 22px;">= 0.000</div>
                        </div>
                        <div class="roc_metric-card" style="padding: 8px;">
                            <div class="roc_metric-name" style="font-size: 20px; margin-bottom: 5px;text-align: center;">FPR (False Positive Rate)</div>
                            <div class="roc_metric-formula" id="roc_fprFormula" style="min-height: 50px; font-size: 18px;">Loading...</div>
                            <div class="roc_metric-value" id="roc_fprValue" style="margin-top: 5px; font-size: 22px;">= 0.000</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Ensure KaTeX is loaded completely before page init -->
    <script>
        // Wait for all resources to load, including KaTeX
        window.addEventListener('load', function() {
            // Initialize simulation
            roc_init();
        });
        
        function roc_init() {
            // DOM Elements
            const roc_canvas = document.getElementById('roc_canvas');
            const roc_ctx = roc_canvas.getContext('2d');
            const roc_rocCanvas = document.getElementById('roc_rocCanvas');
            const roc_rocCtx = roc_rocCanvas.getContext('2d');
            const roc_circleSizeSlider = document.getElementById('roc_circleSize');
            const roc_circleSizeFill = document.getElementById('roc_circleSizeFill');
            const roc_sizeValue = document.getElementById('roc_sizeValue');
        
            // Quadrant labels
            const roc_quadrantLabels = [
                document.getElementById('roc_quadrant0'),
                document.getElementById('roc_quadrant1'),
                document.getElementById('roc_quadrant2'),
                document.getElementById('roc_quadrant3')
            ];
            
            // Metric displays
            const roc_tprFormula = document.getElementById('roc_tprFormula');
            const roc_tprValue = document.getElementById('roc_tprValue');
            const roc_fprFormula = document.getElementById('roc_fprFormula');
            const roc_fprValue = document.getElementById('roc_fprValue');
            
            // Variables
            let roc_isDragging = false;
            let roc_truePositives = 0;
            let roc_falsePositives = 0;
            let roc_trueNegatives = 0;
            let roc_falseNegatives = 0;
            let roc_totalPoints = 0;
            let roc_points = [];
            let roc_rocPoints = [];
            let roc_currentSize = 0; // Track current circle size
            
            // Circle properties
            let roc_circleRadius;
            let roc_centerX;
            let roc_centerY;
            let roc_circleCenter = { x: 0.5, y: 0.5 }; // Normalized position (0-1)
            let roc_circleSizePercent = 0; // Percentage of min dimension
            let roc_dragStartPos = { x: 0, y: 0 };
            let roc_dragStartCenter = { x: 0, y: 0 };
            
            // Update slider fill
            function roc_updateSliderFill() {
                const percent = (roc_circleSizeSlider.value - roc_circleSizeSlider.min) / (roc_circleSizeSlider.max - roc_circleSizeSlider.min) * 100;
                roc_circleSizeFill.style.width = percent + '%';
            }
            
            // Initial slider fill update
            roc_updateSliderFill();
            
            // Setup slider events for changing circle size only
            function roc_setupSliderEvents() {
                // Update slider fill and add event listener
                roc_updateSliderFill();
                
                roc_circleSizeSlider.addEventListener('input', function() {
                    // Store previous and current size for ROC curve updating
                    const prevSize = roc_circleSizePercent;
                    roc_circleSizePercent = parseInt(this.value);
                    roc_currentSize = roc_circleSizePercent;
                    
                    roc_updateSliderFill();
                    roc_calculateDimensions();
                    roc_redrawCanvas();
                    roc_recalculateMetrics();
                    roc_updateLabels();
                    
                    // Update ROC curve based on whether size increased or decreased
                    if (roc_circleSizePercent > prevSize) {
                        roc_addROCPoint();
                    } else if (roc_circleSizePercent < prevSize) {
                        roc_removeROCPointsAboveSize(roc_circleSizePercent);
                    }
                    
                    roc_drawROCCurve();
                });
            }
            
            // Resize canvas to fit container
            function roc_resizeCanvas() {
                const container = roc_canvas.parentElement;
                roc_canvas.width = container.clientWidth;
                roc_canvas.height = container.clientHeight;
                
                const rocContainer = roc_rocCanvas.parentElement;
                roc_rocCanvas.width = rocContainer.clientWidth;
                roc_rocCanvas.height = rocContainer.clientHeight;
                
                roc_calculateDimensions();
                roc_redrawCanvas();
                roc_drawROCCurve();
                roc_updateLabels();
            }
            
            // Calculate circle dimensions based on canvas size and current settings
            function roc_calculateDimensions() {
                // Fixed center position (prevent dragging)
                roc_centerX = roc_canvas.width * 0.5;
                roc_centerY = roc_canvas.height * 0.5;
                const minDimension = Math.min(roc_canvas.width, roc_canvas.height);
                roc_circleRadius = minDimension * (roc_circleSizePercent / 100);
            }
            
            // Generate points
            function roc_generatePoints(count) {
                roc_points = [];
                
                // Generate half the points on the left side and half on the right
                for (let i = 0; i < count / 2; i++) {
                    // Left side point (Negatives)
                    roc_points.push({
                        x: Math.random() * (roc_canvas.width / 2 - 5),
                        y: Math.random() * roc_canvas.height
                    });
                    
                    // Right side point (Positives)
                    roc_points.push({
                        x: (roc_canvas.width / 2 + 5) + Math.random() * (roc_canvas.width / 2 - 10),
                        y: Math.random() * roc_canvas.height
                    });
                }
                
                roc_recalculateMetrics();
            }
            
            // Update the class metrics based on the points
            function roc_recalculateMetrics() {
                // Reset counts
                roc_truePositives = 0;
                roc_falsePositives = 0;
                roc_trueNegatives = 0;
                roc_falseNegatives = 0;
                
                // Recalculate counts for each point
                roc_points.forEach(point => {
                    const isRight = point.x >= roc_canvas.width / 2;
                    const isPredictedPositive = roc_isInsideCircle(point.x, point.y);
                    
                    if (isRight && isPredictedPositive) roc_truePositives++;
                    else if (!isRight && isPredictedPositive) roc_falsePositives++;
                    else if (!isRight && !isPredictedPositive) roc_trueNegatives++;
                    else if (isRight && !isPredictedPositive) roc_falseNegatives++;
                });
                
                roc_totalPoints = roc_points.length;
                
                // Update the metric displays
                roc_updateMetricDisplay();
            }
            
            // Update metric display
            function roc_updateMetricDisplay() {
                // Calculate TPR and FPR
                const tpr = roc_truePositives / (roc_truePositives + roc_falseNegatives) || 0;
                const fpr = roc_falsePositives / (roc_falsePositives + roc_trueNegatives) || 0;
                
                // Update display values with equal sign
                roc_tprValue.textContent = "= " + tpr.toFixed(3);
                roc_fprValue.textContent = "= " + fpr.toFixed(3);
                
                // Properly format the equations for KaTeX
                const tprFormulaText = `\\frac{TP}{TP + FN} = \\frac{${roc_truePositives}}{${roc_truePositives} + ${roc_falseNegatives}}`;
                const fprFormulaText = `\\frac{FP}{FP + TN} = \\frac{${roc_falsePositives}}{${roc_falsePositives} + ${roc_trueNegatives}}`;
                
                // Set the text content for later rendering
                roc_tprFormula.setAttribute('data-formula', tprFormulaText);
                roc_fprFormula.setAttribute('data-formula', fprFormulaText);
                
                // Render with KaTeX
                roc_renderFormulas();
            }
            
            // Properly format the equations for KaTeX with larger font
            function roc_renderFormulas() {
                try {
                    if (typeof katex !== 'undefined') {
                        const tprFormulaText = roc_tprFormula.getAttribute('data-formula');
                        const fprFormulaText = roc_fprFormula.getAttribute('data-formula');
                        
                        katex.render(tprFormulaText, roc_tprFormula, {
                            displayMode: true,
                            throwOnError: false,
                            fontSize: '1.2em' // Larger font size
                        });
                        
                        katex.render(fprFormulaText, roc_fprFormula, {
                            displayMode: true,
                            throwOnError: false,
                            fontSize: '1.2em' // Larger font size
                        });
                    } else {
                        console.error("KaTeX not available for rendering");
                        // Fallback to plain text if rendering fails
                        roc_tprFormula.textContent = roc_tprFormula.getAttribute('data-formula');
                        roc_fprFormula.textContent = roc_fprFormula.getAttribute('data-formula');
                    }
                } catch (error) {
                    console.error("KaTeX rendering error:", error);
                }
            }
            
            // Draw all points
            function roc_drawPoints() {
                roc_points.forEach(point => {
                    const isRight = point.x >= roc_canvas.width / 2;
                    
                    // Choose color based on actual class (left/right side)
                    if (isRight) {
                        roc_ctx.fillStyle = 'blue'; // Actual Positive (right side)
                    } else {
                        roc_ctx.fillStyle = 'red'; // Actual Negative (left side)
                    }
                    
                    roc_ctx.beginPath();
                    roc_ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                    roc_ctx.fill();
                });
            }
            
            // Redraw canvas with all points and current circle position
            function roc_redrawCanvas() {
                roc_ctx.clearRect(0, 0, roc_canvas.width, roc_canvas.height);
                
                // Draw points
                roc_drawPoints();
                
                // Draw dividing line
                roc_ctx.beginPath();
                roc_ctx.moveTo(roc_canvas.width / 2, 0);
                roc_ctx.lineTo(roc_canvas.width / 2, roc_canvas.height);
                roc_ctx.strokeStyle = 'black';
                roc_ctx.lineWidth = 2;
                roc_ctx.stroke();
                
                // Draw circle
                roc_ctx.beginPath();
                roc_ctx.arc(roc_centerX, roc_centerY, roc_circleRadius, 0, Math.PI * 2);
                roc_ctx.fillStyle = 'rgba(0, 0, 255, 0.15)';
                roc_ctx.fill();
                roc_ctx.strokeStyle = 'black'; // Changed to black for better visibility
                roc_ctx.lineWidth = 3;
                roc_ctx.stroke();
                
                // Draw border
                roc_ctx.strokeStyle = '#ddd';
                roc_ctx.lineWidth = 1;
                roc_ctx.strokeRect(0, 0, roc_canvas.width, roc_canvas.height);
            }
            
            // Draw the ROC curve
            function roc_drawROCCurve() {
                roc_rocCtx.clearRect(0, 0, roc_rocCanvas.width, roc_rocCanvas.height);
                
                            // Draw axes
            roc_rocCtx.beginPath();
            // Y-axis (left)
            roc_rocCtx.moveTo(0, roc_rocCanvas.height);
            roc_rocCtx.lineTo(0, 0);
            // X-axis (bottom)
            roc_rocCtx.moveTo(0, roc_rocCanvas.height);
            roc_rocCtx.lineTo(roc_rocCanvas.width, roc_rocCanvas.height);
            roc_rocCtx.stroke();

            // Y-axis label
            roc_rocCtx.save();
            roc_rocCtx.translate(20, roc_rocCanvas.height/2); // Adjust left position
            roc_rocCtx.rotate(-Math.PI/2);
            roc_rocCtx.restore();

            // Y-ticks (only 0 and 1)
            [0, 1].forEach(t => {
                const y = roc_rocCanvas.height - (t * roc_rocCanvas.height);
                // Tick
                roc_rocCtx.beginPath();
                roc_rocCtx.moveTo(0, y);
                roc_rocCtx.lineTo(5, y);
                roc_rocCtx.stroke();
                // Label
                roc_rocCtx.textAlign = "right";
                roc_rocCtx.fillText(t.toFixed(0), -8, y + 4);
            });

            // X-ticks (only 0 and 1)
            [0, 1].forEach(t => {
                const x = t * roc_rocCanvas.width;
                // Tick
                roc_rocCtx.beginPath();
                roc_rocCtx.moveTo(x, roc_rocCanvas.height);
                roc_rocCtx.lineTo(x, roc_rocCanvas.height - 5);
                roc_rocCtx.stroke();
                // Label
                roc_rocCtx.textAlign = "center";
                roc_rocCtx.fillText(t.toFixed(0), x, roc_rocCanvas.height + 20);
            });

            // X-axis label
                // Draw reference line (random classifier)
                roc_rocCtx.beginPath();
                roc_rocCtx.moveTo(0, roc_rocCanvas.height);
                roc_rocCtx.lineTo(roc_rocCanvas.width, 0);
                roc_rocCtx.strokeStyle = 'gray';
                roc_rocCtx.lineWidth = 1;
                roc_rocCtx.setLineDash([5, 5]);
                roc_rocCtx.stroke();
                roc_rocCtx.setLineDash([]);
                
                // Draw ROC curve points if we have any
                if (roc_rocPoints.length > 0) {
                    // Only draw line if there are multiple points (after user has moved the slider)
                    if (roc_rocPoints.length > 1) {
                        // Draw the curve connecting the points
                        roc_rocCtx.beginPath();
                        roc_rocCtx.moveTo(0, roc_rocCanvas.height); // Start at origin (0,1)
                        
                        // Sort points to ensure proper curve
                        const sortedPoints = [...roc_rocPoints].sort((a, b) => a.fpr - b.fpr);
                        
                        sortedPoints.forEach(point => {
                            const x = point.fpr * roc_rocCanvas.width;
                            const y = roc_rocCanvas.height - (point.tpr * roc_rocCanvas.height);
                            roc_rocCtx.lineTo(x, y);
                        });
                        
                        roc_rocCtx.strokeStyle = 'gray'; // Changed from blue to gray
                        roc_rocCtx.lineWidth = 2;
                        roc_rocCtx.stroke();
                        
                        // Draw points
                        sortedPoints.forEach(point => {
                            const x = point.fpr * roc_rocCanvas.width;
                            const y = roc_rocCanvas.height - (point.tpr * roc_rocCanvas.height);
                            
                            roc_rocCtx.beginPath();
                            roc_rocCtx.arc(x, y, 3, 0, Math.PI * 2);
                            roc_rocCtx.fillStyle = 'gray'; // Changed from blue to gray
                            roc_rocCtx.fill();
                        });
                    }
                    
                    // Draw current operating point
                    const tpr = roc_truePositives / (roc_truePositives + roc_falseNegatives) || 0;
                    const fpr = roc_falsePositives / (roc_falsePositives + roc_trueNegatives) || 0;
                    
                    const currentX = fpr * roc_rocCanvas.width;
                    const currentY = roc_rocCanvas.height - (tpr * roc_rocCanvas.height);
                    
                    roc_rocCtx.beginPath();
                    roc_rocCtx.arc(currentX, currentY, 6, 0, Math.PI * 2);
                    roc_rocCtx.fillStyle = 'gray'; // Changed from red to gray
                    roc_rocCtx.fill();
                    roc_rocCtx.strokeStyle = 'black';
                    roc_rocCtx.lineWidth = 1;
                    roc_rocCtx.stroke();
                }
            }
            
            // Add a new ROC point for current size
            function roc_addROCPoint() {
                const tpr = roc_truePositives / (roc_truePositives + roc_falseNegatives) || 0;
                const fpr = roc_falsePositives / (roc_falsePositives + roc_trueNegatives) || 0;
                
                // Check if we already have a point with the exact same size
                const existingPoint = roc_rocPoints.find(p => p.size === roc_circleSizePercent);
                
                if (existingPoint) {
                    // Update existing point
                    existingPoint.tpr = tpr;
                    existingPoint.fpr = fpr;
                } else {
                    // Add new point
                    roc_rocPoints.push({
                        tpr,
                        fpr,
                        size: roc_circleSizePercent
                    });
                }
                
                // Sort points by size
                roc_rocPoints.sort((a, b) => a.size - b.size);
            }
            
            // Remove ROC points above a certain size
            function roc_removeROCPointsAboveSize(size) {
                roc_rocPoints = roc_rocPoints.filter(point => point.size <= size);
            }
            
            // Update quadrant labels dynamically based on circle position
            function roc_updateLabels() {
                // Get vertical dividing line position
                const midX = roc_canvas.width / 2;
                
                // Check if circle overlaps with left or right half
                const leftEdge = roc_centerX - roc_circleRadius;
                const rightEdge = roc_centerX + roc_circleRadius;
                const topEdge = roc_centerY - roc_circleRadius;
                const bottomEdge = roc_centerY + roc_circleRadius;
                const overlapsLeft = leftEdge < midX;
                const overlapsRight = rightEdge > midX;
                
                // Padding to ensure labels stay within canvas
                const padding = 20;
                const labelWidth = 70;
                const labelHeight = 40;
                
                // 1. False Positives (inside circle, left side)
                if (overlapsLeft && roc_falsePositives > 0) {
                    const fpX = Math.max(padding, Math.min(midX - labelWidth - padding, roc_centerX - roc_circleRadius / 2));
                    const fpY = roc_centerY;
                    roc_quadrantLabels[0].style.display = 'block';
                    roc_quadrantLabels[0].style.left = fpX + 'px';
                    roc_quadrantLabels[0].style.top = fpY + 'px';
                } else {
                    roc_quadrantLabels[0].style.display = 'none';
                }
                
                // 2. True Positives (inside circle, right side)
                if (overlapsRight && roc_truePositives > 0) {
                    const tpX = Math.min(roc_canvas.width - labelWidth - padding, Math.max(midX + padding, roc_centerX + roc_circleRadius / 3));
                    const tpY = roc_centerY;
                    roc_quadrantLabels[1].style.display = 'block';
                    roc_quadrantLabels[1].style.left = tpX + 'px';
                    roc_quadrantLabels[1].style.top = tpY + 'px';
                } else {
                    roc_quadrantLabels[1].style.display = 'none';
                }
                
                // 3. True Negatives (outside circle, left side)
                // Only show if there's sufficient space between the circle and the edge
                const safeDistanceFromCircle = 50; // Minimum distance needed
                const distanceLeftEdge = leftEdge;
                
                if (roc_trueNegatives > 0 && distanceLeftEdge > safeDistanceFromCircle) {
                    const tnX = padding;
                    const tnY = padding;
                    roc_quadrantLabels[2].style.display = 'block';
                    roc_quadrantLabels[2].style.left = tnX + 'px';
                    roc_quadrantLabels[2].style.top = tnY + 'px';
                } else {
                    // Hide when circle gets too close
                    roc_quadrantLabels[2].style.display = 'none';
                }
                
                // 4. False Negatives (outside circle, right side)
                // Only show if there's sufficient space between the circle and right edge
                const distanceRightEdge = roc_canvas.width - rightEdge;
                
                if (roc_falseNegatives > 0 && distanceRightEdge > safeDistanceFromCircle) {
                    const fnX = roc_canvas.width - labelWidth - padding;
                    const fnY = padding;
                    roc_quadrantLabels[3].style.display = 'block';
                    roc_quadrantLabels[3].style.left = fnX + 'px';
                    roc_quadrantLabels[3].style.top = fnY + 'px';
                } else {
                    // Hide when circle gets too close
                    roc_quadrantLabels[3].style.display = 'none';
                }
            }
            
            // Check if a point is inside the circle
            function roc_isInsideCircle(x, y) {
                const dx = x - roc_centerX;
                const dy = y - roc_centerY;
                return (dx * dx + dy * dy) <= (roc_circleRadius * roc_circleRadius);
            }
            
            // Calculate distance from a point to the circle
            function roc_distanceToCircle(x, y) {
                const dx = x - roc_centerX;
                const dy = y - roc_centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return Math.max(0, distance - roc_circleRadius);
            }
            
            // Initialize the first ROC point for the starting size
            function roc_initROCPoint() {
                roc_rocPoints = [];
                roc_addROCPoint();
            }
            
            // Mouse events for dragging the circle
            function roc_setupDragEvents() {
                roc_canvas.addEventListener('mousedown', function(e) {
                    const rect = roc_canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Check if click is near the circle center
                    const dx = mouseX - roc_centerX;
                    const dy = mouseY - roc_centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= roc_circleRadius) {
                        roc_isDragging = true;
                        roc_dragStartPos = { x: mouseX, y: mouseY };
                        roc_dragStartCenter = { x: roc_circleCenter.x, y: roc_circleCenter.y };
                        roc_canvas.style.cursor = 'grabbing';
                    }
                });
                
                roc_canvas.addEventListener('mousemove', function(e) {
                    if (!roc_isDragging) return;
                    
                    const rect = roc_canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Calculate new center position
                    const dx = (mouseX - roc_dragStartPos.x) / roc_canvas.width;
                    const dy = (mouseY - roc_dragStartPos.y) / roc_canvas.height;
                    
                    roc_circleCenter.x = Math.max(0.1, Math.min(0.9, roc_dragStartCenter.x + dx));
                    roc_circleCenter.y = Math.max(0.1, Math.min(0.9, roc_dragStartCenter.y + dy));
                    
                    roc_calculateDimensions();
                    roc_redrawCanvas();
                    roc_recalculateMetrics();
                    roc_updateLabels();
                    roc_updateROCCurve();
                });
                
                roc_canvas.addEventListener('mouseup', function() {
                    if (roc_isDragging) {
                        roc_isDragging = false;
                        roc_canvas.style.cursor = 'move';
                    }
                });
                
                roc_canvas.addEventListener('mouseleave', function() {
                    if (roc_isDragging) {
                        roc_isDragging = false;
                        roc_canvas.style.cursor = 'move';
                    }
                });
                
                // Set initial cursor
                roc_canvas.style.cursor = 'move';
            }
            
            // Touch events for mobile
            function roc_setupTouchEvents() {
                roc_canvas.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    const rect = roc_canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    
                    // Check if touch is near the circle center
                    const dx = touchX - roc_centerX;
                    const dy = touchY - roc_centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= roc_circleRadius) {
                        roc_isDragging = true;
                        roc_dragStartPos = { x: touchX, y: touchY };
                        roc_dragStartCenter = { x: roc_circleCenter.x, y: roc_circleCenter.y };
                    }
                });
                
                roc_canvas.addEventListener('touchmove', function(e) {
                    if (!roc_isDragging) return;
                    e.preventDefault();
                    
                    const rect = roc_canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    
                    // Calculate new center position
                    const dx = (touchX - roc_dragStartPos.x) / roc_canvas.width;
                    const dy = (touchY - roc_dragStartPos.y) / roc_canvas.height;
                    
                    roc_circleCenter.x = Math.max(0.1, Math.min(0.9, roc_dragStartCenter.x + dx));
                    roc_circleCenter.y = Math.max(0.1, Math.min(0.9, roc_dragStartCenter.y + dy));
                    
                    roc_calculateDimensions();
                    roc_redrawCanvas();
                    roc_recalculateMetrics();
                    roc_updateLabels();
                    roc_updateROCCurve();
                });
                
                roc_canvas.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    roc_isDragging = false;
                });
            }
            
            // Set canvas dimensions
            roc_resizeCanvas();
            
            // Setup events
            roc_setupSliderEvents();
            roc_setupTouchEvents(); // Simple touch events for slider only
            
            // Generate many more points
            roc_generatePoints(10000);
            
            // Initial calculations and rendering
            roc_calculateDimensions();
            roc_recalculateMetrics();
            roc_redrawCanvas();
            roc_updateLabels();
            
            // Initialize the ROC point for current size
            roc_initROCPoint();
            
            // Draw ROC curve
            roc_drawROCCurve();
            
            // Render formulas
            roc_renderFormulas();
            
            // Handle window resize
            window.addEventListener('resize', function() {
                roc_resizeCanvas();
                roc_redrawCanvas();
                roc_drawROCCurve();
                roc_updateLabels();
            });
        }
    </script>
</body>
</html>
<br>
<p>Isso seria equivalente a um modelo que faz previsões aleatórias, como jogar uma moeda para decidir entre positivo e negativo. Ou seja, um modelo sem poder preditivo. Agora vamos passar para um modelo um pouco melhor.</p>
<br>
<h2 id="um-modelo-melhor-que-o-baseline">Um modelo melhor que o baseline</h2>
<p>Um bom modelo de classificação consegue obter uma sensibilidade alta sem produzir muitos falsos positivos. Utilizando a mesma simulação, uma possibilidade seria um círculo (modelo) que cresce com início inteiramente no lado direito (captando mais positivos inicialmente).</p>
<br>
<p>Após certa medida, no entanto, ele começa a captar parte do lado esquerdo, gerando falsos positivos. Quando plotamos a curva ROC nesse caso, obtemos uma curva que se arqueia para o canto superior esquerdo do gráfico<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>. Aumente o tamanho do círculo na visualização abaixo e observe o que acontece.</p>
<br>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/contrib/auto-render.min.js"></script>
    <script>
        // Ensure KaTeX is fully loaded before page initialization
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof katex !== 'undefined') {
                console.log("KaTeX loaded successfully");
            } else {
                console.error("KaTeX failed to load");
            }
        });
    </script>
    <style>
        
        .roc2_simulation-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .roc2_control-panel {
            width: 100%;
            max-width: 80%;
            margin: 0 auto 20px;
        }
        
        .roc2_slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
            position: relative;
            width: 100%;
            max-width: 350px;
        }
        
        .roc2_slider-container label {
            font-weight: bold;
            min-width: 100px;
            color: #333;
            margin-bottom: 1px;
        }
        
        .roc2_range-slider {
            width: 100%;
            position: relative;
        }
        
        .roc2_range-slider-track {
            height: 8px;
            width: 100%;
            background-color: #ddd;
            border-radius: 4px;
            position: relative;
        }
        
        .roc2_range-slider-fill {
            height: 100%;
            background-color: #3b82f6;
            border-radius: 4px;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            transition: width 0.1s ease;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: transparent;
            position: absolute;
            top: 0;
            left: 0;
            margin: 0;
            z-index: 10;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        .roc2_slider-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #3b82f6;
            background-color: #f0f4ff;
            padding: 4px 8px;
            border-radius: 12px;
            margin-left: 10px;
            border: 1px solid #d1d5db;
        }
        
        .roc2_flex-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 3%; /* Increased from 20px */
        }
        
        .roc2_visualization-area {
            flex: 1;
            min-width: 300px;
        }
        
        .roc2_roc-area {
            flex: 1;
            min-width: 300px;
        }
        
        .roc2_canvas-container {
            position: relative;
            width: 100%;
            padding-bottom: 85%;
            border: 1px solid #ddd;
            overflow: hidden;
            background-color: white;
        }

        #roc2_canvas, #roc2_rocCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: move;
        }
        
        .roc2_quadrant-label {
            position: absolute;
            white-space: nowrap;
            font-size: 17px;
            text-align: center;
            color: #fff;
            background-color: rgba(0, 0, 0, 1);
            padding: 1px 5px;
            border-radius: 10px;
            z-index: 10;
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        .roc2_metrics-display {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f8f9fa;
        }
        
        .roc2_metrics-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }
        
        .roc2_metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .roc2_metric-card {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
        }
        
        .roc2_metric-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            color: #333;
        }
        
        .roc2_metric-formula {
            text-align: center;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .roc2_metric-value {
            text-align: center;
            font-weight: bold;
            font-size: 18px;
            color: #3b82f6;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .roc2_flex-container {
                flex-direction: column;
            }
            
            .roc2_metrics-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="roc2_simulation-container">
        
        <div class="roc2_control-panel">
            <div class="roc2_slider-container">
                <label for="roc2_circleSize">Tamanho do círculo</label>
                <div class="roc2_range-slider">
                    <div class="roc2_range-slider-track">
                        <div class="roc2_range-slider-fill" id="roc2_circleSizeFill"></div>
                    </div>
                    <input type="range" id="roc2_circleSize" min="0" max="100" value="0" step="1">
                </div>
            </div>
        </div>
        
        <div class="roc2_flex-container">
            <!-- Visualization Area -->
            <div class="roc2_visualization-area">
                <div class="roc2_canvas-container">
                    <canvas id="roc2_canvas"></canvas>
                    <div id="roc2_quadrant0" class="roc2_quadrant-label">False<br>Positives</div>
                    <div id="roc2_quadrant1" class="roc2_quadrant-label">True<br>Positives</div>
                    <div id="roc2_quadrant2" class="roc2_quadrant-label">True<br>Negatives</div>
                    <div id="roc2_quadrant3" class="roc2_quadrant-label">False<br>Negatives</div>
                </div>
                
                <div style="display: flex; justify-content: space-between; width: 100%; font-weight: bold; margin-top: 5px;">
                    <span>Negatives</span>
                    <span>Positives</span>
                </div>
            </div>
            
            <!-- Right side: ROC Curve and Metrics -->
            <div class="roc2_roc-area">
            <!-- ROC Curve with Y-axis labels -->
            <div style="display: flex; align-items: stretch; margin-bottom: 0px;">
                <!-- Y-axis labels -->
                <div style="display: flex; flex-direction: column; font-weight: bold; width: 40px; position: relative; height: 300px;">
                    <span style="position: absolute; top: 0; right: 0;">1.0</span>
                    <span style="position: absolute; writing-mode: vertical-rl; transform: rotate(180deg); left: 10px; top: 50%;">TPR</span>
                </div>
                
                <!-- ROC Curve canvas -->
                <div style="flex-grow: 1;">
                    <div class="roc2_canvas-container" style="padding-bottom: 50%;">
                        <canvas id="roc2_rocCanvas"></canvas>
                    </div>
                    
                    <!-- X-axis labels -->
                    <div style="display: flex; justify-content: space-between; width: 100%; font-weight: bold; margin: 5px 0 10px 0;">
                        <span>0.0</span>
                        <span style="text-align: center; flex-grow: 1;">FPR</span>
                        <span>1.0</span>
                    </div>
                </div>
                </div>
                
                <!-- Compact Metrics Display -->
                <div class="roc2_metrics-display" style="margin-top: 0; padding: 10px;">
                    <div class="roc2_metrics-grid" style="grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div class="roc2_metric-card" style="padding: 8px;">
                            <div class="roc2_metric-name" style="font-size: 20px; margin-bottom: 5px;text-align: center;">TPR (True Positive Rate)</div>
                            <div class="roc2_metric-formula" id="roc2_tprFormula" style="min-height: 50px; font-size: 18px;">Loading...</div>
                            <div class="roc2_metric-value" id="roc2_tprValue" style="margin-top: 5px; font-size: 22px;">= 0.000</div>
                        </div>
                        <div class="roc2_metric-card" style="padding: 8px;">
                            <div class="roc2_metric-name" style="font-size: 20px; margin-bottom: 5px;text-align: center;">FPR (False Positive Rate)</div>
                            <div class="roc2_metric-formula" id="roc2_fprFormula" style="min-height: 50px; font-size: 18px;">Loading...</div>
                            <div class="roc2_metric-value" id="roc2_fprValue" style="margin-top: 5px; font-size: 22px;">= 0.000</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Ensure KaTeX is loaded completely before page init -->
    <script>
        // Wait for all resources to load, including KaTeX
        window.addEventListener('load', function() {
            // Initialize simulation
            roc2_init();
        });
        
        function roc2_init() {
            // DOM Elements
            const roc2_canvas = document.getElementById('roc2_canvas');
            const roc2_ctx = roc2_canvas.getContext('2d');
            const roc2_rocCanvas = document.getElementById('roc2_rocCanvas');
            const roc2_rocCtx = roc2_rocCanvas.getContext('2d');
            const roc2_circleSizeSlider = document.getElementById('roc2_circleSize');
            const roc2_circleSizeFill = document.getElementById('roc2_circleSizeFill');
            const roc2_sizeValue = document.getElementById('roc2_sizeValue');
        
            // Quadrant labels
            const roc2_quadrantLabels = [
                document.getElementById('roc2_quadrant0'),
                document.getElementById('roc2_quadrant1'),
                document.getElementById('roc2_quadrant2'),
                document.getElementById('roc2_quadrant3')
            ];
            
            // Metric displays
            const roc2_tprFormula = document.getElementById('roc2_tprFormula');
            const roc2_tprValue = document.getElementById('roc2_tprValue');
            const roc2_fprFormula = document.getElementById('roc2_fprFormula');
            const roc2_fprValue = document.getElementById('roc2_fprValue');
            
            // Variables
            let roc2_isDragging = false;
            let roc2_truePositives = 0;
            let roc2_falsePositives = 0;
            let roc2_trueNegatives = 0;
            let roc2_falseNegatives = 0;
            let roc2_totalPoints = 0;
            let roc2_points = [];
            let roc2_rocPoints = [];
            let roc2_currentSize = 0; // Track current circle size
            
            // Circle properties
            let roc2_circleRadius;
            let roc2_centerX;
            let roc2_centerY;
            let roc2_circleCenter = { x: 0.65, y: 0.5 }; // Normalized position (0-1) - CHANGED X FROM 0.5 TO 0.65
            let roc2_circleSizePercent = 0; // Percentage of min dimension
            let roc2_dragStartPos = { x: 0, y: 0 };
            let roc2_dragStartCenter = { x: 0, y: 0 };
            
            // Update slider fill
            function roc2_updateSliderFill() {
                const percent = (roc2_circleSizeSlider.value - roc2_circleSizeSlider.min) / (roc2_circleSizeSlider.max - roc2_circleSizeSlider.min) * 100;
                roc2_circleSizeFill.style.width = percent + '%';
            }
            
            // Initial slider fill update
            roc2_updateSliderFill();
            
            // Setup slider events for changing circle size only
            function roc2_setupSliderEvents() {
                // Update slider fill and add event listener
                roc2_updateSliderFill();
                
                roc2_circleSizeSlider.addEventListener('input', function() {
                    // Store previous and current size for ROC curve updating
                    const prevSize = roc2_circleSizePercent;
                    roc2_circleSizePercent = parseInt(this.value);
                    roc2_currentSize = roc2_circleSizePercent;
                    
                    roc2_updateSliderFill();
                    roc2_calculateDimensions();
                    roc2_redrawCanvas();
                    roc2_recalculateMetrics();
                    roc2_updateLabels();
                    
                    // Update ROC curve based on whether size increased or decreased
                    if (roc2_circleSizePercent > prevSize) {
                        roc2_addROCPoint();
                    } else if (roc2_circleSizePercent < prevSize) {
                        roc2_removeROCPointsAboveSize(roc2_circleSizePercent);
                    }
                    
                    roc2_drawROCCurve();
                });
            }
            
            // Resize canvas to fit container
            function roc2_resizeCanvas() {
                const container = roc2_canvas.parentElement;
                roc2_canvas.width = container.clientWidth;
                roc2_canvas.height = container.clientHeight;
                
                const rocContainer = roc2_rocCanvas.parentElement;
                roc2_rocCanvas.width = rocContainer.clientWidth;
                roc2_rocCanvas.height = rocContainer.clientHeight;
                
                roc2_calculateDimensions();
                roc2_redrawCanvas();
                roc2_drawROCCurve();
                roc2_updateLabels();
            }
            
            // Calculate circle dimensions based on canvas size and current settings
            function roc2_calculateDimensions() {
                // Fixed center position (prevent dragging)
                roc2_centerX = roc2_canvas.width * roc2_circleCenter.x;
                roc2_centerY = roc2_canvas.height * roc2_circleCenter.y;
                const minDimension = Math.min(roc2_canvas.width, roc2_canvas.height);
                roc2_circleRadius = minDimension * (roc2_circleSizePercent / 100);
            }
            
            // Generate points
            function roc2_generatePoints(count) {
                roc2_points = [];
                
                // Generate half the points on the left side and half on the right
                for (let i = 0; i < count / 2; i++) {
                    // Left side point (Negatives)
                    roc2_points.push({
                        x: Math.random() * (roc2_canvas.width / 2 - 5),
                        y: Math.random() * roc2_canvas.height
                    });
                    
                    // Right side point (Positives)
                    roc2_points.push({
                        x: (roc2_canvas.width / 2 + 5) + Math.random() * (roc2_canvas.width / 2 - 10),
                        y: Math.random() * roc2_canvas.height
                    });
                }
                
                roc2_recalculateMetrics();
            }
            
            // Update the class metrics based on the points
            function roc2_recalculateMetrics() {
                // Reset counts
                roc2_truePositives = 0;
                roc2_falsePositives = 0;
                roc2_trueNegatives = 0;
                roc2_falseNegatives = 0;
                
                // Recalculate counts for each point
                roc2_points.forEach(point => {
                    const isRight = point.x >= roc2_canvas.width / 2;
                    const isPredictedPositive = roc2_isInsideCircle(point.x, point.y);
                    
                    if (isRight && isPredictedPositive) roc2_truePositives++;
                    else if (!isRight && isPredictedPositive) roc2_falsePositives++;
                    else if (!isRight && !isPredictedPositive) roc2_trueNegatives++;
                    else if (isRight && !isPredictedPositive) roc2_falseNegatives++;
                });
                
                roc2_totalPoints = roc2_points.length;
                
                // Update the metric displays
                roc2_updateMetricDisplay();
            }
            
            // Update metric display
            function roc2_updateMetricDisplay() {
                // Calculate TPR and FPR
                const tpr = roc2_truePositives / (roc2_truePositives + roc2_falseNegatives) || 0;
                const fpr = roc2_falsePositives / (roc2_falsePositives + roc2_trueNegatives) || 0;
                
                // Update display values with equal sign
                roc2_tprValue.textContent = "= " + tpr.toFixed(3);
                roc2_fprValue.textContent = "= " + fpr.toFixed(3);
                
                // Properly format the equations for KaTeX
                const tprFormulaText = `\\frac{TP}{TP + FN} = \\frac{${roc2_truePositives}}{${roc2_truePositives} + ${roc2_falseNegatives}}`;
                const fprFormulaText = `\\frac{FP}{FP + TN} = \\frac{${roc2_falsePositives}}{${roc2_falsePositives} + ${roc2_trueNegatives}}`;
                
                // Set the text content for later rendering
                roc2_tprFormula.setAttribute('data-formula', tprFormulaText);
                roc2_fprFormula.setAttribute('data-formula', fprFormulaText);
                
                // Render with KaTeX
                roc2_renderFormulas();
            }
            
            // Properly format the equations for KaTeX with larger font
            function roc2_renderFormulas() {
                try {
                    if (typeof katex !== 'undefined') {
                        const tprFormulaText = roc2_tprFormula.getAttribute('data-formula');
                        const fprFormulaText = roc2_fprFormula.getAttribute('data-formula');
                        
                        katex.render(tprFormulaText, roc2_tprFormula, {
                            displayMode: true,
                            throwOnError: false,
                            fontSize: '1.2em' // Larger font size
                        });
                        
                        katex.render(fprFormulaText, roc2_fprFormula, {
                            displayMode: true,
                            throwOnError: false,
                            fontSize: '1.2em' // Larger font size
                        });
                    } else {
                        console.error("KaTeX not available for rendering");
                        // Fallback to plain text if rendering fails
                        roc2_tprFormula.textContent = roc2_tprFormula.getAttribute('data-formula');
                        roc2_fprFormula.textContent = roc2_fprFormula.getAttribute('data-formula');
                    }
                } catch (error) {
                    console.error("KaTeX rendering error:", error);
                }
            }
            
            // Draw all points
            function roc2_drawPoints() {
                roc2_points.forEach(point => {
                    const isRight = point.x >= roc2_canvas.width / 2;
                    
                    // Choose color based on actual class (left/right side)
                    if (isRight) {
                        roc2_ctx.fillStyle = 'blue'; // Actual Positive (right side)
                    } else {
                        roc2_ctx.fillStyle = 'red'; // Actual Negative (left side)
                    }
                    
                    roc2_ctx.beginPath();
                    roc2_ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                    roc2_ctx.fill();
                });
            }
            
            // Redraw canvas with all points and current circle position
            function roc2_redrawCanvas() {
                roc2_ctx.clearRect(0, 0, roc2_canvas.width, roc2_canvas.height);
                
                // Draw points
                roc2_drawPoints();
                
                // Draw dividing line
                roc2_ctx.beginPath();
                roc2_ctx.moveTo(roc2_canvas.width / 2, 0);
                roc2_ctx.lineTo(roc2_canvas.width / 2, roc2_canvas.height);
                roc2_ctx.strokeStyle = 'black';
                roc2_ctx.lineWidth = 2;
                roc2_ctx.stroke();
                
                // Draw circle
                roc2_ctx.beginPath();
                roc2_ctx.arc(roc2_centerX, roc2_centerY, roc2_circleRadius, 0, Math.PI * 2);
                roc2_ctx.fillStyle = 'rgba(0, 0, 255, 0.15)';
                roc2_ctx.fill();
                roc2_ctx.strokeStyle = 'black'; // Changed to black for better visibility
                roc2_ctx.lineWidth = 3;
                roc2_ctx.stroke();
                
                // Draw border
                roc2_ctx.strokeStyle = '#ddd';
                roc2_ctx.lineWidth = 1;
                roc2_ctx.strokeRect(0, 0, roc2_canvas.width, roc2_canvas.height);
            }
            
            // Draw the ROC curve
            function roc2_drawROCCurve() {
                roc2_rocCtx.clearRect(0, 0, roc2_rocCanvas.width, roc2_rocCanvas.height);
                
                            // Draw axes
            roc2_rocCtx.beginPath();
            // Y-axis (left)
            roc2_rocCtx.moveTo(0, roc2_rocCanvas.height);
            roc2_rocCtx.lineTo(0, 0);
            // X-axis (bottom)
            roc2_rocCtx.moveTo(0, roc2_rocCanvas.height);
            roc2_rocCtx.lineTo(roc2_rocCanvas.width, roc2_rocCanvas.height);
            roc2_rocCtx.stroke();

            // Y-axis label
            roc2_rocCtx.save();
            roc2_rocCtx.translate(20, roc2_rocCanvas.height/2); // Adjust left position
            roc2_rocCtx.rotate(-Math.PI/2);
            roc2_rocCtx.restore();

            // Y-ticks (only 0 and 1)
            [0, 1].forEach(t => {
                const y = roc2_rocCanvas.height - (t * roc2_rocCanvas.height);
                // Tick
                roc2_rocCtx.beginPath();
                roc2_rocCtx.moveTo(0, y);
                roc2_rocCtx.lineTo(5, y);
                roc2_rocCtx.stroke();
                // Label
                roc2_rocCtx.textAlign = "right";
                roc2_rocCtx.fillText(t.toFixed(0), -8, y + 4);
            });

            // X-ticks (only 0 and 1)
            [0, 1].forEach(t => {
                const x = t * roc2_rocCanvas.width;
                // Tick
                roc2_rocCtx.beginPath();
                roc2_rocCtx.moveTo(x, roc2_rocCanvas.height);
                roc2_rocCtx.lineTo(x, roc2_rocCanvas.height - 5);
                roc2_rocCtx.stroke();
                // Label
                roc2_rocCtx.textAlign = "center";
                roc2_rocCtx.fillText(t.toFixed(0), x, roc2_rocCanvas.height + 20);
            });

            // X-axis label
                // Draw reference line (random classifier)
                roc2_rocCtx.beginPath();
                roc2_rocCtx.moveTo(0, roc2_rocCanvas.height);
                roc2_rocCtx.lineTo(roc2_rocCanvas.width, 0);
                roc2_rocCtx.strokeStyle = 'gray';
                roc2_rocCtx.lineWidth = 1;
                roc2_rocCtx.setLineDash([5, 5]);
                roc2_rocCtx.stroke();
                roc2_rocCtx.setLineDash([]);
                
                // Draw ROC curve points if we have any
                if (roc2_rocPoints.length > 0) {
                    // Only draw line if there are multiple points (after user has moved the slider)
                    if (roc2_rocPoints.length > 1) {
                        // Draw the curve connecting the points
                        roc2_rocCtx.beginPath();
                        roc2_rocCtx.moveTo(0, roc2_rocCanvas.height); // Start at origin (0,1)
                        
                        // Sort points to ensure proper curve
                        const sortedPoints = [...roc2_rocPoints].sort((a, b) => a.fpr - b.fpr);
                        
                        sortedPoints.forEach(point => {
                            const x = point.fpr * roc2_rocCanvas.width;
                            const y = roc2_rocCanvas.height - (point.tpr * roc2_rocCanvas.height);
                            roc2_rocCtx.lineTo(x, y);
                        });
                        
                        roc2_rocCtx.strokeStyle = 'gray'; // Changed from blue to gray
                        roc2_rocCtx.lineWidth = 2;
                        roc2_rocCtx.stroke();
                        
                        // Draw points
                        sortedPoints.forEach(point => {
                            const x = point.fpr * roc2_rocCanvas.width;
                            const y = roc2_rocCanvas.height - (point.tpr * roc2_rocCanvas.height);
                            
                            roc2_rocCtx.beginPath();
                            roc2_rocCtx.arc(x, y, 3, 0, Math.PI * 2);
                            roc2_rocCtx.fillStyle = 'gray'; // Changed from blue to gray
                            roc2_rocCtx.fill();
                        });
                    }
                    
                    // Draw current operating point
                    const tpr = roc2_truePositives / (roc2_truePositives + roc2_falseNegatives) || 0;
                    const fpr = roc2_falsePositives / (roc2_falsePositives + roc2_trueNegatives) || 0;
                    
                    const currentX = fpr * roc2_rocCanvas.width;
                    const currentY = roc2_rocCanvas.height - (tpr * roc2_rocCanvas.height);
                    
                    roc2_rocCtx.beginPath();
                    roc2_rocCtx.arc(currentX, currentY, 6, 0, Math.PI * 2);
                    roc2_rocCtx.fillStyle = 'gray'; // Changed from red to gray
                    roc2_rocCtx.fill();
                    roc2_rocCtx.strokeStyle = 'black';
                    roc2_rocCtx.lineWidth = 1;
                    roc2_rocCtx.stroke();
                }
            }
            
            // Add a new ROC point for current size
            function roc2_addROCPoint() {
                const tpr = roc2_truePositives / (roc2_truePositives + roc2_falseNegatives) || 0;
                const fpr = roc2_falsePositives / (roc2_falsePositives + roc2_trueNegatives) || 0;
                
                // Check if we already have a point with the exact same size
                const existingPoint = roc2_rocPoints.find(p => p.size === roc2_circleSizePercent);
                
                if (existingPoint) {
                    // Update existing point
                    existingPoint.tpr = tpr;
                    existingPoint.fpr = fpr;
                } else {
                    // Add new point
                    roc2_rocPoints.push({
                        tpr,
                        fpr,
                        size: roc2_circleSizePercent
                    });
                }
                
                // Sort points by size
                roc2_rocPoints.sort((a, b) => a.size - b.size);
            }
            
            // Remove ROC points above a certain size
            function roc2_removeROCPointsAboveSize(size) {
                roc2_rocPoints = roc2_rocPoints.filter(point => point.size <= size);
            }
            
            // Update quadrant labels dynamically based on circle position
            function roc2_updateLabels() {
                // Get vertical dividing line position
                const midX = roc2_canvas.width / 2;
                
                // Check if circle overlaps with left or right half
                const leftEdge = roc2_centerX - roc2_circleRadius;
                const rightEdge = roc2_centerX + roc2_circleRadius;
                const topEdge = roc2_centerY - roc2_circleRadius;
                const bottomEdge = roc2_centerY + roc2_circleRadius;
                const overlapsLeft = leftEdge < midX;
                const overlapsRight = rightEdge > midX;
                
                // Padding to ensure labels stay within canvas
                const padding = 20;
                const labelWidth = 70;
                const labelHeight = 40;
                
                // 1. False Positives (inside circle, left side)
                if (overlapsLeft && roc2_falsePositives > 0) {
                    const fpX = Math.max(padding, Math.min(midX - labelWidth - padding, roc2_centerX - roc2_circleRadius / 2));
                    const fpY = roc2_centerY;
                    roc2_quadrantLabels[0].style.display = 'block';
                    roc2_quadrantLabels[0].style.left = fpX + 'px';
                    roc2_quadrantLabels[0].style.top = fpY + 'px';
                } else {
                    roc2_quadrantLabels[0].style.display = 'none';
                }
                
                // 2. True Positives (inside circle, right side)
                if (overlapsRight && roc2_truePositives > 0) {
                    const tpX = Math.min(roc2_canvas.width - labelWidth - padding, Math.max(midX + padding, roc2_centerX + roc2_circleRadius / 3));
                    const tpY = roc2_centerY;
                    roc2_quadrantLabels[1].style.display = 'block';
                    roc2_quadrantLabels[1].style.left = tpX + 'px';
                    roc2_quadrantLabels[1].style.top = tpY + 'px';
                } else {
                    roc2_quadrantLabels[1].style.display = 'none';
                }
                
                // 3. True Negatives (outside circle, left side)
                // Only show if there's sufficient space between the circle and the edge
                const safeDistanceFromCircle = 5; // Minimum distance needed
                const distanceLeftEdge = leftEdge;
                
                if (roc2_trueNegatives > 0 && distanceLeftEdge > safeDistanceFromCircle) {
                    const tnX = padding;
                    const tnY = padding;
                    roc2_quadrantLabels[2].style.display = 'block';
                    roc2_quadrantLabels[2].style.left = tnX + 'px';
                    roc2_quadrantLabels[2].style.top = tnY + 'px';
                } else {
                    // Hide when circle gets too close
                    roc2_quadrantLabels[2].style.display = 'none';
                }
                
                // 4. False Negatives (outside circle, right side)
                // Only show if there's sufficient space between the circle and right edge
                const distanceRightEdge = roc2_canvas.width - rightEdge;
                
                if (roc2_falseNegatives > 0 && distanceRightEdge > safeDistanceFromCircle) {
                    const fnX = roc2_canvas.width - labelWidth - padding;
                    const fnY = padding;
                    roc2_quadrantLabels[3].style.display = 'block';
                    roc2_quadrantLabels[3].style.left = fnX + 'px';
                    roc2_quadrantLabels[3].style.top = fnY + 'px';
                } else {
                    // Hide when circle gets too close
                    roc2_quadrantLabels[3].style.display = 'none';
                }
            }
            
            // Check if a point is inside the circle
            function roc2_isInsideCircle(x, y) {
                const dx = x - roc2_centerX;
                const dy = y - roc2_centerY;
                return (dx * dx + dy * dy) <= (roc2_circleRadius * roc2_circleRadius);
            }
            
            // Calculate distance from a point to the circle
            function roc2_distanceToCircle(x, y) {
                const dx = x - roc2_centerX;
                const dy = y - roc2_centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return Math.max(0, distance - roc2_circleRadius);
            }
            
            // Initialize the first ROC point for the starting size
            function roc2_initROCPoint() {
                roc2_rocPoints = [];
                roc2_addROCPoint();
            }
            
            // Mouse events for dragging the circle
            function roc2_setupDragEvents() {
                roc2_canvas.addEventListener('mousedown', function(e) {
                    const rect = roc2_canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Check if click is near the circle center
                    const dx = mouseX - roc2_centerX;
                    const dy = mouseY - roc2_centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= roc2_circleRadius) {
                        roc2_isDragging = true;
                        roc2_dragStartPos = { x: mouseX, y: mouseY };
                        roc2_dragStartCenter = { x: roc2_circleCenter.x, y: roc2_circleCenter.y };
                        roc2_canvas.style.cursor = 'grabbing';
                    }
                });
                
                roc2_canvas.addEventListener('mousemove', function(e) {
                    if (!roc2_isDragging) return;
                    
                    const rect = roc2_canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Calculate new center position
                    const dx = (mouseX - roc2_dragStartPos.x) / roc2_canvas.width;
                    const dy = (mouseY - roc2_dragStartPos.y) / roc2_canvas.height;
                    
                    roc2_circleCenter.x = Math.max(0.1, Math.min(0.9, roc2_dragStartCenter.x + dx));
                    roc2_circleCenter.y = Math.max(0.1, Math.min(0.9, roc2_dragStartCenter.y + dy));
                    
                    roc2_calculateDimensions();
                    roc2_redrawCanvas();
                    roc2_recalculateMetrics();
                    roc2_updateLabels();
                    roc2_updateROCCurve();
                });
                
                roc2_canvas.addEventListener('mouseup', function() {
                    if (roc2_isDragging) {
                        roc2_isDragging = false;
                        roc2_canvas.style.cursor = 'move';
                    }
                });
                
                roc2_canvas.addEventListener('mouseleave', function() {
                    if (roc2_isDragging) {
                        roc2_isDragging = false;
                        roc2_canvas.style.cursor = 'move';
                    }
                });
                
                // Set initial cursor
                roc2_canvas.style.cursor = 'move';
            }
            
            // Touch events for mobile
            function roc2_setupTouchEvents() {
                roc2_canvas.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    const rect = roc2_canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    
                    // Check if touch is near the circle center
                    const dx = touchX - roc2_centerX;
                    const dy = touchY - roc2_centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= roc2_circleRadius) {
                        roc2_isDragging = true;
                        roc2_dragStartPos = { x: touchX, y: touchY };
                        roc2_dragStartCenter = { x: roc2_circleCenter.x, y: roc2_circleCenter.y };
                    }
                });
                
                roc2_canvas.addEventListener('touchmove', function(e) {
                    if (!roc2_isDragging) return;
                    e.preventDefault();
                    
                    const rect = roc2_canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    
                    // Calculate new center position
                    const dx = (touchX - roc2_dragStartPos.x) / roc2_canvas.width;
                    const dy = (touchY - roc2_dragStartPos.y) / roc2_canvas.height;
                    
                    roc2_circleCenter.x = Math.max(0.1, Math.min(0.9, roc2_dragStartCenter.x + dx));
                    roc2_circleCenter.y = Math.max(0.1, Math.min(0.9, roc2_dragStartCenter.y + dy));
                    
                    roc2_calculateDimensions();
                    roc2_redrawCanvas();
                    roc2_recalculateMetrics();
                    roc2_updateLabels();
                    roc2_updateROCCurve();
                });
                
                roc2_canvas.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    roc2_isDragging = false;
                });
            }
            
            // Set canvas dimensions
            roc2_resizeCanvas();
            
            // Setup events
            roc2_setupSliderEvents();
            roc2_setupTouchEvents(); // Simple touch events for slider only
            
            // Generate many more points
            roc2_generatePoints(10000);
            
            // Initial calculations and rendering
            roc2_calculateDimensions();
            roc2_recalculateMetrics();
            roc2_redrawCanvas();
            roc2_updateLabels();
            
            // Initialize the ROC point for current size
            roc2_initROCPoint();
            
            // Draw ROC curve
            roc2_drawROCCurve();
            
            // Render formulas
            roc2_renderFormulas();
            
            // Handle window resize
            window.addEventListener('resize', function() {
                roc2_resizeCanvas();
                roc2_redrawCanvas();
                roc2_drawROCCurve();
                roc2_updateLabels();
            });
        }
    </script>
</body>
</html>
<br>
<p>Vale a pena destacar que a curva ROC pode ser enganosa para conjuntos de dados muito desbalanceados. Como um último exemplo, vamos observar o que acontece com a curva nesse cenário.</p>
<br>
<h2 id="dados-desbalanceados">Dados Desbalanceados</h2>
<p>Quando os dados são altamente desbalanceados (por exemplo, fraude bancária onde menos de 0,1% das transações são fraudulentas), a curva ROC pode mascarar problemas de desempenho. Na curva ROC, os falsos positivos são medidos em relação ao número total de negativos (FPR = FP/N). Com muitos exemplos negativos, cada falso positivo tem um impacto mínimo na taxa de falsos positivos. Isso pode fazer com que um modelo pareça melhor do que realmente é. Para dados desbalanceados, considere usar a curva <strong>Precisão-Recall (PR)</strong>.</p>
<br>
<p>A simulação abaixo mostra na prática a diferença entre as curvas ROC e PR. É possível alterar tanto o tamanho do círculo quanto a porcentagem da classe positiva no conjunto de dados. Varie primeiramente o tamanho do círculo e veja as duas curvas surgindo.</p>
<br>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        
        .dual_simulation-container {
            max-width: 1200px;
            margin: 0 auto;
            /* You can adjust this min-height to increase simulation height */
            min-height: 600px;
        }
        
        .dual_dataset-info {
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
        }
        
        .dual_flex-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 3%;
        }
        
        .dual_side {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
        }
        
        .dual_slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
            position: relative;
            width: 100%;
            margin-bottom: 20px;
        }
        
        .dual_slider-container label {
            font-weight: bold;
            min-width: 120px;
            color: #333;
            margin-bottom: 1px;
        }
        
        .dual_range-slider {
            flex: 1;
            position: relative;
        }
        
        .dual_range-slider-track {
            height: 8px;
            width: 100%;
            background-color: #ddd;
            border-radius: 4px;
            position: relative;
        }
        
        .dual_range-slider-fill {
            height: 100%;
            background-color: #3b82f6;
            border-radius: 4px;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            transition: width 0.1s ease;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: transparent;
            position: absolute;
            top: 0;
            left: 0;
            margin: 0;
            z-index: 10;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }
        
        .dual_value-display {
            min-width: 60px;
            text-align: center;
            font-weight: bold;
            color: #3b82f6;
            background-color: #f0f4ff;
            padding: 4px 8px;
            border-radius: 12px;
            border: 1px solid #d1d5db;
            margin-left: 10px;
        }
        
        .dual_canvas-container {
            position: relative;
            width: 100%;
            padding-bottom: 100%;
            border: 1px solid #ddd;
            overflow: hidden;
            background-color: white;
        }

        .dual_curves-area {
            display: flex;
            flex-direction: column;
        }
        
        .dual_curve-container {
            position: relative;
            width: 100%;
            padding-bottom: 40%;
            border: 1px solid #ddd;
            background-color: white;
        }

        #dual_canvas, #dual_rocCanvas, #dual_prCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .dual_quadrant-label {
            position: absolute;
            white-space: nowrap;
            font-size: 17px;
            text-align: center;
            color: #fff;
            background-color: rgba(0, 0, 0, 1);
            padding: 1px 5px;
            border-radius: 10px;
            z-index: 10;
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        .dual_curve-title {
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .dual_instructions {
            background-color: #e9f5ff;
            border: 1px solid #b8daff;
            border-radius: 5px;
            padding: 10px;
            margin-top: 15px;
            font-size: 14px;
        }
        
        .dual_axis-container {
            display: flex;
            align-items: stretch;
            position: relative;
            margin-bottom: 5px;
        }
        
        .dual_y-axis-label {
            width: 30px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            margin-right: 5px;
            text-align: center;
        }
        
        .dual_y-axis-label span {
            transform: rotate(-90deg);
            white-space: nowrap;
            display: block;
            width: 40px;
            font-size: 18px;
            position: absolute;
            left: -10px;
        }
        
        .dual_graph-container {
            flex-grow: 1;
            position: relative;
        }
        
        .dual_tick-label {
            position: absolute;
            font-size: 18px;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .dual_flex-container {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="dual_simulation-container">
        <div class="dual_flex-container">
            <!-- Left Side - Visualization -->
            <div class="dual_side">
                <!-- Slider for Positive Class Ratio -->
                <div class="dual_slider-container">
                    <label for="dual_positiveRatio">Classe positiva:</label>
                    <div class="dual_range-slider">
                        <div class="dual_range-slider-track">
                            <div class="dual_range-slider-fill" id="dual_positiveRatioFill"></div>
                        </div>
                        <input type="range" id="dual_positiveRatio" min="1" max="50" value="1" step="1">
                    </div>
                    <div class="dual_value-display" id="dual_positiveRatioValue">1%</div>
                </div>
                
                <!-- Visualization Area -->
                <div class="dual_canvas-container">
                    <canvas id="dual_canvas"></canvas>
                    <div id="dual_quadrant0" class="dual_quadrant-label">False<br>Positives</div>
                    <div id="dual_quadrant1" class="dual_quadrant-label">True<br>Positives</div>
                    <div id="dual_quadrant2" class="dual_quadrant-label">True<br>Negatives</div>
                    <div id="dual_quadrant3" class="dual_quadrant-label">False<br>Negatives</div>
                </div>
                
                <div style="display: flex; justify-content: space-between; width: 100%; font-weight: bold; margin-top: 5px;">
                    <span id="dual_negativeLabel">Negatives (99%)</span>
                    <span id="dual_positiveLabel">Positives (1%)</span>
                </div>
            </div>
            
            <!-- Right side - ROC and PR Curves -->
            <div class="dual_side">
                <!-- Slider for Circle Size -->
                <div class="dual_slider-container">
                    <label for="dual_circleSize">Tamanho do círculo</label>
                    <div class="dual_range-slider">
                        <div class="dual_range-slider-track">
                            <div class="dual_range-slider-fill" id="dual_circleSizeFill"></div>
                        </div>
                        <input type="range" id="dual_circleSize" min="0" max="100" value="0" step="1">
                    </div>
                    <div class="dual_value-display" id="dual_circleSizeValue">0</div>
                </div>
                
                <!-- Curves Area -->
                <div class="dual_curves-area">
                    <!-- ROC Curve -->
                    <div>
                        <div class="dual_curve-title">ROC Curve</div>
                        <div class="dual_axis-container">
                            <div class="dual_y-axis-label">
                                <span>TPR</span>
                            </div>
                            <div class="dual_graph-container">
                                <div class="dual_curve-container">
                                    <canvas id="dual_rocCanvas"></canvas>
                                    <!-- Fixed tick labels positioned over canvas -->
                                    <div class="dual_tick-label" style="left: -30px; top: 0;">1.0</div>
                                    <div class="dual_tick-label" style="bottom: -30px; left: 0;">0.0</div>
                                    <div class="dual_tick-label" style="bottom: -30px; right: 0;">1.0</div>
                                </div>
                                
                                <!-- X-axis label -->
                                <div style="text-align: center; font-weight: bold; margin: 20px 0 10px 0;">
                                    FPR
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- PR Curve -->
                    <div>
                        <div class="dual_curve-title">Precision-Recall Curve</div>
                        <div class="dual_axis-container">
                            <div class="dual_y-axis-label">
                                <span>Precision</span>
                            </div>
                            <div class="dual_graph-container">
                                <div class="dual_curve-container">
                                    <canvas id="dual_prCanvas"></canvas>
                                    <!-- Fixed tick labels positioned over canvas -->
                                    <div class="dual_tick-label" style="left: -30px; top: 0;">1.0</div>
                                    <div class="dual_tick-label" style="bottom: -30px; left: 0;">0.0</div>
                                    <div class="dual_tick-label" style="bottom: -30px; right: 0;">1.0</div>
                                </div>
                                
                                <!-- X-axis label -->
                                <div style="text-align: center; font-weight: bold; margin: 20px 0 10px 0;">
                                    Recall
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
        
    <script>
        // Wait for all resources to load
        window.addEventListener('load', function() {
            // Initialize simulation
            dual_init();
        });
        
        function dual_init() {
            // DOM Elements
            const dual_canvas = document.getElementById('dual_canvas');
            const dual_ctx = dual_canvas.getContext('2d');
            const dual_rocCanvas = document.getElementById('dual_rocCanvas');
            const dual_rocCtx = dual_rocCanvas.getContext('2d');
            const dual_prCanvas = document.getElementById('dual_prCanvas');
            const dual_prCtx = dual_prCanvas.getContext('2d');
            const dual_circleSizeSlider = document.getElementById('dual_circleSize');
            const dual_circleSizeFill = document.getElementById('dual_circleSizeFill');
            const dual_circleSizeValue = document.getElementById('dual_circleSizeValue');
            const dual_positiveRatioSlider = document.getElementById('dual_positiveRatio');
            const dual_positiveRatioFill = document.getElementById('dual_positiveRatioFill');
            const dual_positiveRatioValue = document.getElementById('dual_positiveRatioValue');
            const dual_positiveLabel = document.getElementById('dual_positiveLabel');
            const dual_negativeLabel = document.getElementById('dual_negativeLabel');
        
            // Quadrant labels
            const dual_quadrantLabels = [
                document.getElementById('dual_quadrant0'),
                document.getElementById('dual_quadrant1'),
                document.getElementById('dual_quadrant2'),
                document.getElementById('dual_quadrant3')
            ];
            
            // Variables
            let dual_truePositives = 0;
            let dual_falsePositives = 0;
            let dual_trueNegatives = 0;
            let dual_falseNegatives = 0;
            let dual_totalPoints = 0;
            let dual_points = [];
            let dual_rocPoints = [];
            let dual_prPoints = [];
            let dual_currentSize = 0; // Track current circle size
            let dual_positiveClassRatio = 0.01; // Starting point: 1%
            
            // Set extra space above y=1 for visibility (expressed as a fraction of canvas height)
            const dual_extraSpace = 0.05; // 5% extra space above y=1.0
            
            // Circle properties - fixed center at 0.65, 0.5
            let dual_circleRadius;
            let dual_centerX;
            let dual_centerY;
            let dual_circleCenter = { x: 0.65, y: 0.5 }; // Fixed position
            let dual_circleSizePercent = 0; // Percentage of min dimension
            
            // Update positive ratio slider fill and label
            function dual_updatePositiveRatioSlider() {
                const percent = (dual_positiveRatioSlider.value - dual_positiveRatioSlider.min) / 
                                (dual_positiveRatioSlider.max - dual_positiveRatioSlider.min) * 100;
                dual_positiveRatioFill.style.width = percent + '%';
                
                // Update the display value
                const ratioValue = parseInt(dual_positiveRatioSlider.value);
                dual_positiveRatioValue.textContent = ratioValue + '%';
                
                // Convert to decimal
                dual_positiveClassRatio = ratioValue / 100;
                
                // Update dataset info text and labels
                dual_positiveLabel.textContent = `Positives (${ratioValue}%)`;
                dual_negativeLabel.textContent = `Negatives (${100-ratioValue}%)`;
            }
            
            // Update circle size slider fill and value
            function dual_updateCircleSizeSlider() {
                const percent = (dual_circleSizeSlider.value - dual_circleSizeSlider.min) / 
                               (dual_circleSizeSlider.max - dual_circleSizeSlider.min) * 100;
                dual_circleSizeFill.style.width = percent;
                dual_circleSizeValue.textContent = dual_circleSizeSlider.value;
            }
            
            // Initial slider fill updates
            dual_updateCircleSizeSlider();
            dual_updatePositiveRatioSlider();
            
            // Setup slider events
            function dual_setupSliderEvents() {
                // Circle size slider
                dual_circleSizeSlider.addEventListener('input', function() {
                    // Store previous and current size for curve updating
                    const prevSize = dual_circleSizePercent;
                    dual_circleSizePercent = parseInt(this.value);
                    dual_currentSize = dual_circleSizePercent;
                    
                    dual_updateCircleSizeSlider();
                    dual_calculateDimensions();
                    dual_redrawCanvas();
                    dual_recalculateMetrics();
                    dual_updateQuadrantLabels();
                    
                    // Update curve points based on whether size increased or decreased
                    if (dual_circleSizePercent > prevSize) {
                        dual_addCurvePoints();
                    } else if (dual_circleSizePercent < prevSize) {
                        dual_removeCurvePointsAboveSize(dual_circleSizePercent);
                    }
                    
                    dual_drawROCCurve();
                    dual_drawPRCurve();
                });
                
                // Positive class ratio slider
                dual_positiveRatioSlider.addEventListener('input', function() {
                    dual_updatePositiveRatioSlider();
                    
                    // Clear previous points and regenerate with new ratio
                    dual_generatePoints(10000);
                    
                    // Reset curves for the new distribution
                    dual_rocPoints = [];
                    dual_prPoints = [];
                    dual_addCurvePoints();
                    
                    // Redraw everything
                    dual_redrawCanvas();
                    dual_drawROCCurve();
                    dual_drawPRCurve();
                    dual_updateQuadrantLabels();
                });
            }
            
            // Resize canvas to fit container
            function dual_resizeCanvas() {
                const container = dual_canvas.parentElement;
                dual_canvas.width = container.clientWidth;
                dual_canvas.height = container.clientHeight;
                
                const rocContainer = dual_rocCanvas.parentElement;
                dual_rocCanvas.width = rocContainer.clientWidth;
                dual_rocCanvas.height = rocContainer.clientHeight;
                
                const prContainer = dual_prCanvas.parentElement;
                dual_prCanvas.width = prContainer.clientWidth;
                dual_prCanvas.height = prContainer.clientHeight;
                
                dual_calculateDimensions();
                dual_redrawCanvas();
                dual_drawROCCurve();
                dual_drawPRCurve();
                dual_updateQuadrantLabels();
            }
            
            // Calculate circle dimensions based on canvas size and current settings
            function dual_calculateDimensions() {
                // Fixed center position (no dragging)
                dual_centerX = dual_canvas.width * dual_circleCenter.x;
                dual_centerY = dual_canvas.height * dual_circleCenter.y;
                const minDimension = Math.min(dual_canvas.width, dual_canvas.height);
                dual_circleRadius = minDimension * (dual_circleSizePercent / 100);
            }
            
            // Generate points with adjustable positive class ratio
            function dual_generatePoints(count) {
                dual_points = [];
                
                // Calculate number of points for each class
                const positiveCount = Math.round(count * dual_positiveClassRatio);
                const negativeCount = count - positiveCount;
                
                // Generate negative points (left side)
                for (let i = 0; i < negativeCount; i++) {
                    dual_points.push({
                        x: Math.random() * (dual_canvas.width / 2 - 5),
                        y: Math.random() * dual_canvas.height
                    });
                }
                
                // Generate positive points (right side)
                for (let i = 0; i < positiveCount; i++) {
                    dual_points.push({
                        x: (dual_canvas.width / 2 + 5) + Math.random() * (dual_canvas.width / 2 - 10),
                        y: Math.random() * dual_canvas.height
                    });
                }
                
                dual_recalculateMetrics();
            }
            
            // Update the class metrics based on the points
            function dual_recalculateMetrics() {
                // Reset counts
                dual_truePositives = 0;
                dual_falsePositives = 0;
                dual_trueNegatives = 0;
                dual_falseNegatives = 0;
                
                // Recalculate counts for each point
                dual_points.forEach(point => {
                    const isRight = point.x >= dual_canvas.width / 2;
                    const isPredictedPositive = dual_isInsideCircle(point.x, point.y);
                    
                    if (isRight && isPredictedPositive) dual_truePositives++;
                    else if (!isRight && isPredictedPositive) dual_falsePositives++;
                    else if (!isRight && !isPredictedPositive) dual_trueNegatives++;
                    else if (isRight && !isPredictedPositive) dual_falseNegatives++;
                });
                
                dual_totalPoints = dual_points.length;
            }
            
            // Draw all points
            function dual_drawPoints() {
                dual_points.forEach(point => {
                    const isRight = point.x >= dual_canvas.width / 2;
                    
                    // Choose color based on actual class (left/right side)
                    if (isRight) {
                        dual_ctx.fillStyle = 'blue'; // Actual Positive (right side)
                    } else {
                        dual_ctx.fillStyle = 'red'; // Actual Negative (left side)
                    }
                    
                    dual_ctx.beginPath();
                    dual_ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                    dual_ctx.fill();
                });
            }
            
            // Redraw canvas with all points and current circle position
            function dual_redrawCanvas() {
                dual_ctx.clearRect(0, 0, dual_canvas.width, dual_canvas.height);
                
                // Draw points
                dual_drawPoints();
                
                // Draw dividing line
                dual_ctx.beginPath();
                dual_ctx.moveTo(dual_canvas.width / 2, 0);
                dual_ctx.lineTo(dual_canvas.width / 2, dual_canvas.height);
                dual_ctx.strokeStyle = 'black';
                dual_ctx.lineWidth = 2;
                dual_ctx.stroke();
                
                // Draw circle
                dual_ctx.beginPath();
                dual_ctx.arc(dual_centerX, dual_centerY, dual_circleRadius, 0, Math.PI * 2);
                dual_ctx.fillStyle = 'rgba(0, 0, 255, 0.15)';
                dual_ctx.fill();
                dual_ctx.strokeStyle = 'black';
                dual_ctx.lineWidth = 3;
                dual_ctx.stroke();
                
                // Draw border
                dual_ctx.strokeStyle = '#ddd';
                dual_ctx.lineWidth = 1;
                dual_ctx.strokeRect(0, 0, dual_canvas.width, dual_canvas.height);
            }
            
            // Draw the ROC curve with corrected y-coordinate calculation
            function dual_drawROCCurve() {
                dual_rocCtx.clearRect(0, 0, dual_rocCanvas.width, dual_rocCanvas.height);
                
                // Calculate the actual data area height (reduced to make room for the extra space)
                const dataAreaHeight = dual_rocCanvas.height / (1 + dual_extraSpace);
                
                // Draw axes
                dual_rocCtx.beginPath();
                // Y-axis (left)
                dual_rocCtx.moveTo(0, dual_rocCanvas.height);
                dual_rocCtx.lineTo(0, 0);
                // X-axis (bottom)
                dual_rocCtx.moveTo(0, dual_rocCanvas.height);
                dual_rocCtx.lineTo(dual_rocCanvas.width, dual_rocCanvas.height);
                dual_rocCtx.stroke();

                // Draw reference line (random classifier)
                dual_rocCtx.beginPath();
                dual_rocCtx.moveTo(0, dual_rocCanvas.height); // (0,0) in canvas coordinates
                dual_rocCtx.lineTo(dual_rocCanvas.width, dual_rocCanvas.height - dataAreaHeight); // (1,1) in canvas coordinates
                dual_rocCtx.strokeStyle = 'gray';
                dual_rocCtx.lineWidth = 1;
                dual_rocCtx.setLineDash([5, 5]);
                dual_rocCtx.stroke();
                dual_rocCtx.setLineDash([]);
                
                // Draw ROC curve points if we have any
                if (dual_rocPoints.length > 0) {
                    // Only draw line if there are multiple points
                    if (dual_rocPoints.length > 1) {
                        // Draw the curve connecting the points
                        dual_rocCtx.beginPath();
                        dual_rocCtx.moveTo(0, dual_rocCanvas.height); // Start at origin (0,0)
                        
                        // Sort points to ensure proper curve
                        const sortedPoints = [...dual_rocPoints].sort((a, b) => a.fpr - b.fpr);
                        
                        sortedPoints.forEach(point => {
                            const x = point.fpr * dual_rocCanvas.width;
                            // Corrected y-coordinate calculation
                            const y = dual_rocCanvas.height - (point.tpr * dataAreaHeight);
                            dual_rocCtx.lineTo(x, y);
                        });
                        
                        dual_rocCtx.strokeStyle = 'blue';
                        dual_rocCtx.lineWidth = 2;
                        dual_rocCtx.stroke();
                        
                        // Draw points
                        sortedPoints.forEach(point => {
                            const x = point.fpr * dual_rocCanvas.width;
                            // Corrected y-coordinate calculation
                            const y = dual_rocCanvas.height - (point.tpr * dataAreaHeight);
                            
                            dual_rocCtx.beginPath();
                            dual_rocCtx.arc(x, y, 3, 0, Math.PI * 2);
                            dual_rocCtx.fillStyle = 'blue';
                            dual_rocCtx.fill();
                        });
                    }
                    
                    // Draw current operating point
                    const tpr = dual_truePositives / (dual_truePositives + dual_falseNegatives) || 0;
                    const fpr = dual_falsePositives / (dual_falsePositives + dual_trueNegatives) || 0;
                    
                    const currentX = fpr * dual_rocCanvas.width;
                    // Corrected y-coordinate calculation
                    const currentY = dual_rocCanvas.height - (tpr * dataAreaHeight);
                    
                    dual_rocCtx.beginPath();
                    dual_rocCtx.arc(currentX, currentY, 6, 0, Math.PI * 2);
                    dual_rocCtx.fillStyle = 'red';
                    dual_rocCtx.fill();
                    dual_rocCtx.strokeStyle = 'black';
                    dual_rocCtx.lineWidth = 1;
                    dual_rocCtx.stroke();
                }
            }
            
            // Draw the PR curve with corrected y-coordinate calculation
            function dual_drawPRCurve() {
                dual_prCtx.clearRect(0, 0, dual_prCanvas.width, dual_prCanvas.height);
                
                // Calculate the actual data area height (reduced to make room for the extra space)
                const dataAreaHeight = dual_prCanvas.height / (1 + dual_extraSpace);
                
                // Draw axes
                dual_prCtx.beginPath();
                // Y-axis (left)
                dual_prCtx.moveTo(0, dual_prCanvas.height);
                dual_prCtx.lineTo(0, 0);
                // X-axis (bottom)
                dual_prCtx.moveTo(0, dual_prCanvas.height);
                dual_prCtx.lineTo(dual_prCanvas.width, dual_prCanvas.height);
                dual_prCtx.stroke();
                
                // Baseline removed as requested
                
                // Draw PR curve points if we have any
                if (dual_prPoints.length > 0) {
                    // Only draw line if there are multiple points
                    if (dual_prPoints.length > 1) {
                        // Draw the curve connecting the points
                        dual_prCtx.beginPath();
                        
                        // Sort points to ensure proper curve - for PR curve, we sort by recall (x-axis)
                        const sortedPoints = [...dual_prPoints].sort((a, b) => a.recall - b.recall);
                        
                        // Start point - unlike ROC, PR curves don't start at origin
                        const firstPoint = sortedPoints[0];
                        const firstX = firstPoint.recall * dual_prCanvas.width;
                        // Corrected y-coordinate calculation
                        const firstY = dual_prCanvas.height - (firstPoint.precision * dataAreaHeight);
                        dual_prCtx.moveTo(firstX, firstY);
                        
                        // Connect the rest of the points
                        for (let i = 1; i < sortedPoints.length; i++) {
                            const point = sortedPoints[i];
                            const x = point.recall * dual_prCanvas.width;
                            // Corrected y-coordinate calculation
                            const y = dual_prCanvas.height - (point.precision * dataAreaHeight);
                            dual_prCtx.lineTo(x, y);
                        }
                        
                        dual_prCtx.strokeStyle = 'green';
                        dual_prCtx.lineWidth = 2;
                        dual_prCtx.stroke();
                        
                        // Draw points
                        sortedPoints.forEach(point => {
                            const x = point.recall * dual_prCanvas.width;
                            // Corrected y-coordinate calculation
                            const y = dual_prCanvas.height - (point.precision * dataAreaHeight);
                            
                            dual_prCtx.beginPath();
                            dual_prCtx.arc(x, y, 3, 0, Math.PI * 2);
                            dual_prCtx.fillStyle = 'green';
                            dual_prCtx.fill();
                        });
                    }
                    
                    // Draw current operating point
                    const precision = dual_truePositives / (dual_truePositives + dual_falsePositives) || 0;
                    const recall = dual_truePositives / (dual_truePositives + dual_falseNegatives) || 0;
                    
                    const currentX = recall * dual_prCanvas.width;
                    // Corrected y-coordinate calculation
                    const currentY = dual_prCanvas.height - (precision * dataAreaHeight);
                    
                    dual_prCtx.beginPath();
                    dual_prCtx.arc(currentX, currentY, 6, 0, Math.PI * 2);
                    dual_prCtx.fillStyle = 'red';
                    dual_prCtx.fill();
                    dual_prCtx.strokeStyle = 'black';
                    dual_prCtx.lineWidth = 1;
                    dual_prCtx.stroke();
                }
            }
            
            // Add new curve points for current size
            function dual_addCurvePoints() {
                const tpr = dual_truePositives / (dual_truePositives + dual_falseNegatives) || 0;
                const fpr = dual_falsePositives / (dual_falsePositives + dual_trueNegatives) || 0;
                const precision = dual_truePositives / (dual_truePositives + dual_falsePositives) || 0;
                const recall = tpr; // Recall is the same as TPR
                
                // Check if we already have points with the exact same size
                const existingRocPoint = dual_rocPoints.find(p => p.size === dual_circleSizePercent);
                const existingPrPoint = dual_prPoints.find(p => p.size === dual_circleSizePercent);
                
                // Update ROC point
                if (existingRocPoint) {
                    existingRocPoint.tpr = tpr;
                    existingRocPoint.fpr = fpr;
                } else {
                    dual_rocPoints.push({
                        tpr,
                        fpr,
                        size: dual_circleSizePercent
                    });
                }
                
                // Update PR point
                if (existingPrPoint) {
                    existingPrPoint.precision = precision;
                    existingPrPoint.recall = recall;
                } else {
                    dual_prPoints.push({
                        precision,
                        recall,
                        size: dual_circleSizePercent
                    });
                }
                
                // Sort points by size
                dual_rocPoints.sort((a, b) => a.size - b.size);
                dual_prPoints.sort((a, b) => a.size - b.size);
            }
            
            // Remove curve points above a certain size
            function dual_removeCurvePointsAboveSize(size) {
                dual_rocPoints = dual_rocPoints.filter(point => point.size <= size);
                dual_prPoints = dual_prPoints.filter(point => point.size <= size);
            }
            
            // Update quadrant labels dynamically based on circle position
            function dual_updateQuadrantLabels() {
                // Get vertical dividing line position
                const midX = dual_canvas.width / 2;
                
                // Check if circle overlaps with left or right half
                const leftEdge = dual_centerX - dual_circleRadius;
                const rightEdge = dual_centerX + dual_circleRadius;
                const topEdge = dual_centerY - dual_circleRadius;
                const bottomEdge = dual_centerY + dual_circleRadius;
                const overlapsLeft = leftEdge < midX;
                const overlapsRight = rightEdge > midX;
                
                // Padding to ensure labels stay within canvas
                const padding = 20;
                const labelWidth = 70;
                const labelHeight = 40;
                
                // 1. False Positives (inside circle, left side)
                if (overlapsLeft && dual_falsePositives > 0) {
                    const fpX = Math.max(padding, Math.min(midX - labelWidth - padding, dual_centerX - dual_circleRadius / 2));
                    const fpY = dual_centerY;
                    dual_quadrantLabels[0].style.display = 'block';
                    dual_quadrantLabels[0].style.left = fpX + 'px';
                    dual_quadrantLabels[0].style.top = fpY + 'px';
                } else {
                    dual_quadrantLabels[0].style.display = 'none';
                }
                
                // 2. True Positives (inside circle, right side)
                if (overlapsRight && dual_truePositives > 0) {
                    const tpX = Math.min(dual_canvas.width - labelWidth - padding, Math.max(midX + padding, dual_centerX + dual_circleRadius / 3));
                    const tpY = dual_centerY;
                    dual_quadrantLabels[1].style.display = 'block';
                    dual_quadrantLabels[1].style.left = tpX + 'px';
                    dual_quadrantLabels[1].style.top = tpY + 'px';
                } else {
                    dual_quadrantLabels[1].style.display = 'none';
                }
                
                // 3. True Negatives (outside circle, left side)
                // Only show if there's sufficient space between the circle and the edge
                const safeDistanceFromCircle = 5; // Minimum distance needed
                const distanceLeftEdge = leftEdge;
                
                if (dual_trueNegatives > 0 && distanceLeftEdge > safeDistanceFromCircle) {
                    const tnX = padding;
                    const tnY = padding;
                    dual_quadrantLabels[2].style.display = 'block';
                    dual_quadrantLabels[2].style.left = tnX + 'px';
                    dual_quadrantLabels[2].style.top = tnY + 'px';
                } else {
                    // Hide when circle gets too close
                    dual_quadrantLabels[2].style.display = 'none';
                }
                
                // 4. False Negatives (outside circle, right side)
                // Only show if there's sufficient space between the circle and right edge
                const distanceRightEdge = dual_canvas.width - rightEdge;
                
                if (dual_falseNegatives > 0 && distanceRightEdge > safeDistanceFromCircle) {
                    const fnX = dual_canvas.width - labelWidth - padding;
                    const fnY = padding;
                    dual_quadrantLabels[3].style.display = 'block';
                    dual_quadrantLabels[3].style.left = fnX + 'px';
                    dual_quadrantLabels[3].style.top = fnY + 'px';
                } else {
                    // Hide when circle gets too close
                    dual_quadrantLabels[3].style.display = 'none';
                }
            }
            
            // Check if a point is inside the circle
            function dual_isInsideCircle(x, y) {
                const dx = x - dual_centerX;
                const dy = y - dual_centerY;
                return (dx * dx + dy * dy) <= (dual_circleRadius * dual_circleRadius);
            }
            
            // Initialize the first curve points for the starting size
            function dual_initCurvePoints() {
                dual_rocPoints = [];
                dual_prPoints = [];
                dual_addCurvePoints();
            }
            
            // Set canvas dimensions
            dual_resizeCanvas();
            
            // Setup slider events
            dual_setupSliderEvents();
            
            // Generate points with imbalanced distribution
            dual_generatePoints(10000);
            
            // Initial calculations and rendering
            dual_calculateDimensions();
            dual_recalculateMetrics();
            dual_redrawCanvas();
            dual_updateQuadrantLabels();
            
            // Initialize the curve points for current size
            dual_initCurvePoints();
            
            // Draw curves
            dual_drawROCCurve();
            dual_drawPRCurve();
            
            // Handle window resize
            window.addEventListener('resize', function() {
                dual_resizeCanvas();
                dual_redrawCanvas();
                dual_drawROCCurve();
                dual_drawPRCurve();
                dual_updateQuadrantLabels();
            });
        }
    </script>
</body>
</html>
<p>Repare que, com apenas 1% de exemplos positivos, aumentar o tamanho do círculo faz com que a curva PR sofra uma queda acentuada na precisão — já que o número de falsos positivos aumenta muito mais do que o de verdadeiros positivos. Esse efeito, porém, não é capturado pela curva ROC, que permanece praticamente inalterada.</p>
<br>
<div style="display: flex; align-items: center;">
<div style="flex: 1; padding-right: 20px;">
<p>Outro efeito interessante pode ser observado com a seguinte configuração: defina o tamanho do círculo em 40 e varie a porcentagem da classe positiva de 1% até 100%, e depois retorne a 1%. Você notará que o ponto correspondente na curva ROC praticamente não se move — a taxa de falsos positivos (FPR) permanece quase constante. Por outro lado, na curva PR, a precisão cai drasticamente à medida que a proporção de positivos se torna menor.</p>
</div>
<div style="flex: 1;">

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/JCMaZmj5tks" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

</div>
</div>
<p>Em geral, com precisão e recall estamos mais focados na classe minoritária (positiva, nesse caso), o que torna essas métricas mais informativas para dados desbalanceados. Um falso positivo não tem muito peso na curva ROC se temos muitos exemplos negativos. Porém, o mesmo falso positivo terá um impacto significativo na curva PR porque FP está no denominador da precisão.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Um modelo ideal seria representado por um retângulo idêntico ao lado direito, posicionado exatamente sobre ele.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Os dois tipos de erros possuem nomes conhecidos. Falsos positivos (FP) são erros tipo I e falsos negativos (FN) são erros tipo II.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>Nas simulações desta postagem, os pontos estão distribuídos uniformemente no plano. Essa escolha tem fins didáticos, pois facilita a explicação dos conceitos. No entanto, vale lembrar que, na vida real, os dados não necessariamente seguem essa distribuição.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>A abordagem dessa postagem se aplica a casos binários (por exemplo, positivo/negativo). Para problemas multiclasse, teríamos uma curva ROC para cada classe (one-vs-all).&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>Quanto mais próxima a curva ROC estiver do canto superior esquerdo, melhor é o desempenho do modelo. Para quantificar o desempenho, calculamos a área sob a curva (AUC), que representa a performance geral do modelo: AUC = 1,0: modelo perfeito. AUC = 0,5: modelo aleatório (sem poder preditivo). AUC &lt; 0,5: pior que aleatório (inverta suas previsões).&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

              </div>
              






<div class="article-tags">
  
  <a class="badge badge-light" href="/tag/machine-learning/">machine learning</a>
  
  <a class="badge badge-light" href="/tag/data-science/">Data science</a>
  
  <a class="badge badge-light" href="/tag/visualizacao/">visualização</a>
  
  <a class="badge badge-light" href="/tag/metricas/">métricas</a>
  
  <a class="badge badge-light" href="/tag/classificacao/">classificação</a>
  
  <a class="badge badge-light" href="/tag/curvas-roc/">curvas ROC</a>
  
</div>













  
  
    



  
  
  
    
  
  
  
  <div class="media author-card content-widget-hr">
    
      
      <a href="https://alvarofrancomartins.com"><img class="avatar mr-3 avatar-circle" src="/author/alvaro-franco-martins/avatar_hu9663ca6c1fda1d039f779a01a14750c7_758770_270x270_fill_q100_lanczos_center.jpg" alt="Alvaro Franco Martins"></a>
    

    <div class="media-body">
      <h5 class="card-title"><a href="https://alvarofrancomartins.com">Alvaro Franco Martins</a></h5>
      
      
      <ul class="network-icon" aria-hidden="true">
  
    
    
    
      
    
    
    
    
    
    <li>
      <a href="mailto:alvarought@gmail.com" >
        <i class="fas fa-envelope"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://twitter.com/alvarofmartins" target="_blank" rel="noopener">
        <i class="fab fa-twitter"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://scholar.google.com.br/citations?user=yB30J2MAAAAJ" target="_blank" rel="noopener">
        <i class="fas fa-graduation-cap"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://www.researchgate.net/profile/Alvaro-Martins-2" target="_blank" rel="noopener">
        <i class="fab fa-researchgate"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://github.com/alvarofrancomartins" target="_blank" rel="noopener">
        <i class="fab fa-github"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://www.linkedin.com/in/alvarofrancomartins/" target="_blank" rel="noopener">
        <i class="fab fa-linkedin"></i>
      </a>
    </li>
  
</ul>

    </div>
  </div>


  














  
  
  <div class="article-widget content-widget-hr">
    <h3>Related</h3>
    <ul>
      
      <li><a href="/publication/deep-learning-criminal-networks/">Deep learning criminal networks</a></li>
      
      <li><a href="/publication/machine-learning-partners-in-criminal-networks/">Machine learning partners in criminal networks</a></li>
      
      <li><a href="/post/corruption-networks/">Unveiling the hidden patterns of corruption networks</a></li>
      
    </ul>
  </div>
  




            </div>
        </article>
  
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">
  

  <p class="powered-by">
    
  </p>

  
  






  <p class="powered-by" style="font-size:11px;">
    
    Published with
    <a href="https://wowchemy.com/" target="_blank" rel="noopener">Wowchemy</a>. 
    

    
    <span class="float-right" aria-hidden="true">
      <a href="#" class="back-to-top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>
    </div>
    
  </div>

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

      

    
    <script src="/js/vendor-bundle.min.b73dfaac3b6499dc997741748a7c3fe2.js"></script>

    
    
    
      
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      

      
      

      

      

    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.js" integrity="sha512-SeiQaaDh73yrb56sTW/RgVdi/mMqNeM2oBwubFHagc5BkixSpP1fvqF47mKzPGWYSSy4RwbBunrJBQ4Co8fRWA==" crossorigin="anonymous"></script>
    

    
    

    
    
    
      
      <script id="search-hit-fuse-template" type="text/x-template">
        <div class="search-hit" id="summary-{{key}}">
          <div class="search-hit-content">
            <div class="search-hit-name">
              <a href="{{relpermalink}}">{{title}}</a>
              <div class="article-metadata search-hit-type">{{type}}</div>
              <p class="search-hit-description">{{snippet}}</p>
            </div>
          </div>
        </div>
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
      
    

    
    

    
    
    
    

    
    
      
      
      
      
      
      
      
    

    
    
    
    
    
    
    
    
      
      
    
    
    <script src="/en/js/wowchemy.min.b206710415a50cb12ea588a8ed1fe3c5.js"></script>

    






</body>
</html>
