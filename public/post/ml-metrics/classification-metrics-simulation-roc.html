<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.3/contrib/auto-render.min.js"></script>
    <script>
        // Ensure KaTeX is fully loaded before page initialization
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof katex !== 'undefined') {
                console.log("KaTeX loaded successfully");
            } else {
                console.error("KaTeX failed to load");
            }
        });
    </script>
    <style>
        
        .roc_simulation-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .roc_control-panel {
            width: 100%;
            max-width: 80%;
            margin: 0 auto 20px;
        }
        
        .roc_slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
            position: relative;
            width: 100%;
            max-width: 350px;
        }
        
        .roc_slider-container label {
            font-weight: bold;
            min-width: 100px;
            color: #333;
            margin-bottom: 1px;
        }
        
        .roc_range-slider {
            width: 100%;
            position: relative;
        }
        
        .roc_range-slider-track {
            height: 8px;
            width: 100%;
            background-color: #ddd;
            border-radius: 4px;
            position: relative;
        }
        
        .roc_range-slider-fill {
            height: 100%;
            background-color: #3b82f6;
            border-radius: 4px;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            transition: width 0.1s ease;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: transparent;
            position: absolute;
            top: 0;
            left: 0;
            margin: 0;
            z-index: 10;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        .roc_slider-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #3b82f6;
            background-color: #f0f4ff;
            padding: 4px 8px;
            border-radius: 12px;
            margin-left: 10px;
            border: 1px solid #d1d5db;
        }
        
        .roc_flex-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 3%; /* Increased from 20px */
        }
        
        .roc_visualization-area {
            flex: 1;
            min-width: 300px;
        }
        
        .roc_roc-area {
            flex: 1;
            min-width: 300px;
        }
        
        .roc_canvas-container {
            position: relative;
            width: 100%;
            padding-bottom: 85%;
            border: 1px solid #ddd;
            overflow: hidden;
            background-color: white;
        }

        #roc_canvas, #roc_rocCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: move;
        }
        
        .roc_quadrant-label {
            position: absolute;
            white-space: nowrap;
            font-size: 17px;
            text-align: center;
            color: #fff;
            background-color: rgba(0, 0, 0, 1);
            padding: 1px 5px;
            border-radius: 10px;
            z-index: 10;
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        .roc_metrics-display {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f8f9fa;
        }
        
        .roc_metrics-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }
        
        .roc_metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .roc_metric-card {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
        }
        
        .roc_metric-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            color: #333;
        }
        
        .roc_metric-formula {
            text-align: center;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .roc_metric-value {
            text-align: center;
            font-weight: bold;
            font-size: 18px;
            color: #3b82f6;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .roc_flex-container {
                flex-direction: column;
            }
            
            .roc_metrics-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="roc_simulation-container">
        
        <div class="roc_control-panel">
            <div class="roc_slider-container">
                <label for="roc_circleSize">Tamanho do c√≠rculo</label>
                <div class="roc_range-slider">
                    <div class="roc_range-slider-track">
                        <div class="roc_range-slider-fill" id="roc_circleSizeFill"></div>
                    </div>
                    <input type="range" id="roc_circleSize" min="0" max="100" value="0" step="1">
                </div>
            </div>
        </div>
        
        <div class="roc_flex-container">
            <!-- Visualization Area -->
            <div class="roc_visualization-area">
                <div class="roc_canvas-container">
                    <canvas id="roc_canvas"></canvas>
                    <div id="roc_quadrant0" class="roc_quadrant-label">False<br>Positives</div>
                    <div id="roc_quadrant1" class="roc_quadrant-label">True<br>Positives</div>
                    <div id="roc_quadrant2" class="roc_quadrant-label">True<br>Negatives</div>
                    <div id="roc_quadrant3" class="roc_quadrant-label">False<br>Negatives</div>
                </div>
                
                <div style="display: flex; justify-content: space-between; width: 100%; font-weight: bold; margin-top: 5px;">
                    <span>Negatives</span>
                    <span>Positives</span>
                </div>
            </div>
            
            <!-- Right side: ROC Curve and Metrics -->
            <div class="roc_roc-area">
            <!-- ROC Curve with Y-axis labels -->
            <div style="display: flex; align-items: stretch; margin-bottom: 0px;">
                <!-- Y-axis labels -->
                <div style="display: flex; flex-direction: column; font-weight: bold; width: 40px; position: relative; height: 300px;">
                    <span style="position: absolute; top: 0; right: 0;">1.0</span>
                    <span style="position: absolute; writing-mode: vertical-rl; transform: rotate(180deg); left: 10px; top: 50%;">TPR</span>
                </div>
                
                <!-- ROC Curve canvas -->
                <div style="flex-grow: 1;">
                    <div class="roc_canvas-container" style="padding-bottom: 50%;">
                        <canvas id="roc_rocCanvas"></canvas>
                    </div>
                    
                    <!-- X-axis labels -->
                    <div style="display: flex; justify-content: space-between; width: 100%; font-weight: bold; margin: 5px 0 10px 0;">
                        <span>0.0</span>
                        <span style="text-align: center; flex-grow: 1;">FPR</span>
                        <span>1.0</span>
                    </div>
                </div>
                </div>
                
                <!-- Compact Metrics Display -->
                <div class="roc_metrics-display" style="margin-top: 0; padding: 10px;">
                    <div class="roc_metrics-grid" style="grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div class="roc_metric-card" style="padding: 8px;">
                            <div class="roc_metric-name" style="font-size: 20px; margin-bottom: 5px;text-align: center;">TPR (True Positive Rate)</div>
                            <div class="roc_metric-formula" id="roc_tprFormula" style="min-height: 50px; font-size: 18px;">Loading...</div>
                            <div class="roc_metric-value" id="roc_tprValue" style="margin-top: 5px; font-size: 22px;">= 0.000</div>
                        </div>
                        <div class="roc_metric-card" style="padding: 8px;">
                            <div class="roc_metric-name" style="font-size: 20px; margin-bottom: 5px;text-align: center;">FPR (False Positive Rate)</div>
                            <div class="roc_metric-formula" id="roc_fprFormula" style="min-height: 50px; font-size: 18px;">Loading...</div>
                            <div class="roc_metric-value" id="roc_fprValue" style="margin-top: 5px; font-size: 22px;">= 0.000</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Ensure KaTeX is loaded completely before page init -->
    <script>
        // Wait for all resources to load, including KaTeX
        window.addEventListener('load', function() {
            // Initialize simulation
            roc_init();
        });
        
        function roc_init() {
            // DOM Elements
            const roc_canvas = document.getElementById('roc_canvas');
            const roc_ctx = roc_canvas.getContext('2d');
            const roc_rocCanvas = document.getElementById('roc_rocCanvas');
            const roc_rocCtx = roc_rocCanvas.getContext('2d');
            const roc_circleSizeSlider = document.getElementById('roc_circleSize');
            const roc_circleSizeFill = document.getElementById('roc_circleSizeFill');
            const roc_sizeValue = document.getElementById('roc_sizeValue');
        
            // Quadrant labels
            const roc_quadrantLabels = [
                document.getElementById('roc_quadrant0'),
                document.getElementById('roc_quadrant1'),
                document.getElementById('roc_quadrant2'),
                document.getElementById('roc_quadrant3')
            ];
            
            // Metric displays
            const roc_tprFormula = document.getElementById('roc_tprFormula');
            const roc_tprValue = document.getElementById('roc_tprValue');
            const roc_fprFormula = document.getElementById('roc_fprFormula');
            const roc_fprValue = document.getElementById('roc_fprValue');
            
            // Variables
            let roc_isDragging = false;
            let roc_truePositives = 0;
            let roc_falsePositives = 0;
            let roc_trueNegatives = 0;
            let roc_falseNegatives = 0;
            let roc_totalPoints = 0;
            let roc_points = [];
            let roc_rocPoints = [];
            let roc_currentSize = 0; // Track current circle size
            
            // Circle properties
            let roc_circleRadius;
            let roc_centerX;
            let roc_centerY;
            let roc_circleCenter = { x: 0.5, y: 0.5 }; // Normalized position (0-1)
            let roc_circleSizePercent = 0; // Percentage of min dimension
            let roc_dragStartPos = { x: 0, y: 0 };
            let roc_dragStartCenter = { x: 0, y: 0 };
            
            // Update slider fill
            function roc_updateSliderFill() {
                const percent = (roc_circleSizeSlider.value - roc_circleSizeSlider.min) / (roc_circleSizeSlider.max - roc_circleSizeSlider.min) * 100;
                roc_circleSizeFill.style.width = percent + '%';
            }
            
            // Initial slider fill update
            roc_updateSliderFill();
            
            // Setup slider events for changing circle size only
            function roc_setupSliderEvents() {
                // Update slider fill and add event listener
                roc_updateSliderFill();
                
                roc_circleSizeSlider.addEventListener('input', function() {
                    // Store previous and current size for ROC curve updating
                    const prevSize = roc_circleSizePercent;
                    roc_circleSizePercent = parseInt(this.value);
                    roc_currentSize = roc_circleSizePercent;
                    
                    roc_updateSliderFill();
                    roc_calculateDimensions();
                    roc_redrawCanvas();
                    roc_recalculateMetrics();
                    roc_updateLabels();
                    
                    // Update ROC curve based on whether size increased or decreased
                    if (roc_circleSizePercent > prevSize) {
                        roc_addROCPoint();
                    } else if (roc_circleSizePercent < prevSize) {
                        roc_removeROCPointsAboveSize(roc_circleSizePercent);
                    }
                    
                    roc_drawROCCurve();
                });
            }
            
            // Resize canvas to fit container
            function roc_resizeCanvas() {
                const container = roc_canvas.parentElement;
                roc_canvas.width = container.clientWidth;
                roc_canvas.height = container.clientHeight;
                
                const rocContainer = roc_rocCanvas.parentElement;
                roc_rocCanvas.width = rocContainer.clientWidth;
                roc_rocCanvas.height = rocContainer.clientHeight;
                
                roc_calculateDimensions();
                roc_redrawCanvas();
                roc_drawROCCurve();
                roc_updateLabels();
            }
            
            // Calculate circle dimensions based on canvas size and current settings
            function roc_calculateDimensions() {
                // Fixed center position (prevent dragging)
                roc_centerX = roc_canvas.width * 0.5;
                roc_centerY = roc_canvas.height * 0.5;
                const minDimension = Math.min(roc_canvas.width, roc_canvas.height);
                roc_circleRadius = minDimension * (roc_circleSizePercent / 100);
            }
            
            // Generate points
            function roc_generatePoints(count) {
                roc_points = [];
                
                // Generate half the points on the left side and half on the right
                for (let i = 0; i < count / 2; i++) {
                    // Left side point (Negatives)
                    roc_points.push({
                        x: Math.random() * (roc_canvas.width / 2 - 5),
                        y: Math.random() * roc_canvas.height
                    });
                    
                    // Right side point (Positives)
                    roc_points.push({
                        x: (roc_canvas.width / 2 + 5) + Math.random() * (roc_canvas.width / 2 - 10),
                        y: Math.random() * roc_canvas.height
                    });
                }
                
                roc_recalculateMetrics();
            }
            
            // Update the class metrics based on the points
            function roc_recalculateMetrics() {
                // Reset counts
                roc_truePositives = 0;
                roc_falsePositives = 0;
                roc_trueNegatives = 0;
                roc_falseNegatives = 0;
                
                // Recalculate counts for each point
                roc_points.forEach(point => {
                    const isRight = point.x >= roc_canvas.width / 2;
                    const isPredictedPositive = roc_isInsideCircle(point.x, point.y);
                    
                    if (isRight && isPredictedPositive) roc_truePositives++;
                    else if (!isRight && isPredictedPositive) roc_falsePositives++;
                    else if (!isRight && !isPredictedPositive) roc_trueNegatives++;
                    else if (isRight && !isPredictedPositive) roc_falseNegatives++;
                });
                
                roc_totalPoints = roc_points.length;
                
                // Update the metric displays
                roc_updateMetricDisplay();
            }
            
            // Update metric display
            function roc_updateMetricDisplay() {
                // Calculate TPR and FPR
                const tpr = roc_truePositives / (roc_truePositives + roc_falseNegatives) || 0;
                const fpr = roc_falsePositives / (roc_falsePositives + roc_trueNegatives) || 0;
                
                // Update display values with equal sign
                roc_tprValue.textContent = "= " + tpr.toFixed(3);
                roc_fprValue.textContent = "= " + fpr.toFixed(3);
                
                // Properly format the equations for KaTeX
                const tprFormulaText = `\\frac{TP}{TP + FN} = \\frac{${roc_truePositives}}{${roc_truePositives} + ${roc_falseNegatives}}`;
                const fprFormulaText = `\\frac{FP}{FP + TN} = \\frac{${roc_falsePositives}}{${roc_falsePositives} + ${roc_trueNegatives}}`;
                
                // Set the text content for later rendering
                roc_tprFormula.setAttribute('data-formula', tprFormulaText);
                roc_fprFormula.setAttribute('data-formula', fprFormulaText);
                
                // Render with KaTeX
                roc_renderFormulas();
            }
            
            // Properly format the equations for KaTeX with larger font
            function roc_renderFormulas() {
                try {
                    if (typeof katex !== 'undefined') {
                        const tprFormulaText = roc_tprFormula.getAttribute('data-formula');
                        const fprFormulaText = roc_fprFormula.getAttribute('data-formula');
                        
                        katex.render(tprFormulaText, roc_tprFormula, {
                            displayMode: true,
                            throwOnError: false,
                            fontSize: '1.2em' // Larger font size
                        });
                        
                        katex.render(fprFormulaText, roc_fprFormula, {
                            displayMode: true,
                            throwOnError: false,
                            fontSize: '1.2em' // Larger font size
                        });
                    } else {
                        console.error("KaTeX not available for rendering");
                        // Fallback to plain text if rendering fails
                        roc_tprFormula.textContent = roc_tprFormula.getAttribute('data-formula');
                        roc_fprFormula.textContent = roc_fprFormula.getAttribute('data-formula');
                    }
                } catch (error) {
                    console.error("KaTeX rendering error:", error);
                }
            }
            
            // Draw all points
            function roc_drawPoints() {
                roc_points.forEach(point => {
                    const isRight = point.x >= roc_canvas.width / 2;
                    
                    // Choose color based on actual class (left/right side)
                    if (isRight) {
                        roc_ctx.fillStyle = 'blue'; // Actual Positive (right side)
                    } else {
                        roc_ctx.fillStyle = 'red'; // Actual Negative (left side)
                    }
                    
                    roc_ctx.beginPath();
                    roc_ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                    roc_ctx.fill();
                });
            }
            
            // Redraw canvas with all points and current circle position
            function roc_redrawCanvas() {
                roc_ctx.clearRect(0, 0, roc_canvas.width, roc_canvas.height);
                
                // Draw points
                roc_drawPoints();
                
                // Draw dividing line
                roc_ctx.beginPath();
                roc_ctx.moveTo(roc_canvas.width / 2, 0);
                roc_ctx.lineTo(roc_canvas.width / 2, roc_canvas.height);
                roc_ctx.strokeStyle = 'black';
                roc_ctx.lineWidth = 2;
                roc_ctx.stroke();
                
                // Draw circle
                roc_ctx.beginPath();
                roc_ctx.arc(roc_centerX, roc_centerY, roc_circleRadius, 0, Math.PI * 2);
                roc_ctx.fillStyle = 'rgba(0, 0, 255, 0.15)';
                roc_ctx.fill();
                roc_ctx.strokeStyle = 'black'; // Changed to black for better visibility
                roc_ctx.lineWidth = 3;
                roc_ctx.stroke();
                
                // Draw border
                roc_ctx.strokeStyle = '#ddd';
                roc_ctx.lineWidth = 1;
                roc_ctx.strokeRect(0, 0, roc_canvas.width, roc_canvas.height);
            }
            
            // Draw the ROC curve
            function roc_drawROCCurve() {
                roc_rocCtx.clearRect(0, 0, roc_rocCanvas.width, roc_rocCanvas.height);
                
                            // Draw axes
            roc_rocCtx.beginPath();
            // Y-axis (left)
            roc_rocCtx.moveTo(0, roc_rocCanvas.height);
            roc_rocCtx.lineTo(0, 0);
            // X-axis (bottom)
            roc_rocCtx.moveTo(0, roc_rocCanvas.height);
            roc_rocCtx.lineTo(roc_rocCanvas.width, roc_rocCanvas.height);
            roc_rocCtx.stroke();

            // Y-axis label
            roc_rocCtx.save();
            roc_rocCtx.translate(20, roc_rocCanvas.height/2); // Adjust left position
            roc_rocCtx.rotate(-Math.PI/2);
            roc_rocCtx.restore();

            // Y-ticks (only 0 and 1)
            [0, 1].forEach(t => {
                const y = roc_rocCanvas.height - (t * roc_rocCanvas.height);
                // Tick
                roc_rocCtx.beginPath();
                roc_rocCtx.moveTo(0, y);
                roc_rocCtx.lineTo(5, y);
                roc_rocCtx.stroke();
                // Label
                roc_rocCtx.textAlign = "right";
                roc_rocCtx.fillText(t.toFixed(0), -8, y + 4);
            });

            // X-ticks (only 0 and 1)
            [0, 1].forEach(t => {
                const x = t * roc_rocCanvas.width;
                // Tick
                roc_rocCtx.beginPath();
                roc_rocCtx.moveTo(x, roc_rocCanvas.height);
                roc_rocCtx.lineTo(x, roc_rocCanvas.height - 5);
                roc_rocCtx.stroke();
                // Label
                roc_rocCtx.textAlign = "center";
                roc_rocCtx.fillText(t.toFixed(0), x, roc_rocCanvas.height + 20);
            });

            // X-axis label
                // Draw reference line (random classifier)
                roc_rocCtx.beginPath();
                roc_rocCtx.moveTo(0, roc_rocCanvas.height);
                roc_rocCtx.lineTo(roc_rocCanvas.width, 0);
                roc_rocCtx.strokeStyle = 'gray';
                roc_rocCtx.lineWidth = 1;
                roc_rocCtx.setLineDash([5, 5]);
                roc_rocCtx.stroke();
                roc_rocCtx.setLineDash([]);
                
                // Draw ROC curve points if we have any
                if (roc_rocPoints.length > 0) {
                    // Only draw line if there are multiple points (after user has moved the slider)
                    if (roc_rocPoints.length > 1) {
                        // Draw the curve connecting the points
                        roc_rocCtx.beginPath();
                        roc_rocCtx.moveTo(0, roc_rocCanvas.height); // Start at origin (0,1)
                        
                        // Sort points to ensure proper curve
                        const sortedPoints = [...roc_rocPoints].sort((a, b) => a.fpr - b.fpr);
                        
                        sortedPoints.forEach(point => {
                            const x = point.fpr * roc_rocCanvas.width;
                            const y = roc_rocCanvas.height - (point.tpr * roc_rocCanvas.height);
                            roc_rocCtx.lineTo(x, y);
                        });
                        
                        roc_rocCtx.strokeStyle = 'gray'; // Changed from blue to gray
                        roc_rocCtx.lineWidth = 2;
                        roc_rocCtx.stroke();
                        
                        // Draw points
                        sortedPoints.forEach(point => {
                            const x = point.fpr * roc_rocCanvas.width;
                            const y = roc_rocCanvas.height - (point.tpr * roc_rocCanvas.height);
                            
                            roc_rocCtx.beginPath();
                            roc_rocCtx.arc(x, y, 3, 0, Math.PI * 2);
                            roc_rocCtx.fillStyle = 'gray'; // Changed from blue to gray
                            roc_rocCtx.fill();
                        });
                    }
                    
                    // Draw current operating point
                    const tpr = roc_truePositives / (roc_truePositives + roc_falseNegatives) || 0;
                    const fpr = roc_falsePositives / (roc_falsePositives + roc_trueNegatives) || 0;
                    
                    const currentX = fpr * roc_rocCanvas.width;
                    const currentY = roc_rocCanvas.height - (tpr * roc_rocCanvas.height);
                    
                    roc_rocCtx.beginPath();
                    roc_rocCtx.arc(currentX, currentY, 6, 0, Math.PI * 2);
                    roc_rocCtx.fillStyle = 'gray'; // Changed from red to gray
                    roc_rocCtx.fill();
                    roc_rocCtx.strokeStyle = 'black';
                    roc_rocCtx.lineWidth = 1;
                    roc_rocCtx.stroke();
                }
            }
            
            // Add a new ROC point for current size
            function roc_addROCPoint() {
                const tpr = roc_truePositives / (roc_truePositives + roc_falseNegatives) || 0;
                const fpr = roc_falsePositives / (roc_falsePositives + roc_trueNegatives) || 0;
                
                // Check if we already have a point with the exact same size
                const existingPoint = roc_rocPoints.find(p => p.size === roc_circleSizePercent);
                
                if (existingPoint) {
                    // Update existing point
                    existingPoint.tpr = tpr;
                    existingPoint.fpr = fpr;
                } else {
                    // Add new point
                    roc_rocPoints.push({
                        tpr,
                        fpr,
                        size: roc_circleSizePercent
                    });
                }
                
                // Sort points by size
                roc_rocPoints.sort((a, b) => a.size - b.size);
            }
            
            // Remove ROC points above a certain size
            function roc_removeROCPointsAboveSize(size) {
                roc_rocPoints = roc_rocPoints.filter(point => point.size <= size);
            }
            
            // Update quadrant labels dynamically based on circle position
            function roc_updateLabels() {
                // Get vertical dividing line position
                const midX = roc_canvas.width / 2;
                
                // Check if circle overlaps with left or right half
                const leftEdge = roc_centerX - roc_circleRadius;
                const rightEdge = roc_centerX + roc_circleRadius;
                const topEdge = roc_centerY - roc_circleRadius;
                const bottomEdge = roc_centerY + roc_circleRadius;
                const overlapsLeft = leftEdge < midX;
                const overlapsRight = rightEdge > midX;
                
                // Padding to ensure labels stay within canvas
                const padding = 20;
                const labelWidth = 70;
                const labelHeight = 40;
                
                // 1. False Positives (inside circle, left side)
                if (overlapsLeft && roc_falsePositives > 0) {
                    const fpX = Math.max(padding, Math.min(midX - labelWidth - padding, roc_centerX - roc_circleRadius / 2));
                    const fpY = roc_centerY;
                    roc_quadrantLabels[0].style.display = 'block';
                    roc_quadrantLabels[0].style.left = fpX + 'px';
                    roc_quadrantLabels[0].style.top = fpY + 'px';
                } else {
                    roc_quadrantLabels[0].style.display = 'none';
                }
                
                // 2. True Positives (inside circle, right side)
                if (overlapsRight && roc_truePositives > 0) {
                    const tpX = Math.min(roc_canvas.width - labelWidth - padding, Math.max(midX + padding, roc_centerX + roc_circleRadius / 3));
                    const tpY = roc_centerY;
                    roc_quadrantLabels[1].style.display = 'block';
                    roc_quadrantLabels[1].style.left = tpX + 'px';
                    roc_quadrantLabels[1].style.top = tpY + 'px';
                } else {
                    roc_quadrantLabels[1].style.display = 'none';
                }
                
                // 3. True Negatives (outside circle, left side)
                // Only show if there's sufficient space between the circle and the edge
                const safeDistanceFromCircle = 50; // Minimum distance needed
                const distanceLeftEdge = leftEdge;
                
                if (roc_trueNegatives > 0 && distanceLeftEdge > safeDistanceFromCircle) {
                    const tnX = padding;
                    const tnY = padding;
                    roc_quadrantLabels[2].style.display = 'block';
                    roc_quadrantLabels[2].style.left = tnX + 'px';
                    roc_quadrantLabels[2].style.top = tnY + 'px';
                } else {
                    // Hide when circle gets too close
                    roc_quadrantLabels[2].style.display = 'none';
                }
                
                // 4. False Negatives (outside circle, right side)
                // Only show if there's sufficient space between the circle and right edge
                const distanceRightEdge = roc_canvas.width - rightEdge;
                
                if (roc_falseNegatives > 0 && distanceRightEdge > safeDistanceFromCircle) {
                    const fnX = roc_canvas.width - labelWidth - padding;
                    const fnY = padding;
                    roc_quadrantLabels[3].style.display = 'block';
                    roc_quadrantLabels[3].style.left = fnX + 'px';
                    roc_quadrantLabels[3].style.top = fnY + 'px';
                } else {
                    // Hide when circle gets too close
                    roc_quadrantLabels[3].style.display = 'none';
                }
            }
            
            // Check if a point is inside the circle
            function roc_isInsideCircle(x, y) {
                const dx = x - roc_centerX;
                const dy = y - roc_centerY;
                return (dx * dx + dy * dy) <= (roc_circleRadius * roc_circleRadius);
            }
            
            // Calculate distance from a point to the circle
            function roc_distanceToCircle(x, y) {
                const dx = x - roc_centerX;
                const dy = y - roc_centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return Math.max(0, distance - roc_circleRadius);
            }
            
            // Initialize the first ROC point for the starting size
            function roc_initROCPoint() {
                roc_rocPoints = [];
                roc_addROCPoint();
            }
            
            // Mouse events for dragging the circle
            function roc_setupDragEvents() {
                roc_canvas.addEventListener('mousedown', function(e) {
                    const rect = roc_canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Check if click is near the circle center
                    const dx = mouseX - roc_centerX;
                    const dy = mouseY - roc_centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= roc_circleRadius) {
                        roc_isDragging = true;
                        roc_dragStartPos = { x: mouseX, y: mouseY };
                        roc_dragStartCenter = { x: roc_circleCenter.x, y: roc_circleCenter.y };
                        roc_canvas.style.cursor = 'grabbing';
                    }
                });
                
                roc_canvas.addEventListener('mousemove', function(e) {
                    if (!roc_isDragging) return;
                    
                    const rect = roc_canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Calculate new center position
                    const dx = (mouseX - roc_dragStartPos.x) / roc_canvas.width;
                    const dy = (mouseY - roc_dragStartPos.y) / roc_canvas.height;
                    
                    roc_circleCenter.x = Math.max(0.1, Math.min(0.9, roc_dragStartCenter.x + dx));
                    roc_circleCenter.y = Math.max(0.1, Math.min(0.9, roc_dragStartCenter.y + dy));
                    
                    roc_calculateDimensions();
                    roc_redrawCanvas();
                    roc_recalculateMetrics();
                    roc_updateLabels();
                    roc_updateROCCurve();
                });
                
                roc_canvas.addEventListener('mouseup', function() {
                    if (roc_isDragging) {
                        roc_isDragging = false;
                        roc_canvas.style.cursor = 'move';
                    }
                });
                
                roc_canvas.addEventListener('mouseleave', function() {
                    if (roc_isDragging) {
                        roc_isDragging = false;
                        roc_canvas.style.cursor = 'move';
                    }
                });
                
                // Set initial cursor
                roc_canvas.style.cursor = 'move';
            }
            
            // Touch events for mobile
            function roc_setupTouchEvents() {
                roc_canvas.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    const rect = roc_canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    
                    // Check if touch is near the circle center
                    const dx = touchX - roc_centerX;
                    const dy = touchY - roc_centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= roc_circleRadius) {
                        roc_isDragging = true;
                        roc_dragStartPos = { x: touchX, y: touchY };
                        roc_dragStartCenter = { x: roc_circleCenter.x, y: roc_circleCenter.y };
                    }
                });
                
                roc_canvas.addEventListener('touchmove', function(e) {
                    if (!roc_isDragging) return;
                    e.preventDefault();
                    
                    const rect = roc_canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    
                    // Calculate new center position
                    const dx = (touchX - roc_dragStartPos.x) / roc_canvas.width;
                    const dy = (touchY - roc_dragStartPos.y) / roc_canvas.height;
                    
                    roc_circleCenter.x = Math.max(0.1, Math.min(0.9, roc_dragStartCenter.x + dx));
                    roc_circleCenter.y = Math.max(0.1, Math.min(0.9, roc_dragStartCenter.y + dy));
                    
                    roc_calculateDimensions();
                    roc_redrawCanvas();
                    roc_recalculateMetrics();
                    roc_updateLabels();
                    roc_updateROCCurve();
                });
                
                roc_canvas.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    roc_isDragging = false;
                });
            }
            
            // Set canvas dimensions
            roc_resizeCanvas();
            
            // Setup events
            roc_setupSliderEvents();
            roc_setupTouchEvents(); // Simple touch events for slider only
            
            // Generate many more points
            roc_generatePoints(10000);
            
            // Initial calculations and rendering
            roc_calculateDimensions();
            roc_recalculateMetrics();
            roc_redrawCanvas();
            roc_updateLabels();
            
            // Initialize the ROC point for current size
            roc_initROCPoint();
            
            // Draw ROC curve
            roc_drawROCCurve();
            
            // Render formulas
            roc_renderFormulas();
            
            // Handle window resize
            window.addEventListener('resize', function() {
                roc_resizeCanvas();
                roc_redrawCanvas();
                roc_drawROCCurve();
                roc_updateLabels();
            });
        }
    </script>
</body>
</html>